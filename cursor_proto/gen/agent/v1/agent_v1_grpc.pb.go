// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: agent_v1.proto

package agentv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentService_Run_FullMethodName                    = "/agent.v1.AgentService/Run"
	AgentService_RunSSE_FullMethodName                 = "/agent.v1.AgentService/RunSSE"
	AgentService_RunPoll_FullMethodName                = "/agent.v1.AgentService/RunPoll"
	AgentService_NameAgent_FullMethodName              = "/agent.v1.AgentService/NameAgent"
	AgentService_GetUsableModels_FullMethodName        = "/agent.v1.AgentService/GetUsableModels"
	AgentService_GetDefaultModelForCli_FullMethodName  = "/agent.v1.AgentService/GetDefaultModelForCli"
	AgentService_GetAllowedModelIntents_FullMethodName = "/agent.v1.AgentService/GetAllowedModelIntents"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.AgentService (var: Z$e)
type AgentServiceClient interface {
	Run(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AgentClientMessage, AgentServerMessage], error)
	RunSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentServerMessage], error)
	RunPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	NameAgent(ctx context.Context, in *NameAgentRequest, opts ...grpc.CallOption) (*NameAgentResponse, error)
	GetUsableModels(ctx context.Context, in *GetUsableModelsRequest, opts ...grpc.CallOption) (*GetUsableModelsResponse, error)
	GetDefaultModelForCli(ctx context.Context, in *GetDefaultModelForCliRequest, opts ...grpc.CallOption) (*GetDefaultModelForCliResponse, error)
	GetAllowedModelIntents(ctx context.Context, in *GetAllowedModelIntentsRequest, opts ...grpc.CallOption) (*GetAllowedModelIntentsResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) Run(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AgentClientMessage, AgentServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[0], AgentService_Run_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AgentClientMessage, AgentServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunClient = grpc.BidiStreamingClient[AgentClientMessage, AgentServerMessage]

func (c *agentServiceClient) RunSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[1], AgentService_RunSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, AgentServerMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunSSEClient = grpc.ServerStreamingClient[AgentServerMessage]

func (c *agentServiceClient) RunPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[2], AgentService_RunPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *agentServiceClient) NameAgent(ctx context.Context, in *NameAgentRequest, opts ...grpc.CallOption) (*NameAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NameAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_NameAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetUsableModels(ctx context.Context, in *GetUsableModelsRequest, opts ...grpc.CallOption) (*GetUsableModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsableModelsResponse)
	err := c.cc.Invoke(ctx, AgentService_GetUsableModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetDefaultModelForCli(ctx context.Context, in *GetDefaultModelForCliRequest, opts ...grpc.CallOption) (*GetDefaultModelForCliResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDefaultModelForCliResponse)
	err := c.cc.Invoke(ctx, AgentService_GetDefaultModelForCli_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAllowedModelIntents(ctx context.Context, in *GetAllowedModelIntentsRequest, opts ...grpc.CallOption) (*GetAllowedModelIntentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllowedModelIntentsResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAllowedModelIntents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
//
// Source: agent.v1.AgentService (var: Z$e)
type AgentServiceServer interface {
	Run(grpc.BidiStreamingServer[AgentClientMessage, AgentServerMessage]) error
	RunSSE(*BidiRequestId, grpc.ServerStreamingServer[AgentServerMessage]) error
	RunPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	NameAgent(context.Context, *NameAgentRequest) (*NameAgentResponse, error)
	GetUsableModels(context.Context, *GetUsableModelsRequest) (*GetUsableModelsResponse, error)
	GetDefaultModelForCli(context.Context, *GetDefaultModelForCliRequest) (*GetDefaultModelForCliResponse, error)
	GetAllowedModelIntents(context.Context, *GetAllowedModelIntentsRequest) (*GetAllowedModelIntentsResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) Run(grpc.BidiStreamingServer[AgentClientMessage, AgentServerMessage]) error {
	return status.Error(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedAgentServiceServer) RunSSE(*BidiRequestId, grpc.ServerStreamingServer[AgentServerMessage]) error {
	return status.Error(codes.Unimplemented, "method RunSSE not implemented")
}
func (UnimplementedAgentServiceServer) RunPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method RunPoll not implemented")
}
func (UnimplementedAgentServiceServer) NameAgent(context.Context, *NameAgentRequest) (*NameAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NameAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetUsableModels(context.Context, *GetUsableModelsRequest) (*GetUsableModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUsableModels not implemented")
}
func (UnimplementedAgentServiceServer) GetDefaultModelForCli(context.Context, *GetDefaultModelForCliRequest) (*GetDefaultModelForCliResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDefaultModelForCli not implemented")
}
func (UnimplementedAgentServiceServer) GetAllowedModelIntents(context.Context, *GetAllowedModelIntentsRequest) (*GetAllowedModelIntentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllowedModelIntents not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServiceServer).Run(&grpc.GenericServerStream[AgentClientMessage, AgentServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunServer = grpc.BidiStreamingServer[AgentClientMessage, AgentServerMessage]

func _AgentService_RunSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).RunSSE(m, &grpc.GenericServerStream[BidiRequestId, AgentServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunSSEServer = grpc.ServerStreamingServer[AgentServerMessage]

func _AgentService_RunPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).RunPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_RunPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _AgentService_NameAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).NameAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_NameAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).NameAgent(ctx, req.(*NameAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetUsableModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsableModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetUsableModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetUsableModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetUsableModels(ctx, req.(*GetUsableModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetDefaultModelForCli_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultModelForCliRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetDefaultModelForCli(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetDefaultModelForCli_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetDefaultModelForCli(ctx, req.(*GetDefaultModelForCliRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAllowedModelIntents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllowedModelIntentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAllowedModelIntents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAllowedModelIntents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAllowedModelIntents(ctx, req.(*GetAllowedModelIntentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NameAgent",
			Handler:    _AgentService_NameAgent_Handler,
		},
		{
			MethodName: "GetUsableModels",
			Handler:    _AgentService_GetUsableModels_Handler,
		},
		{
			MethodName: "GetDefaultModelForCli",
			Handler:    _AgentService_GetDefaultModelForCli_Handler,
		},
		{
			MethodName: "GetAllowedModelIntents",
			Handler:    _AgentService_GetAllowedModelIntents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _AgentService_Run_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RunSSE",
			Handler:       _AgentService_RunSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunPoll",
			Handler:       _AgentService_RunPoll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent_v1.proto",
}

const (
	ControlService_Ping_FullMethodName                       = "/agent.v1.ControlService/Ping"
	ControlService_Exec_FullMethodName                       = "/agent.v1.ControlService/Exec"
	ControlService_ListDirectory_FullMethodName              = "/agent.v1.ControlService/ListDirectory"
	ControlService_ReadTextFile_FullMethodName               = "/agent.v1.ControlService/ReadTextFile"
	ControlService_WriteTextFile_FullMethodName              = "/agent.v1.ControlService/WriteTextFile"
	ControlService_ReadBinaryFile_FullMethodName             = "/agent.v1.ControlService/ReadBinaryFile"
	ControlService_WriteBinaryFile_FullMethodName            = "/agent.v1.ControlService/WriteBinaryFile"
	ControlService_GetDiff_FullMethodName                    = "/agent.v1.ControlService/GetDiff"
	ControlService_GetWorkspaceChangesHash_FullMethodName    = "/agent.v1.ControlService/GetWorkspaceChangesHash"
	ControlService_RefreshGithubAccessToken_FullMethodName   = "/agent.v1.ControlService/RefreshGithubAccessToken"
	ControlService_WarmRemoteAccessServer_FullMethodName     = "/agent.v1.ControlService/WarmRemoteAccessServer"
	ControlService_ListArtifacts_FullMethodName              = "/agent.v1.ControlService/ListArtifacts"
	ControlService_UploadArtifacts_FullMethodName            = "/agent.v1.ControlService/UploadArtifacts"
	ControlService_GetMcpRefreshTokens_FullMethodName        = "/agent.v1.ControlService/GetMcpRefreshTokens"
	ControlService_UpdateEnvironmentVariables_FullMethodName = "/agent.v1.ControlService/UpdateEnvironmentVariables"
)

// ControlServiceClient is the client API for ControlService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.ControlService (var: eWe)
type ControlServiceClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResponse], error)
	ListDirectory(ctx context.Context, in *ListDirectoryRequest, opts ...grpc.CallOption) (*ListDirectoryResponse, error)
	ReadTextFile(ctx context.Context, in *ReadTextFileRequest, opts ...grpc.CallOption) (*ReadTextFileResponse, error)
	WriteTextFile(ctx context.Context, in *WriteTextFileRequest, opts ...grpc.CallOption) (*WriteTextFileResponse, error)
	ReadBinaryFile(ctx context.Context, in *ReadBinaryFileRequest, opts ...grpc.CallOption) (*ReadBinaryFileResponse, error)
	WriteBinaryFile(ctx context.Context, in *WriteBinaryFileRequest, opts ...grpc.CallOption) (*WriteBinaryFileResponse, error)
	GetDiff(ctx context.Context, in *GetDiffRequest, opts ...grpc.CallOption) (*GetDiffResponse, error)
	GetWorkspaceChangesHash(ctx context.Context, in *GetWorkspaceChangesHashRequest, opts ...grpc.CallOption) (*GetWorkspaceChangesHashResponse, error)
	RefreshGithubAccessToken(ctx context.Context, in *RefreshGithubAccessTokenRequest, opts ...grpc.CallOption) (*RefreshGithubAccessTokenResponse, error)
	WarmRemoteAccessServer(ctx context.Context, in *WarmRemoteAccessServerRequest, opts ...grpc.CallOption) (*WarmRemoteAccessServerResponse, error)
	ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error)
	UploadArtifacts(ctx context.Context, in *UploadArtifactsRequest, opts ...grpc.CallOption) (*UploadArtifactsResponse, error)
	GetMcpRefreshTokens(ctx context.Context, in *GetMcpRefreshTokensRequest, opts ...grpc.CallOption) (*GetMcpRefreshTokensResponse, error)
	UpdateEnvironmentVariables(ctx context.Context, in *UpdateEnvironmentVariablesRequest, opts ...grpc.CallOption) (*UpdateEnvironmentVariablesResponse, error)
}

type controlServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewControlServiceClient(cc grpc.ClientConnInterface) ControlServiceClient {
	return &controlServiceClient{cc}
}

func (c *controlServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, ControlService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ControlService_ServiceDesc.Streams[0], ControlService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecRequest, ExecResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControlService_ExecClient = grpc.ServerStreamingClient[ExecResponse]

func (c *controlServiceClient) ListDirectory(ctx context.Context, in *ListDirectoryRequest, opts ...grpc.CallOption) (*ListDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDirectoryResponse)
	err := c.cc.Invoke(ctx, ControlService_ListDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ReadTextFile(ctx context.Context, in *ReadTextFileRequest, opts ...grpc.CallOption) (*ReadTextFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadTextFileResponse)
	err := c.cc.Invoke(ctx, ControlService_ReadTextFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) WriteTextFile(ctx context.Context, in *WriteTextFileRequest, opts ...grpc.CallOption) (*WriteTextFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteTextFileResponse)
	err := c.cc.Invoke(ctx, ControlService_WriteTextFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ReadBinaryFile(ctx context.Context, in *ReadBinaryFileRequest, opts ...grpc.CallOption) (*ReadBinaryFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadBinaryFileResponse)
	err := c.cc.Invoke(ctx, ControlService_ReadBinaryFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) WriteBinaryFile(ctx context.Context, in *WriteBinaryFileRequest, opts ...grpc.CallOption) (*WriteBinaryFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteBinaryFileResponse)
	err := c.cc.Invoke(ctx, ControlService_WriteBinaryFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) GetDiff(ctx context.Context, in *GetDiffRequest, opts ...grpc.CallOption) (*GetDiffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDiffResponse)
	err := c.cc.Invoke(ctx, ControlService_GetDiff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) GetWorkspaceChangesHash(ctx context.Context, in *GetWorkspaceChangesHashRequest, opts ...grpc.CallOption) (*GetWorkspaceChangesHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkspaceChangesHashResponse)
	err := c.cc.Invoke(ctx, ControlService_GetWorkspaceChangesHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) RefreshGithubAccessToken(ctx context.Context, in *RefreshGithubAccessTokenRequest, opts ...grpc.CallOption) (*RefreshGithubAccessTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshGithubAccessTokenResponse)
	err := c.cc.Invoke(ctx, ControlService_RefreshGithubAccessToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) WarmRemoteAccessServer(ctx context.Context, in *WarmRemoteAccessServerRequest, opts ...grpc.CallOption) (*WarmRemoteAccessServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmRemoteAccessServerResponse)
	err := c.cc.Invoke(ctx, ControlService_WarmRemoteAccessServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArtifactsResponse)
	err := c.cc.Invoke(ctx, ControlService_ListArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) UploadArtifacts(ctx context.Context, in *UploadArtifactsRequest, opts ...grpc.CallOption) (*UploadArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadArtifactsResponse)
	err := c.cc.Invoke(ctx, ControlService_UploadArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) GetMcpRefreshTokens(ctx context.Context, in *GetMcpRefreshTokensRequest, opts ...grpc.CallOption) (*GetMcpRefreshTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMcpRefreshTokensResponse)
	err := c.cc.Invoke(ctx, ControlService_GetMcpRefreshTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) UpdateEnvironmentVariables(ctx context.Context, in *UpdateEnvironmentVariablesRequest, opts ...grpc.CallOption) (*UpdateEnvironmentVariablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateEnvironmentVariablesResponse)
	err := c.cc.Invoke(ctx, ControlService_UpdateEnvironmentVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControlServiceServer is the server API for ControlService service.
// All implementations must embed UnimplementedControlServiceServer
// for forward compatibility.
//
// Source: agent.v1.ControlService (var: eWe)
type ControlServiceServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	Exec(*ExecRequest, grpc.ServerStreamingServer[ExecResponse]) error
	ListDirectory(context.Context, *ListDirectoryRequest) (*ListDirectoryResponse, error)
	ReadTextFile(context.Context, *ReadTextFileRequest) (*ReadTextFileResponse, error)
	WriteTextFile(context.Context, *WriteTextFileRequest) (*WriteTextFileResponse, error)
	ReadBinaryFile(context.Context, *ReadBinaryFileRequest) (*ReadBinaryFileResponse, error)
	WriteBinaryFile(context.Context, *WriteBinaryFileRequest) (*WriteBinaryFileResponse, error)
	GetDiff(context.Context, *GetDiffRequest) (*GetDiffResponse, error)
	GetWorkspaceChangesHash(context.Context, *GetWorkspaceChangesHashRequest) (*GetWorkspaceChangesHashResponse, error)
	RefreshGithubAccessToken(context.Context, *RefreshGithubAccessTokenRequest) (*RefreshGithubAccessTokenResponse, error)
	WarmRemoteAccessServer(context.Context, *WarmRemoteAccessServerRequest) (*WarmRemoteAccessServerResponse, error)
	ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error)
	UploadArtifacts(context.Context, *UploadArtifactsRequest) (*UploadArtifactsResponse, error)
	GetMcpRefreshTokens(context.Context, *GetMcpRefreshTokensRequest) (*GetMcpRefreshTokensResponse, error)
	UpdateEnvironmentVariables(context.Context, *UpdateEnvironmentVariablesRequest) (*UpdateEnvironmentVariablesResponse, error)
	mustEmbedUnimplementedControlServiceServer()
}

// UnimplementedControlServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedControlServiceServer struct{}

func (UnimplementedControlServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedControlServiceServer) Exec(*ExecRequest, grpc.ServerStreamingServer[ExecResponse]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedControlServiceServer) ListDirectory(context.Context, *ListDirectoryRequest) (*ListDirectoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDirectory not implemented")
}
func (UnimplementedControlServiceServer) ReadTextFile(context.Context, *ReadTextFileRequest) (*ReadTextFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadTextFile not implemented")
}
func (UnimplementedControlServiceServer) WriteTextFile(context.Context, *WriteTextFileRequest) (*WriteTextFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteTextFile not implemented")
}
func (UnimplementedControlServiceServer) ReadBinaryFile(context.Context, *ReadBinaryFileRequest) (*ReadBinaryFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadBinaryFile not implemented")
}
func (UnimplementedControlServiceServer) WriteBinaryFile(context.Context, *WriteBinaryFileRequest) (*WriteBinaryFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteBinaryFile not implemented")
}
func (UnimplementedControlServiceServer) GetDiff(context.Context, *GetDiffRequest) (*GetDiffResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDiff not implemented")
}
func (UnimplementedControlServiceServer) GetWorkspaceChangesHash(context.Context, *GetWorkspaceChangesHashRequest) (*GetWorkspaceChangesHashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetWorkspaceChangesHash not implemented")
}
func (UnimplementedControlServiceServer) RefreshGithubAccessToken(context.Context, *RefreshGithubAccessTokenRequest) (*RefreshGithubAccessTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshGithubAccessToken not implemented")
}
func (UnimplementedControlServiceServer) WarmRemoteAccessServer(context.Context, *WarmRemoteAccessServerRequest) (*WarmRemoteAccessServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmRemoteAccessServer not implemented")
}
func (UnimplementedControlServiceServer) ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListArtifacts not implemented")
}
func (UnimplementedControlServiceServer) UploadArtifacts(context.Context, *UploadArtifactsRequest) (*UploadArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadArtifacts not implemented")
}
func (UnimplementedControlServiceServer) GetMcpRefreshTokens(context.Context, *GetMcpRefreshTokensRequest) (*GetMcpRefreshTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMcpRefreshTokens not implemented")
}
func (UnimplementedControlServiceServer) UpdateEnvironmentVariables(context.Context, *UpdateEnvironmentVariablesRequest) (*UpdateEnvironmentVariablesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateEnvironmentVariables not implemented")
}
func (UnimplementedControlServiceServer) mustEmbedUnimplementedControlServiceServer() {}
func (UnimplementedControlServiceServer) testEmbeddedByValue()                        {}

// UnsafeControlServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControlServiceServer will
// result in compilation errors.
type UnsafeControlServiceServer interface {
	mustEmbedUnimplementedControlServiceServer()
}

func RegisterControlServiceServer(s grpc.ServiceRegistrar, srv ControlServiceServer) {
	// If the following call panics, it indicates UnimplementedControlServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ControlService_ServiceDesc, srv)
}

func _ControlService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControlServiceServer).Exec(m, &grpc.GenericServerStream[ExecRequest, ExecResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControlService_ExecServer = grpc.ServerStreamingServer[ExecResponse]

func _ControlService_ListDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ListDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ListDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ListDirectory(ctx, req.(*ListDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ReadTextFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadTextFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ReadTextFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ReadTextFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ReadTextFile(ctx, req.(*ReadTextFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_WriteTextFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteTextFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).WriteTextFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_WriteTextFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).WriteTextFile(ctx, req.(*WriteTextFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ReadBinaryFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadBinaryFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ReadBinaryFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ReadBinaryFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ReadBinaryFile(ctx, req.(*ReadBinaryFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_WriteBinaryFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteBinaryFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).WriteBinaryFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_WriteBinaryFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).WriteBinaryFile(ctx, req.(*WriteBinaryFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_GetDiff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).GetDiff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_GetDiff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).GetDiff(ctx, req.(*GetDiffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_GetWorkspaceChangesHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkspaceChangesHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).GetWorkspaceChangesHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_GetWorkspaceChangesHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).GetWorkspaceChangesHash(ctx, req.(*GetWorkspaceChangesHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_RefreshGithubAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshGithubAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).RefreshGithubAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_RefreshGithubAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).RefreshGithubAccessToken(ctx, req.(*RefreshGithubAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_WarmRemoteAccessServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WarmRemoteAccessServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).WarmRemoteAccessServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_WarmRemoteAccessServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).WarmRemoteAccessServer(ctx, req.(*WarmRemoteAccessServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_ListArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).ListArtifacts(ctx, req.(*ListArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_UploadArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).UploadArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_UploadArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).UploadArtifacts(ctx, req.(*UploadArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_GetMcpRefreshTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMcpRefreshTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).GetMcpRefreshTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_GetMcpRefreshTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).GetMcpRefreshTokens(ctx, req.(*GetMcpRefreshTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_UpdateEnvironmentVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEnvironmentVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).UpdateEnvironmentVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControlService_UpdateEnvironmentVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).UpdateEnvironmentVariables(ctx, req.(*UpdateEnvironmentVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ControlService_ServiceDesc is the grpc.ServiceDesc for ControlService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControlService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.ControlService",
	HandlerType: (*ControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _ControlService_Ping_Handler,
		},
		{
			MethodName: "ListDirectory",
			Handler:    _ControlService_ListDirectory_Handler,
		},
		{
			MethodName: "ReadTextFile",
			Handler:    _ControlService_ReadTextFile_Handler,
		},
		{
			MethodName: "WriteTextFile",
			Handler:    _ControlService_WriteTextFile_Handler,
		},
		{
			MethodName: "ReadBinaryFile",
			Handler:    _ControlService_ReadBinaryFile_Handler,
		},
		{
			MethodName: "WriteBinaryFile",
			Handler:    _ControlService_WriteBinaryFile_Handler,
		},
		{
			MethodName: "GetDiff",
			Handler:    _ControlService_GetDiff_Handler,
		},
		{
			MethodName: "GetWorkspaceChangesHash",
			Handler:    _ControlService_GetWorkspaceChangesHash_Handler,
		},
		{
			MethodName: "RefreshGithubAccessToken",
			Handler:    _ControlService_RefreshGithubAccessToken_Handler,
		},
		{
			MethodName: "WarmRemoteAccessServer",
			Handler:    _ControlService_WarmRemoteAccessServer_Handler,
		},
		{
			MethodName: "ListArtifacts",
			Handler:    _ControlService_ListArtifacts_Handler,
		},
		{
			MethodName: "UploadArtifacts",
			Handler:    _ControlService_UploadArtifacts_Handler,
		},
		{
			MethodName: "GetMcpRefreshTokens",
			Handler:    _ControlService_GetMcpRefreshTokens_Handler,
		},
		{
			MethodName: "UpdateEnvironmentVariables",
			Handler:    _ControlService_UpdateEnvironmentVariables_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _ControlService_Exec_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent_v1.proto",
}

const (
	ExecService_Exec_FullMethodName = "/agent.v1.ExecService/Exec"
)

// ExecServiceClient is the client API for ExecService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.ExecService (var: tWe)
type ExecServiceClient interface {
	Exec(ctx context.Context, in *ExecServerMessage, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecStreamElement], error)
}

type execServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExecServiceClient(cc grpc.ClientConnInterface) ExecServiceClient {
	return &execServiceClient{cc}
}

func (c *execServiceClient) Exec(ctx context.Context, in *ExecServerMessage, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ExecStreamElement], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ExecService_ServiceDesc.Streams[0], ExecService_Exec_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecServerMessage, ExecStreamElement]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExecService_ExecClient = grpc.ServerStreamingClient[ExecStreamElement]

// ExecServiceServer is the server API for ExecService service.
// All implementations must embed UnimplementedExecServiceServer
// for forward compatibility.
//
// Source: agent.v1.ExecService (var: tWe)
type ExecServiceServer interface {
	Exec(*ExecServerMessage, grpc.ServerStreamingServer[ExecStreamElement]) error
	mustEmbedUnimplementedExecServiceServer()
}

// UnimplementedExecServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExecServiceServer struct{}

func (UnimplementedExecServiceServer) Exec(*ExecServerMessage, grpc.ServerStreamingServer[ExecStreamElement]) error {
	return status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedExecServiceServer) mustEmbedUnimplementedExecServiceServer() {}
func (UnimplementedExecServiceServer) testEmbeddedByValue()                     {}

// UnsafeExecServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecServiceServer will
// result in compilation errors.
type UnsafeExecServiceServer interface {
	mustEmbedUnimplementedExecServiceServer()
}

func RegisterExecServiceServer(s grpc.ServiceRegistrar, srv ExecServiceServer) {
	// If the following call panics, it indicates UnimplementedExecServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExecService_ServiceDesc, srv)
}

func _ExecService_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecServerMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecServiceServer).Exec(m, &grpc.GenericServerStream[ExecServerMessage, ExecStreamElement]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExecService_ExecServer = grpc.ServerStreamingServer[ExecStreamElement]

// ExecService_ServiceDesc is the grpc.ServiceDesc for ExecService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.ExecService",
	HandlerType: (*ExecServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _ExecService_Exec_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent_v1.proto",
}

const (
	LifecycleService_ResetInstance_FullMethodName = "/agent.v1.LifecycleService/ResetInstance"
	LifecycleService_RenewInstance_FullMethodName = "/agent.v1.LifecycleService/RenewInstance"
)

// LifecycleServiceClient is the client API for LifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.LifecycleService (var: iWe)
type LifecycleServiceClient interface {
	ResetInstance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	RenewInstance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type lifecycleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLifecycleServiceClient(cc grpc.ClientConnInterface) LifecycleServiceClient {
	return &lifecycleServiceClient{cc}
}

func (c *lifecycleServiceClient) ResetInstance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LifecycleService_ResetInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lifecycleServiceClient) RenewInstance(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, LifecycleService_RenewInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LifecycleServiceServer is the server API for LifecycleService service.
// All implementations must embed UnimplementedLifecycleServiceServer
// for forward compatibility.
//
// Source: agent.v1.LifecycleService (var: iWe)
type LifecycleServiceServer interface {
	ResetInstance(context.Context, *Empty) (*Empty, error)
	RenewInstance(context.Context, *Empty) (*Empty, error)
	mustEmbedUnimplementedLifecycleServiceServer()
}

// UnimplementedLifecycleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLifecycleServiceServer struct{}

func (UnimplementedLifecycleServiceServer) ResetInstance(context.Context, *Empty) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetInstance not implemented")
}
func (UnimplementedLifecycleServiceServer) RenewInstance(context.Context, *Empty) (*Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RenewInstance not implemented")
}
func (UnimplementedLifecycleServiceServer) mustEmbedUnimplementedLifecycleServiceServer() {}
func (UnimplementedLifecycleServiceServer) testEmbeddedByValue()                          {}

// UnsafeLifecycleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LifecycleServiceServer will
// result in compilation errors.
type UnsafeLifecycleServiceServer interface {
	mustEmbedUnimplementedLifecycleServiceServer()
}

func RegisterLifecycleServiceServer(s grpc.ServiceRegistrar, srv LifecycleServiceServer) {
	// If the following call panics, it indicates UnimplementedLifecycleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LifecycleService_ServiceDesc, srv)
}

func _LifecycleService_ResetInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LifecycleServiceServer).ResetInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LifecycleService_ResetInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LifecycleServiceServer).ResetInstance(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LifecycleService_RenewInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LifecycleServiceServer).RenewInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LifecycleService_RenewInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LifecycleServiceServer).RenewInstance(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// LifecycleService_ServiceDesc is the grpc.ServiceDesc for LifecycleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LifecycleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.LifecycleService",
	HandlerType: (*LifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResetInstance",
			Handler:    _LifecycleService_ResetInstance_Handler,
		},
		{
			MethodName: "RenewInstance",
			Handler:    _LifecycleService_RenewInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent_v1.proto",
}

const (
	PrivateWorkerBridgeExternalService_Connect_FullMethodName = "/agent.v1.PrivateWorkerBridgeExternalService/Connect"
)

// PrivateWorkerBridgeExternalServiceClient is the client API for PrivateWorkerBridgeExternalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.PrivateWorkerBridgeExternalService (var: nWe)
type PrivateWorkerBridgeExternalServiceClient interface {
	Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Frame, Frame], error)
}

type privateWorkerBridgeExternalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPrivateWorkerBridgeExternalServiceClient(cc grpc.ClientConnInterface) PrivateWorkerBridgeExternalServiceClient {
	return &privateWorkerBridgeExternalServiceClient{cc}
}

func (c *privateWorkerBridgeExternalServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Frame, Frame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PrivateWorkerBridgeExternalService_ServiceDesc.Streams[0], PrivateWorkerBridgeExternalService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Frame, Frame]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PrivateWorkerBridgeExternalService_ConnectClient = grpc.BidiStreamingClient[Frame, Frame]

// PrivateWorkerBridgeExternalServiceServer is the server API for PrivateWorkerBridgeExternalService service.
// All implementations must embed UnimplementedPrivateWorkerBridgeExternalServiceServer
// for forward compatibility.
//
// Source: agent.v1.PrivateWorkerBridgeExternalService (var: nWe)
type PrivateWorkerBridgeExternalServiceServer interface {
	Connect(grpc.BidiStreamingServer[Frame, Frame]) error
	mustEmbedUnimplementedPrivateWorkerBridgeExternalServiceServer()
}

// UnimplementedPrivateWorkerBridgeExternalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPrivateWorkerBridgeExternalServiceServer struct{}

func (UnimplementedPrivateWorkerBridgeExternalServiceServer) Connect(grpc.BidiStreamingServer[Frame, Frame]) error {
	return status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedPrivateWorkerBridgeExternalServiceServer) mustEmbedUnimplementedPrivateWorkerBridgeExternalServiceServer() {
}
func (UnimplementedPrivateWorkerBridgeExternalServiceServer) testEmbeddedByValue() {}

// UnsafePrivateWorkerBridgeExternalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PrivateWorkerBridgeExternalServiceServer will
// result in compilation errors.
type UnsafePrivateWorkerBridgeExternalServiceServer interface {
	mustEmbedUnimplementedPrivateWorkerBridgeExternalServiceServer()
}

func RegisterPrivateWorkerBridgeExternalServiceServer(s grpc.ServiceRegistrar, srv PrivateWorkerBridgeExternalServiceServer) {
	// If the following call panics, it indicates UnimplementedPrivateWorkerBridgeExternalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PrivateWorkerBridgeExternalService_ServiceDesc, srv)
}

func _PrivateWorkerBridgeExternalService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PrivateWorkerBridgeExternalServiceServer).Connect(&grpc.GenericServerStream[Frame, Frame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PrivateWorkerBridgeExternalService_ConnectServer = grpc.BidiStreamingServer[Frame, Frame]

// PrivateWorkerBridgeExternalService_ServiceDesc is the grpc.ServiceDesc for PrivateWorkerBridgeExternalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PrivateWorkerBridgeExternalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.PrivateWorkerBridgeExternalService",
	HandlerType: (*PrivateWorkerBridgeExternalServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _PrivateWorkerBridgeExternalService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "agent_v1.proto",
}

const (
	PtyHostService_SpawnPty_FullMethodName     = "/agent.v1.PtyHostService/SpawnPty"
	PtyHostService_AttachPty_FullMethodName    = "/agent.v1.PtyHostService/AttachPty"
	PtyHostService_SendInput_FullMethodName    = "/agent.v1.PtyHostService/SendInput"
	PtyHostService_ResizePty_FullMethodName    = "/agent.v1.PtyHostService/ResizePty"
	PtyHostService_ListPtys_FullMethodName     = "/agent.v1.PtyHostService/ListPtys"
	PtyHostService_TerminatePty_FullMethodName = "/agent.v1.PtyHostService/TerminatePty"
)

// PtyHostServiceClient is the client API for PtyHostService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: agent.v1.PtyHostService (var: rWe)
type PtyHostServiceClient interface {
	SpawnPty(ctx context.Context, in *SpawnPtyRequest, opts ...grpc.CallOption) (*SpawnPtyResponse, error)
	AttachPty(ctx context.Context, in *AttachPtyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PtyEvent], error)
	SendInput(ctx context.Context, in *SendInputRequest, opts ...grpc.CallOption) (*SendInputResponse, error)
	ResizePty(ctx context.Context, in *ResizePtyRequest, opts ...grpc.CallOption) (*ResizePtyResponse, error)
	ListPtys(ctx context.Context, in *ListPtysRequest, opts ...grpc.CallOption) (*ListPtysResponse, error)
	TerminatePty(ctx context.Context, in *TerminatePtyRequest, opts ...grpc.CallOption) (*TerminatePtyResponse, error)
}

type ptyHostServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPtyHostServiceClient(cc grpc.ClientConnInterface) PtyHostServiceClient {
	return &ptyHostServiceClient{cc}
}

func (c *ptyHostServiceClient) SpawnPty(ctx context.Context, in *SpawnPtyRequest, opts ...grpc.CallOption) (*SpawnPtyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SpawnPtyResponse)
	err := c.cc.Invoke(ctx, PtyHostService_SpawnPty_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptyHostServiceClient) AttachPty(ctx context.Context, in *AttachPtyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PtyEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PtyHostService_ServiceDesc.Streams[0], PtyHostService_AttachPty_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AttachPtyRequest, PtyEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PtyHostService_AttachPtyClient = grpc.ServerStreamingClient[PtyEvent]

func (c *ptyHostServiceClient) SendInput(ctx context.Context, in *SendInputRequest, opts ...grpc.CallOption) (*SendInputResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendInputResponse)
	err := c.cc.Invoke(ctx, PtyHostService_SendInput_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptyHostServiceClient) ResizePty(ctx context.Context, in *ResizePtyRequest, opts ...grpc.CallOption) (*ResizePtyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResizePtyResponse)
	err := c.cc.Invoke(ctx, PtyHostService_ResizePty_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptyHostServiceClient) ListPtys(ctx context.Context, in *ListPtysRequest, opts ...grpc.CallOption) (*ListPtysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPtysResponse)
	err := c.cc.Invoke(ctx, PtyHostService_ListPtys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ptyHostServiceClient) TerminatePty(ctx context.Context, in *TerminatePtyRequest, opts ...grpc.CallOption) (*TerminatePtyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TerminatePtyResponse)
	err := c.cc.Invoke(ctx, PtyHostService_TerminatePty_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PtyHostServiceServer is the server API for PtyHostService service.
// All implementations must embed UnimplementedPtyHostServiceServer
// for forward compatibility.
//
// Source: agent.v1.PtyHostService (var: rWe)
type PtyHostServiceServer interface {
	SpawnPty(context.Context, *SpawnPtyRequest) (*SpawnPtyResponse, error)
	AttachPty(*AttachPtyRequest, grpc.ServerStreamingServer[PtyEvent]) error
	SendInput(context.Context, *SendInputRequest) (*SendInputResponse, error)
	ResizePty(context.Context, *ResizePtyRequest) (*ResizePtyResponse, error)
	ListPtys(context.Context, *ListPtysRequest) (*ListPtysResponse, error)
	TerminatePty(context.Context, *TerminatePtyRequest) (*TerminatePtyResponse, error)
	mustEmbedUnimplementedPtyHostServiceServer()
}

// UnimplementedPtyHostServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPtyHostServiceServer struct{}

func (UnimplementedPtyHostServiceServer) SpawnPty(context.Context, *SpawnPtyRequest) (*SpawnPtyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SpawnPty not implemented")
}
func (UnimplementedPtyHostServiceServer) AttachPty(*AttachPtyRequest, grpc.ServerStreamingServer[PtyEvent]) error {
	return status.Error(codes.Unimplemented, "method AttachPty not implemented")
}
func (UnimplementedPtyHostServiceServer) SendInput(context.Context, *SendInputRequest) (*SendInputResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendInput not implemented")
}
func (UnimplementedPtyHostServiceServer) ResizePty(context.Context, *ResizePtyRequest) (*ResizePtyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResizePty not implemented")
}
func (UnimplementedPtyHostServiceServer) ListPtys(context.Context, *ListPtysRequest) (*ListPtysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPtys not implemented")
}
func (UnimplementedPtyHostServiceServer) TerminatePty(context.Context, *TerminatePtyRequest) (*TerminatePtyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TerminatePty not implemented")
}
func (UnimplementedPtyHostServiceServer) mustEmbedUnimplementedPtyHostServiceServer() {}
func (UnimplementedPtyHostServiceServer) testEmbeddedByValue()                        {}

// UnsafePtyHostServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PtyHostServiceServer will
// result in compilation errors.
type UnsafePtyHostServiceServer interface {
	mustEmbedUnimplementedPtyHostServiceServer()
}

func RegisterPtyHostServiceServer(s grpc.ServiceRegistrar, srv PtyHostServiceServer) {
	// If the following call panics, it indicates UnimplementedPtyHostServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PtyHostService_ServiceDesc, srv)
}

func _PtyHostService_SpawnPty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpawnPtyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtyHostServiceServer).SpawnPty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PtyHostService_SpawnPty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtyHostServiceServer).SpawnPty(ctx, req.(*SpawnPtyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtyHostService_AttachPty_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachPtyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PtyHostServiceServer).AttachPty(m, &grpc.GenericServerStream[AttachPtyRequest, PtyEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PtyHostService_AttachPtyServer = grpc.ServerStreamingServer[PtyEvent]

func _PtyHostService_SendInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtyHostServiceServer).SendInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PtyHostService_SendInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtyHostServiceServer).SendInput(ctx, req.(*SendInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtyHostService_ResizePty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizePtyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtyHostServiceServer).ResizePty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PtyHostService_ResizePty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtyHostServiceServer).ResizePty(ctx, req.(*ResizePtyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtyHostService_ListPtys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPtysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtyHostServiceServer).ListPtys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PtyHostService_ListPtys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtyHostServiceServer).ListPtys(ctx, req.(*ListPtysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PtyHostService_TerminatePty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminatePtyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PtyHostServiceServer).TerminatePty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PtyHostService_TerminatePty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PtyHostServiceServer).TerminatePty(ctx, req.(*TerminatePtyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PtyHostService_ServiceDesc is the grpc.ServiceDesc for PtyHostService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PtyHostService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agent.v1.PtyHostService",
	HandlerType: (*PtyHostServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SpawnPty",
			Handler:    _PtyHostService_SpawnPty_Handler,
		},
		{
			MethodName: "SendInput",
			Handler:    _PtyHostService_SendInput_Handler,
		},
		{
			MethodName: "ResizePty",
			Handler:    _PtyHostService_ResizePty_Handler,
		},
		{
			MethodName: "ListPtys",
			Handler:    _PtyHostService_ListPtys_Handler,
		},
		{
			MethodName: "TerminatePty",
			Handler:    _PtyHostService_TerminatePty_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AttachPty",
			Handler:       _PtyHostService_AttachPty_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent_v1.proto",
}
