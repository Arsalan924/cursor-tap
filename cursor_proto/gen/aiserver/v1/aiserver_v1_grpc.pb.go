// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: aiserver_v1.proto

package aiserverv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AiBranchService_OpusChainGetPlan_FullMethodName            = "/aiserver.v1.AiBranchService/OpusChainGetPlan"
	AiBranchService_OpusChainGetFileInstruction_FullMethodName = "/aiserver.v1.AiBranchService/OpusChainGetFileInstruction"
	AiBranchService_OpusChainReflect_FullMethodName            = "/aiserver.v1.AiBranchService/OpusChainReflect"
	AiBranchService_OpusChainGetFilePaths_FullMethodName       = "/aiserver.v1.AiBranchService/OpusChainGetFilePaths"
	AiBranchService_RecordAcceptedPatch_FullMethodName         = "/aiserver.v1.AiBranchService/RecordAcceptedPatch"
	AiBranchService_ReportModeSelection_FullMethodName         = "/aiserver.v1.AiBranchService/ReportModeSelection"
)

// AiBranchServiceClient is the client API for AiBranchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AiBranchService (var: pVe)
type AiBranchServiceClient interface {
	OpusChainGetPlan(ctx context.Context, in *OpusChainGetPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OpusChainGetPlanResponse], error)
	OpusChainGetFileInstruction(ctx context.Context, in *OpusChainGetFileInstructionRequest, opts ...grpc.CallOption) (*OpusChainGetFileInstructionResponse, error)
	OpusChainReflect(ctx context.Context, in *OpusChainReflectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OpusChainReflectResponse], error)
	OpusChainGetFilePaths(ctx context.Context, in *OpusChainGetFilePathsRequest, opts ...grpc.CallOption) (*OpusChainGetFilePathsResponse, error)
	RecordAcceptedPatch(ctx context.Context, in *RecordAcceptedPatchRequest, opts ...grpc.CallOption) (*RecordAcceptedPatchResponse, error)
	ReportModeSelection(ctx context.Context, in *ReportModeSelectionRequest, opts ...grpc.CallOption) (*ReportModeSelectionResponse, error)
}

type aiBranchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAiBranchServiceClient(cc grpc.ClientConnInterface) AiBranchServiceClient {
	return &aiBranchServiceClient{cc}
}

func (c *aiBranchServiceClient) OpusChainGetPlan(ctx context.Context, in *OpusChainGetPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OpusChainGetPlanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiBranchService_ServiceDesc.Streams[0], AiBranchService_OpusChainGetPlan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[OpusChainGetPlanRequest, OpusChainGetPlanResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiBranchService_OpusChainGetPlanClient = grpc.ServerStreamingClient[OpusChainGetPlanResponse]

func (c *aiBranchServiceClient) OpusChainGetFileInstruction(ctx context.Context, in *OpusChainGetFileInstructionRequest, opts ...grpc.CallOption) (*OpusChainGetFileInstructionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpusChainGetFileInstructionResponse)
	err := c.cc.Invoke(ctx, AiBranchService_OpusChainGetFileInstruction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiBranchServiceClient) OpusChainReflect(ctx context.Context, in *OpusChainReflectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[OpusChainReflectResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiBranchService_ServiceDesc.Streams[1], AiBranchService_OpusChainReflect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[OpusChainReflectRequest, OpusChainReflectResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiBranchService_OpusChainReflectClient = grpc.ServerStreamingClient[OpusChainReflectResponse]

func (c *aiBranchServiceClient) OpusChainGetFilePaths(ctx context.Context, in *OpusChainGetFilePathsRequest, opts ...grpc.CallOption) (*OpusChainGetFilePathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpusChainGetFilePathsResponse)
	err := c.cc.Invoke(ctx, AiBranchService_OpusChainGetFilePaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiBranchServiceClient) RecordAcceptedPatch(ctx context.Context, in *RecordAcceptedPatchRequest, opts ...grpc.CallOption) (*RecordAcceptedPatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordAcceptedPatchResponse)
	err := c.cc.Invoke(ctx, AiBranchService_RecordAcceptedPatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiBranchServiceClient) ReportModeSelection(ctx context.Context, in *ReportModeSelectionRequest, opts ...grpc.CallOption) (*ReportModeSelectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportModeSelectionResponse)
	err := c.cc.Invoke(ctx, AiBranchService_ReportModeSelection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AiBranchServiceServer is the server API for AiBranchService service.
// All implementations must embed UnimplementedAiBranchServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AiBranchService (var: pVe)
type AiBranchServiceServer interface {
	OpusChainGetPlan(*OpusChainGetPlanRequest, grpc.ServerStreamingServer[OpusChainGetPlanResponse]) error
	OpusChainGetFileInstruction(context.Context, *OpusChainGetFileInstructionRequest) (*OpusChainGetFileInstructionResponse, error)
	OpusChainReflect(*OpusChainReflectRequest, grpc.ServerStreamingServer[OpusChainReflectResponse]) error
	OpusChainGetFilePaths(context.Context, *OpusChainGetFilePathsRequest) (*OpusChainGetFilePathsResponse, error)
	RecordAcceptedPatch(context.Context, *RecordAcceptedPatchRequest) (*RecordAcceptedPatchResponse, error)
	ReportModeSelection(context.Context, *ReportModeSelectionRequest) (*ReportModeSelectionResponse, error)
	mustEmbedUnimplementedAiBranchServiceServer()
}

// UnimplementedAiBranchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAiBranchServiceServer struct{}

func (UnimplementedAiBranchServiceServer) OpusChainGetPlan(*OpusChainGetPlanRequest, grpc.ServerStreamingServer[OpusChainGetPlanResponse]) error {
	return status.Error(codes.Unimplemented, "method OpusChainGetPlan not implemented")
}
func (UnimplementedAiBranchServiceServer) OpusChainGetFileInstruction(context.Context, *OpusChainGetFileInstructionRequest) (*OpusChainGetFileInstructionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OpusChainGetFileInstruction not implemented")
}
func (UnimplementedAiBranchServiceServer) OpusChainReflect(*OpusChainReflectRequest, grpc.ServerStreamingServer[OpusChainReflectResponse]) error {
	return status.Error(codes.Unimplemented, "method OpusChainReflect not implemented")
}
func (UnimplementedAiBranchServiceServer) OpusChainGetFilePaths(context.Context, *OpusChainGetFilePathsRequest) (*OpusChainGetFilePathsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OpusChainGetFilePaths not implemented")
}
func (UnimplementedAiBranchServiceServer) RecordAcceptedPatch(context.Context, *RecordAcceptedPatchRequest) (*RecordAcceptedPatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordAcceptedPatch not implemented")
}
func (UnimplementedAiBranchServiceServer) ReportModeSelection(context.Context, *ReportModeSelectionRequest) (*ReportModeSelectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportModeSelection not implemented")
}
func (UnimplementedAiBranchServiceServer) mustEmbedUnimplementedAiBranchServiceServer() {}
func (UnimplementedAiBranchServiceServer) testEmbeddedByValue()                         {}

// UnsafeAiBranchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AiBranchServiceServer will
// result in compilation errors.
type UnsafeAiBranchServiceServer interface {
	mustEmbedUnimplementedAiBranchServiceServer()
}

func RegisterAiBranchServiceServer(s grpc.ServiceRegistrar, srv AiBranchServiceServer) {
	// If the following call panics, it indicates UnimplementedAiBranchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AiBranchService_ServiceDesc, srv)
}

func _AiBranchService_OpusChainGetPlan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpusChainGetPlanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiBranchServiceServer).OpusChainGetPlan(m, &grpc.GenericServerStream[OpusChainGetPlanRequest, OpusChainGetPlanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiBranchService_OpusChainGetPlanServer = grpc.ServerStreamingServer[OpusChainGetPlanResponse]

func _AiBranchService_OpusChainGetFileInstruction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpusChainGetFileInstructionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiBranchServiceServer).OpusChainGetFileInstruction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiBranchService_OpusChainGetFileInstruction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiBranchServiceServer).OpusChainGetFileInstruction(ctx, req.(*OpusChainGetFileInstructionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiBranchService_OpusChainReflect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpusChainReflectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiBranchServiceServer).OpusChainReflect(m, &grpc.GenericServerStream[OpusChainReflectRequest, OpusChainReflectResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiBranchService_OpusChainReflectServer = grpc.ServerStreamingServer[OpusChainReflectResponse]

func _AiBranchService_OpusChainGetFilePaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpusChainGetFilePathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiBranchServiceServer).OpusChainGetFilePaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiBranchService_OpusChainGetFilePaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiBranchServiceServer).OpusChainGetFilePaths(ctx, req.(*OpusChainGetFilePathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiBranchService_RecordAcceptedPatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordAcceptedPatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiBranchServiceServer).RecordAcceptedPatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiBranchService_RecordAcceptedPatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiBranchServiceServer).RecordAcceptedPatch(ctx, req.(*RecordAcceptedPatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiBranchService_ReportModeSelection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportModeSelectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiBranchServiceServer).ReportModeSelection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiBranchService_ReportModeSelection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiBranchServiceServer).ReportModeSelection(ctx, req.(*ReportModeSelectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AiBranchService_ServiceDesc is the grpc.ServiceDesc for AiBranchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AiBranchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AiBranchService",
	HandlerType: (*AiBranchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpusChainGetFileInstruction",
			Handler:    _AiBranchService_OpusChainGetFileInstruction_Handler,
		},
		{
			MethodName: "OpusChainGetFilePaths",
			Handler:    _AiBranchService_OpusChainGetFilePaths_Handler,
		},
		{
			MethodName: "RecordAcceptedPatch",
			Handler:    _AiBranchService_RecordAcceptedPatch_Handler,
		},
		{
			MethodName: "ReportModeSelection",
			Handler:    _AiBranchService_ReportModeSelection_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpusChainGetPlan",
			Handler:       _AiBranchService_OpusChainGetPlan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpusChainReflect",
			Handler:       _AiBranchService_OpusChainReflect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	AiProjectService_AiProjectAgentInit_FullMethodName         = "/aiserver.v1.AiProjectService/AiProjectAgentInit"
	AiProjectService_AiProjectClarification_FullMethodName     = "/aiserver.v1.AiProjectService/AiProjectClarification"
	AiProjectService_AiProjectPlan_FullMethodName              = "/aiserver.v1.AiProjectService/AiProjectPlan"
	AiProjectService_AiProjectPlanFeedback_FullMethodName      = "/aiserver.v1.AiProjectService/AiProjectPlanFeedback"
	AiProjectService_AiProjectBreakdown_FullMethodName         = "/aiserver.v1.AiProjectService/AiProjectBreakdown"
	AiProjectService_AiProjectBreakdownFeedback_FullMethodName = "/aiserver.v1.AiProjectService/AiProjectBreakdownFeedback"
	AiProjectService_AiProjectStep_FullMethodName              = "/aiserver.v1.AiProjectService/AiProjectStep"
	AiProjectService_AiProjectStepFeedback_FullMethodName      = "/aiserver.v1.AiProjectService/AiProjectStepFeedback"
)

// AiProjectServiceClient is the client API for AiProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AiProjectService (var: dVe)
type AiProjectServiceClient interface {
	AiProjectAgentInit(ctx context.Context, in *AiProjectAgentInitRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectClarificationResponse], error)
	AiProjectClarification(ctx context.Context, in *AiProjectClarificationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectClarificationResponse], error)
	AiProjectPlan(ctx context.Context, in *AiProjectAgentPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectAgentPlanResponse], error)
	AiProjectPlanFeedback(ctx context.Context, in *AiProjectPlanFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectPlanFeedbackResponse], error)
	AiProjectBreakdown(ctx context.Context, in *AiProjectBreakdownRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectBreakdownResponse], error)
	AiProjectBreakdownFeedback(ctx context.Context, in *AiProjectBreakdownFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectBreakdownFeedbackResponse], error)
	AiProjectStep(ctx context.Context, in *AiProjectStepRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectStepResponseWrapped], error)
	AiProjectStepFeedback(ctx context.Context, in *AiProjectStepFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectStepFeedbackResponseWrapped], error)
}

type aiProjectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAiProjectServiceClient(cc grpc.ClientConnInterface) AiProjectServiceClient {
	return &aiProjectServiceClient{cc}
}

func (c *aiProjectServiceClient) AiProjectAgentInit(ctx context.Context, in *AiProjectAgentInitRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectClarificationResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[0], AiProjectService_AiProjectAgentInit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectAgentInitRequest, AiProjectClarificationResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectAgentInitClient = grpc.ServerStreamingClient[AiProjectClarificationResponse]

func (c *aiProjectServiceClient) AiProjectClarification(ctx context.Context, in *AiProjectClarificationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectClarificationResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[1], AiProjectService_AiProjectClarification_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectClarificationRequest, AiProjectClarificationResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectClarificationClient = grpc.ServerStreamingClient[AiProjectClarificationResponse]

func (c *aiProjectServiceClient) AiProjectPlan(ctx context.Context, in *AiProjectAgentPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectAgentPlanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[2], AiProjectService_AiProjectPlan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectAgentPlanRequest, AiProjectAgentPlanResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectPlanClient = grpc.ServerStreamingClient[AiProjectAgentPlanResponse]

func (c *aiProjectServiceClient) AiProjectPlanFeedback(ctx context.Context, in *AiProjectPlanFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectPlanFeedbackResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[3], AiProjectService_AiProjectPlanFeedback_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectPlanFeedbackRequest, AiProjectPlanFeedbackResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectPlanFeedbackClient = grpc.ServerStreamingClient[AiProjectPlanFeedbackResponse]

func (c *aiProjectServiceClient) AiProjectBreakdown(ctx context.Context, in *AiProjectBreakdownRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectBreakdownResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[4], AiProjectService_AiProjectBreakdown_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectBreakdownRequest, AiProjectBreakdownResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectBreakdownClient = grpc.ServerStreamingClient[AiProjectBreakdownResponse]

func (c *aiProjectServiceClient) AiProjectBreakdownFeedback(ctx context.Context, in *AiProjectBreakdownFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectBreakdownFeedbackResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[5], AiProjectService_AiProjectBreakdownFeedback_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectBreakdownFeedbackRequest, AiProjectBreakdownFeedbackResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectBreakdownFeedbackClient = grpc.ServerStreamingClient[AiProjectBreakdownFeedbackResponse]

func (c *aiProjectServiceClient) AiProjectStep(ctx context.Context, in *AiProjectStepRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectStepResponseWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[6], AiProjectService_AiProjectStep_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectStepRequest, AiProjectStepResponseWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectStepClient = grpc.ServerStreamingClient[AiProjectStepResponseWrapped]

func (c *aiProjectServiceClient) AiProjectStepFeedback(ctx context.Context, in *AiProjectStepFeedbackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectStepFeedbackResponseWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiProjectService_ServiceDesc.Streams[7], AiProjectService_AiProjectStepFeedback_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectStepFeedbackRequest, AiProjectStepFeedbackResponseWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectStepFeedbackClient = grpc.ServerStreamingClient[AiProjectStepFeedbackResponseWrapped]

// AiProjectServiceServer is the server API for AiProjectService service.
// All implementations must embed UnimplementedAiProjectServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AiProjectService (var: dVe)
type AiProjectServiceServer interface {
	AiProjectAgentInit(*AiProjectAgentInitRequest, grpc.ServerStreamingServer[AiProjectClarificationResponse]) error
	AiProjectClarification(*AiProjectClarificationRequest, grpc.ServerStreamingServer[AiProjectClarificationResponse]) error
	AiProjectPlan(*AiProjectAgentPlanRequest, grpc.ServerStreamingServer[AiProjectAgentPlanResponse]) error
	AiProjectPlanFeedback(*AiProjectPlanFeedbackRequest, grpc.ServerStreamingServer[AiProjectPlanFeedbackResponse]) error
	AiProjectBreakdown(*AiProjectBreakdownRequest, grpc.ServerStreamingServer[AiProjectBreakdownResponse]) error
	AiProjectBreakdownFeedback(*AiProjectBreakdownFeedbackRequest, grpc.ServerStreamingServer[AiProjectBreakdownFeedbackResponse]) error
	AiProjectStep(*AiProjectStepRequest, grpc.ServerStreamingServer[AiProjectStepResponseWrapped]) error
	AiProjectStepFeedback(*AiProjectStepFeedbackRequest, grpc.ServerStreamingServer[AiProjectStepFeedbackResponseWrapped]) error
	mustEmbedUnimplementedAiProjectServiceServer()
}

// UnimplementedAiProjectServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAiProjectServiceServer struct{}

func (UnimplementedAiProjectServiceServer) AiProjectAgentInit(*AiProjectAgentInitRequest, grpc.ServerStreamingServer[AiProjectClarificationResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectAgentInit not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectClarification(*AiProjectClarificationRequest, grpc.ServerStreamingServer[AiProjectClarificationResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectClarification not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectPlan(*AiProjectAgentPlanRequest, grpc.ServerStreamingServer[AiProjectAgentPlanResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectPlan not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectPlanFeedback(*AiProjectPlanFeedbackRequest, grpc.ServerStreamingServer[AiProjectPlanFeedbackResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectPlanFeedback not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectBreakdown(*AiProjectBreakdownRequest, grpc.ServerStreamingServer[AiProjectBreakdownResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectBreakdown not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectBreakdownFeedback(*AiProjectBreakdownFeedbackRequest, grpc.ServerStreamingServer[AiProjectBreakdownFeedbackResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProjectBreakdownFeedback not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectStep(*AiProjectStepRequest, grpc.ServerStreamingServer[AiProjectStepResponseWrapped]) error {
	return status.Error(codes.Unimplemented, "method AiProjectStep not implemented")
}
func (UnimplementedAiProjectServiceServer) AiProjectStepFeedback(*AiProjectStepFeedbackRequest, grpc.ServerStreamingServer[AiProjectStepFeedbackResponseWrapped]) error {
	return status.Error(codes.Unimplemented, "method AiProjectStepFeedback not implemented")
}
func (UnimplementedAiProjectServiceServer) mustEmbedUnimplementedAiProjectServiceServer() {}
func (UnimplementedAiProjectServiceServer) testEmbeddedByValue()                          {}

// UnsafeAiProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AiProjectServiceServer will
// result in compilation errors.
type UnsafeAiProjectServiceServer interface {
	mustEmbedUnimplementedAiProjectServiceServer()
}

func RegisterAiProjectServiceServer(s grpc.ServiceRegistrar, srv AiProjectServiceServer) {
	// If the following call panics, it indicates UnimplementedAiProjectServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AiProjectService_ServiceDesc, srv)
}

func _AiProjectService_AiProjectAgentInit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectAgentInitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectAgentInit(m, &grpc.GenericServerStream[AiProjectAgentInitRequest, AiProjectClarificationResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectAgentInitServer = grpc.ServerStreamingServer[AiProjectClarificationResponse]

func _AiProjectService_AiProjectClarification_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectClarificationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectClarification(m, &grpc.GenericServerStream[AiProjectClarificationRequest, AiProjectClarificationResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectClarificationServer = grpc.ServerStreamingServer[AiProjectClarificationResponse]

func _AiProjectService_AiProjectPlan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectAgentPlanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectPlan(m, &grpc.GenericServerStream[AiProjectAgentPlanRequest, AiProjectAgentPlanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectPlanServer = grpc.ServerStreamingServer[AiProjectAgentPlanResponse]

func _AiProjectService_AiProjectPlanFeedback_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectPlanFeedbackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectPlanFeedback(m, &grpc.GenericServerStream[AiProjectPlanFeedbackRequest, AiProjectPlanFeedbackResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectPlanFeedbackServer = grpc.ServerStreamingServer[AiProjectPlanFeedbackResponse]

func _AiProjectService_AiProjectBreakdown_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectBreakdownRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectBreakdown(m, &grpc.GenericServerStream[AiProjectBreakdownRequest, AiProjectBreakdownResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectBreakdownServer = grpc.ServerStreamingServer[AiProjectBreakdownResponse]

func _AiProjectService_AiProjectBreakdownFeedback_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectBreakdownFeedbackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectBreakdownFeedback(m, &grpc.GenericServerStream[AiProjectBreakdownFeedbackRequest, AiProjectBreakdownFeedbackResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectBreakdownFeedbackServer = grpc.ServerStreamingServer[AiProjectBreakdownFeedbackResponse]

func _AiProjectService_AiProjectStep_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectStepRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectStep(m, &grpc.GenericServerStream[AiProjectStepRequest, AiProjectStepResponseWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectStepServer = grpc.ServerStreamingServer[AiProjectStepResponseWrapped]

func _AiProjectService_AiProjectStepFeedback_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectStepFeedbackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiProjectServiceServer).AiProjectStepFeedback(m, &grpc.GenericServerStream[AiProjectStepFeedbackRequest, AiProjectStepFeedbackResponseWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiProjectService_AiProjectStepFeedbackServer = grpc.ServerStreamingServer[AiProjectStepFeedbackResponseWrapped]

// AiProjectService_ServiceDesc is the grpc.ServiceDesc for AiProjectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AiProjectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AiProjectService",
	HandlerType: (*AiProjectServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AiProjectAgentInit",
			Handler:       _AiProjectService_AiProjectAgentInit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectClarification",
			Handler:       _AiProjectService_AiProjectClarification_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectPlan",
			Handler:       _AiProjectService_AiProjectPlan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectPlanFeedback",
			Handler:       _AiProjectService_AiProjectPlanFeedback_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectBreakdown",
			Handler:       _AiProjectService_AiProjectBreakdown_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectBreakdownFeedback",
			Handler:       _AiProjectService_AiProjectBreakdownFeedback_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectStep",
			Handler:       _AiProjectService_AiProjectStep_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProjectStepFeedback",
			Handler:       _AiProjectService_AiProjectStepFeedback_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	AiService_ServerTime_FullMethodName                            = "/aiserver.v1.AiService/ServerTime"
	AiService_HealthCheck_FullMethodName                           = "/aiserver.v1.AiService/HealthCheck"
	AiService_PrivacyCheck_FullMethodName                          = "/aiserver.v1.AiService/PrivacyCheck"
	AiService_TimeLeftHealthCheck_FullMethodName                   = "/aiserver.v1.AiService/TimeLeftHealthCheck"
	AiService_ThrowErrorCheck_FullMethodName                       = "/aiserver.v1.AiService/ThrowErrorCheck"
	AiService_AvailableModels_FullMethodName                       = "/aiserver.v1.AiService/AvailableModels"
	AiService_StreamChatTryReallyHard_FullMethodName               = "/aiserver.v1.AiService/StreamChatTryReallyHard"
	AiService_RerankDocuments_FullMethodName                       = "/aiserver.v1.AiService/RerankDocuments"
	AiService_StreamComposer_FullMethodName                        = "/aiserver.v1.AiService/StreamComposer"
	AiService_StreamComposerContext_FullMethodName                 = "/aiserver.v1.AiService/StreamComposerContext"
	AiService_WarmComposerCache_FullMethodName                     = "/aiserver.v1.AiService/WarmComposerCache"
	AiService_KeepComposerCacheWarm_FullMethodName                 = "/aiserver.v1.AiService/KeepComposerCacheWarm"
	AiService_CountTokens_FullMethodName                           = "/aiserver.v1.AiService/CountTokens"
	AiService_StreamPotentialLocs_FullMethodName                   = "/aiserver.v1.AiService/StreamPotentialLocs"
	AiService_StreamPotentialLocsUnderneath_FullMethodName         = "/aiserver.v1.AiService/StreamPotentialLocsUnderneath"
	AiService_StreamPotentialLocsInitialQueries_FullMethodName     = "/aiserver.v1.AiService/StreamPotentialLocsInitialQueries"
	AiService_GetChatTitle_FullMethodName                          = "/aiserver.v1.AiService/GetChatTitle"
	AiService_GetCompletion_FullMethodName                         = "/aiserver.v1.AiService/GetCompletion"
	AiService_IsolatedTreesitter_FullMethodName                    = "/aiserver.v1.AiService/IsolatedTreesitter"
	AiService_GetSimplePrompt_FullMethodName                       = "/aiserver.v1.AiService/GetSimplePrompt"
	AiService_GetPassthroughPrompt_FullMethodName                  = "/aiserver.v1.AiService/GetPassthroughPrompt"
	AiService_CheckLongFilesFit_FullMethodName                     = "/aiserver.v1.AiService/CheckLongFilesFit"
	AiService_GetEvaluationPrompt_FullMethodName                   = "/aiserver.v1.AiService/GetEvaluationPrompt"
	AiService_GetUserInfo_FullMethodName                           = "/aiserver.v1.AiService/GetUserInfo"
	AiService_StreamChat_FullMethodName                            = "/aiserver.v1.AiService/StreamChat"
	AiService_StreamChatWeb_FullMethodName                         = "/aiserver.v1.AiService/StreamChatWeb"
	AiService_WarmChatCache_FullMethodName                         = "/aiserver.v1.AiService/WarmChatCache"
	AiService_StreamEdit_FullMethodName                            = "/aiserver.v1.AiService/StreamEdit"
	AiService_PreloadEdit_FullMethodName                           = "/aiserver.v1.AiService/PreloadEdit"
	AiService_StreamFastEdit_FullMethodName                        = "/aiserver.v1.AiService/StreamFastEdit"
	AiService_StreamGenerate_FullMethodName                        = "/aiserver.v1.AiService/StreamGenerate"
	AiService_StreamInlineLongCompletion_FullMethodName            = "/aiserver.v1.AiService/StreamInlineLongCompletion"
	AiService_SlashEdit_FullMethodName                             = "/aiserver.v1.AiService/SlashEdit"
	AiService_SlashEditFollowUpWithPreviousEdits_FullMethodName    = "/aiserver.v1.AiService/SlashEditFollowUpWithPreviousEdits"
	AiService_StreamAiPreviews_FullMethodName                      = "/aiserver.v1.AiService/StreamAiPreviews"
	AiService_ShouldTurnOnCppOnboarding_FullMethodName             = "/aiserver.v1.AiService/ShouldTurnOnCppOnboarding"
	AiService_GetComposerAutocomplete_FullMethodName               = "/aiserver.v1.AiService/GetComposerAutocomplete"
	AiService_StreamReview_FullMethodName                          = "/aiserver.v1.AiService/StreamReview"
	AiService_StreamReviewChat_FullMethodName                      = "/aiserver.v1.AiService/StreamReviewChat"
	AiService_CheckQueuePosition_FullMethodName                    = "/aiserver.v1.AiService/CheckQueuePosition"
	AiService_CheckUsageBasedPrice_FullMethodName                  = "/aiserver.v1.AiService/CheckUsageBasedPrice"
	AiService_DoThisForMeCheck_FullMethodName                      = "/aiserver.v1.AiService/DoThisForMeCheck"
	AiService_StreamDoThisForMe_FullMethodName                     = "/aiserver.v1.AiService/StreamDoThisForMe"
	AiService_StreamChatToolformer_FullMethodName                  = "/aiserver.v1.AiService/StreamChatToolformer"
	AiService_StreamChatToolformerContinue_FullMethodName          = "/aiserver.v1.AiService/StreamChatToolformerContinue"
	AiService_PushAiThought_FullMethodName                         = "/aiserver.v1.AiService/PushAiThought"
	AiService_CheckDoableAsTask_FullMethodName                     = "/aiserver.v1.AiService/CheckDoableAsTask"
	AiService_ReportGroundTruthCandidate_FullMethodName            = "/aiserver.v1.AiService/ReportGroundTruthCandidate"
	AiService_ReportCmdKFate_FullMethodName                        = "/aiserver.v1.AiService/ReportCmdKFate"
	AiService_ShowWelcomeScreen_FullMethodName                     = "/aiserver.v1.AiService/ShowWelcomeScreen"
	AiService_InterfaceAgentInit_FullMethodName                    = "/aiserver.v1.AiService/InterfaceAgentInit"
	AiService_StreamInterfaceAgentStatus_FullMethodName            = "/aiserver.v1.AiService/StreamInterfaceAgentStatus"
	AiService_TaskGetInterfaceAgentStatus_FullMethodName           = "/aiserver.v1.AiService/TaskGetInterfaceAgentStatus"
	AiService_UpdateVscodeProfile_FullMethodName                   = "/aiserver.v1.AiService/UpdateVscodeProfile"
	AiService_TaskInit_FullMethodName                              = "/aiserver.v1.AiService/TaskInit"
	AiService_TaskPause_FullMethodName                             = "/aiserver.v1.AiService/TaskPause"
	AiService_TaskInfo_FullMethodName                              = "/aiserver.v1.AiService/TaskInfo"
	AiService_TaskStreamLog_FullMethodName                         = "/aiserver.v1.AiService/TaskStreamLog"
	AiService_TaskSendMessage_FullMethodName                       = "/aiserver.v1.AiService/TaskSendMessage"
	AiService_TaskProvideResult_FullMethodName                     = "/aiserver.v1.AiService/TaskProvideResult"
	AiService_CreateExperimentalIndex_FullMethodName               = "/aiserver.v1.AiService/CreateExperimentalIndex"
	AiService_ListExperimentalIndexFiles_FullMethodName            = "/aiserver.v1.AiService/ListExperimentalIndexFiles"
	AiService_ListenExperimentalIndex_FullMethodName               = "/aiserver.v1.AiService/ListenExperimentalIndex"
	AiService_RegisterFileToIndex_FullMethodName                   = "/aiserver.v1.AiService/RegisterFileToIndex"
	AiService_SetupIndexDependencies_FullMethodName                = "/aiserver.v1.AiService/SetupIndexDependencies"
	AiService_ComputeIndexTopoSort_FullMethodName                  = "/aiserver.v1.AiService/ComputeIndexTopoSort"
	AiService_StreamChatDeepContext_FullMethodName                 = "/aiserver.v1.AiService/StreamChatDeepContext"
	AiService_ChooseCodeReferences_FullMethodName                  = "/aiserver.v1.AiService/ChooseCodeReferences"
	AiService_RegisterCodeReferences_FullMethodName                = "/aiserver.v1.AiService/RegisterCodeReferences"
	AiService_ExtractPaths_FullMethodName                          = "/aiserver.v1.AiService/ExtractPaths"
	AiService_SummarizeWithReferences_FullMethodName               = "/aiserver.v1.AiService/SummarizeWithReferences"
	AiService_DocumentationQuery_FullMethodName                    = "/aiserver.v1.AiService/DocumentationQuery"
	AiService_AvailableDocs_FullMethodName                         = "/aiserver.v1.AiService/AvailableDocs"
	AiService_ReportFeedback_FullMethodName                        = "/aiserver.v1.AiService/ReportFeedback"
	AiService_ReportBug_FullMethodName                             = "/aiserver.v1.AiService/ReportBug"
	AiService_StreamChatContext_FullMethodName                     = "/aiserver.v1.AiService/StreamChatContext"
	AiService_GenerateTldr_FullMethodName                          = "/aiserver.v1.AiService/GenerateTldr"
	AiService_TaskStreamChatContext_FullMethodName                 = "/aiserver.v1.AiService/TaskStreamChatContext"
	AiService_RerankResults_FullMethodName                         = "/aiserver.v1.AiService/RerankResults"
	AiService_ModelQuery_FullMethodName                            = "/aiserver.v1.AiService/ModelQuery"
	AiService_ModelQueryV2_FullMethodName                          = "/aiserver.v1.AiService/ModelQueryV2"
	AiService_IntentPrediction_FullMethodName                      = "/aiserver.v1.AiService/IntentPrediction"
	AiService_GetChatSuggestions_FullMethodName                    = "/aiserver.v1.AiService/GetChatSuggestions"
	AiService_GetUserInstructions_FullMethodName                   = "/aiserver.v1.AiService/GetUserInstructions"
	AiService_StreamCursorTutor_FullMethodName                     = "/aiserver.v1.AiService/StreamCursorTutor"
	AiService_CheckFeatureStatus_FullMethodName                    = "/aiserver.v1.AiService/CheckFeatureStatus"
	AiService_CheckFeaturesStatus_FullMethodName                   = "/aiserver.v1.AiService/CheckFeaturesStatus"
	AiService_CheckFeatureStatusUnauthenticated_FullMethodName     = "/aiserver.v1.AiService/CheckFeatureStatusUnauthenticated"
	AiService_GetEffectiveTokenLimit_FullMethodName                = "/aiserver.v1.AiService/GetEffectiveTokenLimit"
	AiService_GetContextScores_FullMethodName                      = "/aiserver.v1.AiService/GetContextScores"
	AiService_StreamCpp_FullMethodName                             = "/aiserver.v1.AiService/StreamCpp"
	AiService_CppConfig_FullMethodName                             = "/aiserver.v1.AiService/CppConfig"
	AiService_CppEditHistoryStatus_FullMethodName                  = "/aiserver.v1.AiService/CppEditHistoryStatus"
	AiService_CppAppend_FullMethodName                             = "/aiserver.v1.AiService/CppAppend"
	AiService_RefreshTabContext_FullMethodName                     = "/aiserver.v1.AiService/RefreshTabContext"
	AiService_CheckNumberConfig_FullMethodName                     = "/aiserver.v1.AiService/CheckNumberConfig"
	AiService_CheckNumberConfigUnauthenticated_FullMethodName      = "/aiserver.v1.AiService/CheckNumberConfigUnauthenticated"
	AiService_CheckNumberConfigs_FullMethodName                    = "/aiserver.v1.AiService/CheckNumberConfigs"
	AiService_StreamTerminalAutocomplete_FullMethodName            = "/aiserver.v1.AiService/StreamTerminalAutocomplete"
	AiService_StreamPseudocodeGenerator_FullMethodName             = "/aiserver.v1.AiService/StreamPseudocodeGenerator"
	AiService_StreamPseudocodeMapper_FullMethodName                = "/aiserver.v1.AiService/StreamPseudocodeMapper"
	AiService_AcknowledgeGracePeriodDisclaimer_FullMethodName      = "/aiserver.v1.AiService/AcknowledgeGracePeriodDisclaimer"
	AiService_StreamAiLintBug_FullMethodName                       = "/aiserver.v1.AiService/StreamAiLintBug"
	AiService_StreamAiCursorHelp_FullMethodName                    = "/aiserver.v1.AiService/StreamAiCursorHelp"
	AiService_LogUserLintReply_FullMethodName                      = "/aiserver.v1.AiService/LogUserLintReply"
	AiService_LogLinterExplicitUserFeedback_FullMethodName         = "/aiserver.v1.AiService/LogLinterExplicitUserFeedback"
	AiService_StreamFixMarkers_FullMethodName                      = "/aiserver.v1.AiService/StreamFixMarkers"
	AiService_ReportInlineAction_FullMethodName                    = "/aiserver.v1.AiService/ReportInlineAction"
	AiService_StreamPriomptPrompt_FullMethodName                   = "/aiserver.v1.AiService/StreamPriomptPrompt"
	AiService_StreamLint_FullMethodName                            = "/aiserver.v1.AiService/StreamLint"
	AiService_StreamNewLintRule_FullMethodName                     = "/aiserver.v1.AiService/StreamNewLintRule"
	AiService_AiProject_FullMethodName                             = "/aiserver.v1.AiService/AiProject"
	AiService_ToCamelCase_FullMethodName                           = "/aiserver.v1.AiService/ToCamelCase"
	AiService_ReportGenerationFeedback_FullMethodName              = "/aiserver.v1.AiService/ReportGenerationFeedback"
	AiService_GetThoughtAnnotation_FullMethodName                  = "/aiserver.v1.AiService/GetThoughtAnnotation"
	AiService_StreamWebCmdKV1_FullMethodName                       = "/aiserver.v1.AiService/StreamWebCmdKV1"
	AiService_StreamNextCursorPrediction_FullMethodName            = "/aiserver.v1.AiService/StreamNextCursorPrediction"
	AiService_IsCursorPredictionEnabled_FullMethodName             = "/aiserver.v1.AiService/IsCursorPredictionEnabled"
	AiService_GetCppEditClassification_FullMethodName              = "/aiserver.v1.AiService/GetCppEditClassification"
	AiService_GetTerminalCompletion_FullMethodName                 = "/aiserver.v1.AiService/GetTerminalCompletion"
	AiService_TakeNotesOnCommitDiff_FullMethodName                 = "/aiserver.v1.AiService/TakeNotesOnCommitDiff"
	AiService_BulkEmbed_FullMethodName                             = "/aiserver.v1.AiService/BulkEmbed"
	AiService_BackgroundCmdKEval_FullMethodName                    = "/aiserver.v1.AiService/BackgroundCmdKEval"
	AiService_BackgroundCmdK_FullMethodName                        = "/aiserver.v1.AiService/BackgroundCmdK"
	AiService_StreamCursorMotion_FullMethodName                    = "/aiserver.v1.AiService/StreamCursorMotion"
	AiService_CalculateAutoSelection_FullMethodName                = "/aiserver.v1.AiService/CalculateAutoSelection"
	AiService_GetAtSymbolSuggestions_FullMethodName                = "/aiserver.v1.AiService/GetAtSymbolSuggestions"
	AiService_GetCodebaseQuestions_FullMethodName                  = "/aiserver.v1.AiService/GetCodebaseQuestions"
	AiService_CppEditHistoryAppend_FullMethodName                  = "/aiserver.v1.AiService/CppEditHistoryAppend"
	AiService_DevOnlyGetPastRequestIds_FullMethodName              = "/aiserver.v1.AiService/DevOnlyGetPastRequestIds"
	AiService_GetFilesForComposer_FullMethodName                   = "/aiserver.v1.AiService/GetFilesForComposer"
	AiService_TryParseTypeScriptTreeSitter_FullMethodName          = "/aiserver.v1.AiService/TryParseTypeScriptTreeSitter"
	AiService_NameTab_FullMethodName                               = "/aiserver.v1.AiService/NameTab"
	AiService_IsTerminalFinishedV2_FullMethodName                  = "/aiserver.v1.AiService/IsTerminalFinishedV2"
	AiService_TestModelStatus_FullMethodName                       = "/aiserver.v1.AiService/TestModelStatus"
	AiService_FindBugs_FullMethodName                              = "/aiserver.v1.AiService/FindBugs"
	AiService_ContextReranking_FullMethodName                      = "/aiserver.v1.AiService/ContextReranking"
	AiService_AutoContext_FullMethodName                           = "/aiserver.v1.AiService/AutoContext"
	AiService_WriteGitCommitMessage_FullMethodName                 = "/aiserver.v1.AiService/WriteGitCommitMessage"
	AiService_WriteGitBranchName_FullMethodName                    = "/aiserver.v1.AiService/WriteGitBranchName"
	AiService_StreamBugBot_FullMethodName                          = "/aiserver.v1.AiService/StreamBugBot"
	AiService_StreamBugBotAgentic_FullMethodName                   = "/aiserver.v1.AiService/StreamBugBotAgentic"
	AiService_StreamBugBotAgenticSSE_FullMethodName                = "/aiserver.v1.AiService/StreamBugBotAgenticSSE"
	AiService_StreamBugBotAgenticPoll_FullMethodName               = "/aiserver.v1.AiService/StreamBugBotAgenticPoll"
	AiService_StreamUiBestOfNJudge_FullMethodName                  = "/aiserver.v1.AiService/StreamUiBestOfNJudge"
	AiService_StreamUiBestOfNJudgeSSE_FullMethodName               = "/aiserver.v1.AiService/StreamUiBestOfNJudgeSSE"
	AiService_StreamUiBestOfNJudgePoll_FullMethodName              = "/aiserver.v1.AiService/StreamUiBestOfNJudgePoll"
	AiService_CheckBugBotPrice_FullMethodName                      = "/aiserver.v1.AiService/CheckBugBotPrice"
	AiService_CheckBugBotTelemetryHealthy_FullMethodName           = "/aiserver.v1.AiService/CheckBugBotTelemetryHealthy"
	AiService_RecordIdeBugReaction_FullMethodName                  = "/aiserver.v1.AiService/RecordIdeBugReaction"
	AiService_GetSuggestedBugBotIterations_FullMethodName          = "/aiserver.v1.AiService/GetSuggestedBugBotIterations"
	AiService_GetEditorBugbotAutoRunStatus_FullMethodName          = "/aiserver.v1.AiService/GetEditorBugbotAutoRunStatus"
	AiService_TestBidi_FullMethodName                              = "/aiserver.v1.AiService/TestBidi"
	AiService_StreamDiffReview_FullMethodName                      = "/aiserver.v1.AiService/StreamDiffReview"
	AiService_StreamDiffReviewByFile_FullMethodName                = "/aiserver.v1.AiService/StreamDiffReviewByFile"
	AiService_GetModelLabels_FullMethodName                        = "/aiserver.v1.AiService/GetModelLabels"
	AiService_GetLastDefaultModelNudge_FullMethodName              = "/aiserver.v1.AiService/GetLastDefaultModelNudge"
	AiService_GetDefaultModelNudgeData_FullMethodName              = "/aiserver.v1.AiService/GetDefaultModelNudgeData"
	AiService_GetDefaultModel_FullMethodName                       = "/aiserver.v1.AiService/GetDefaultModel"
	AiService_ReportCommitAiAnalytics_FullMethodName               = "/aiserver.v1.AiService/ReportCommitAiAnalytics"
	AiService_TestBedrockCredentials_FullMethodName                = "/aiserver.v1.AiService/TestBedrockCredentials"
	AiService_ReportAiCodeChangeMetrics_FullMethodName             = "/aiserver.v1.AiService/ReportAiCodeChangeMetrics"
	AiService_ReportProcessMetrics_FullMethodName                  = "/aiserver.v1.AiService/ReportProcessMetrics"
	AiService_ReportProcessMetricsV2_FullMethodName                = "/aiserver.v1.AiService/ReportProcessMetricsV2"
	AiService_ReportClientNumericMetrics_FullMethodName            = "/aiserver.v1.AiService/ReportClientNumericMetrics"
	AiService_PotentiallyGenerateMemory_FullMethodName             = "/aiserver.v1.AiService/PotentiallyGenerateMemory"
	AiService_KnowledgeBaseAdd_FullMethodName                      = "/aiserver.v1.AiService/KnowledgeBaseAdd"
	AiService_KnowledgeBaseList_FullMethodName                     = "/aiserver.v1.AiService/KnowledgeBaseList"
	AiService_KnowledgeBaseRemove_FullMethodName                   = "/aiserver.v1.AiService/KnowledgeBaseRemove"
	AiService_KnowledgeBaseUpdate_FullMethodName                   = "/aiserver.v1.AiService/KnowledgeBaseUpdate"
	AiService_FetchRelevantKnowledgeForConversation_FullMethodName = "/aiserver.v1.AiService/FetchRelevantKnowledgeForConversation"
	AiService_InferBackgroundComposerScripts_FullMethodName        = "/aiserver.v1.AiService/InferBackgroundComposerScripts"
	AiService_GetBackgroundComposerFeedbackLink_FullMethodName     = "/aiserver.v1.AiService/GetBackgroundComposerFeedbackLink"
	AiService_GetUsableModels_FullMethodName                       = "/aiserver.v1.AiService/GetUsableModels"
	AiService_GetDefaultModelForCli_FullMethodName                 = "/aiserver.v1.AiService/GetDefaultModelForCli"
	AiService_StreamComposerEnhancer_FullMethodName                = "/aiserver.v1.AiService/StreamComposerEnhancer"
	AiService_StreamComposerEnhancerSSE_FullMethodName             = "/aiserver.v1.AiService/StreamComposerEnhancerSSE"
	AiService_StreamComposerEnhancerPoll_FullMethodName            = "/aiserver.v1.AiService/StreamComposerEnhancerPoll"
	AiService_StreamStt_FullMethodName                             = "/aiserver.v1.AiService/StreamStt"
	AiService_StreamSttSSE_FullMethodName                          = "/aiserver.v1.AiService/StreamSttSSE"
	AiService_StreamSttPoll_FullMethodName                         = "/aiserver.v1.AiService/StreamSttPoll"
	AiService_NameAgent_FullMethodName                             = "/aiserver.v1.AiService/NameAgent"
	AiService_EvaluatePromptHook_FullMethodName                    = "/aiserver.v1.AiService/EvaluatePromptHook"
)

// AiServiceClient is the client API for AiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AiService (var: Wze)
type AiServiceClient interface {
	ServerTime(ctx context.Context, in *ServerTimeRequest, opts ...grpc.CallOption) (*ServerTimeResponse, error)
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	PrivacyCheck(ctx context.Context, in *PrivacyCheckRequest, opts ...grpc.CallOption) (*PrivacyCheckResponse, error)
	TimeLeftHealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*TimeLeftHealthCheckResponse, error)
	ThrowErrorCheck(ctx context.Context, in *ThrowErrorCheckRequest, opts ...grpc.CallOption) (*ThrowErrorCheckResponse, error)
	AvailableModels(ctx context.Context, in *AvailableModelsRequest, opts ...grpc.CallOption) (*AvailableModelsResponse, error)
	StreamChatTryReallyHard(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	RerankDocuments(ctx context.Context, in *RerankDocumentsRequest, opts ...grpc.CallOption) (*RerankDocumentsResponse, error)
	StreamComposer(ctx context.Context, in *GetComposerChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	StreamComposerContext(ctx context.Context, in *StreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatContextResponse], error)
	WarmComposerCache(ctx context.Context, in *GetComposerChatRequest, opts ...grpc.CallOption) (*WarmComposerCacheResponse, error)
	KeepComposerCacheWarm(ctx context.Context, in *KeepComposerCacheWarmRequest, opts ...grpc.CallOption) (*KeepComposerCacheWarmResponse, error)
	CountTokens(ctx context.Context, in *CountTokensRequest, opts ...grpc.CallOption) (*CountTokensResponse, error)
	StreamPotentialLocs(ctx context.Context, in *PotentialLocsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsResponse], error)
	StreamPotentialLocsUnderneath(ctx context.Context, in *PotentialLocsUnderneathRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsUnderneathResponse], error)
	StreamPotentialLocsInitialQueries(ctx context.Context, in *PotentialLocsInitialQueriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsInitialQueriesResponse], error)
	GetChatTitle(ctx context.Context, in *GetChatTitleRequest, opts ...grpc.CallOption) (*GetChatTitleResponse, error)
	GetCompletion(ctx context.Context, in *GetCompletionRequest, opts ...grpc.CallOption) (*GetCompletionResponse, error)
	IsolatedTreesitter(ctx context.Context, in *IsolatedTreesitterRequest, opts ...grpc.CallOption) (*IsolatedTreesitterResponse, error)
	GetSimplePrompt(ctx context.Context, in *GetSimplePromptRequest, opts ...grpc.CallOption) (*GetSimplePromptResponse, error)
	GetPassthroughPrompt(ctx context.Context, in *GetPassthroughPromptRequest, opts ...grpc.CallOption) (*GetPassthroughPromptResponse, error)
	CheckLongFilesFit(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (*CheckLongFilesFitResponse, error)
	GetEvaluationPrompt(ctx context.Context, in *GetEvaluationPromptRequest, opts ...grpc.CallOption) (*GetEvaluationPromptResponse, error)
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
	StreamChat(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	StreamChatWeb(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	WarmChatCache(ctx context.Context, in *WarmChatCacheRequest, opts ...grpc.CallOption) (*WarmChatCacheResponse, error)
	StreamEdit(ctx context.Context, in *StreamEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	PreloadEdit(ctx context.Context, in *PreloadEditRequest, opts ...grpc.CallOption) (*PreloadEditResponse, error)
	StreamFastEdit(ctx context.Context, in *StreamFastEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamFastEditResponse], error)
	StreamGenerate(ctx context.Context, in *StreamGenerateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	StreamInlineLongCompletion(ctx context.Context, in *StreamInlineLongCompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	SlashEdit(ctx context.Context, in *SlashEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SlashEditResponse], error)
	SlashEditFollowUpWithPreviousEdits(ctx context.Context, in *SlashEditFollowUpWithPreviousEditsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamSlashEditFollowUpWithPreviousEditsResponse], error)
	StreamAiPreviews(ctx context.Context, in *StreamAiPreviewsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiPreviewsResponse], error)
	ShouldTurnOnCppOnboarding(ctx context.Context, in *ShouldTurnOnCppOnboardingRequest, opts ...grpc.CallOption) (*ShouldTurnOnCppOnboardingResponse, error)
	GetComposerAutocomplete(ctx context.Context, in *GetComposerAutocompleteRequest, opts ...grpc.CallOption) (*GetComposerAutocompleteResponse, error)
	StreamReview(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponse], error)
	StreamReviewChat(ctx context.Context, in *ReviewChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewChatResponse], error)
	CheckQueuePosition(ctx context.Context, in *CheckQueuePositionRequest, opts ...grpc.CallOption) (*CheckQueuePositionResponse, error)
	CheckUsageBasedPrice(ctx context.Context, in *CheckUsageBasedPriceRequest, opts ...grpc.CallOption) (*CheckUsageBasedPriceResponse, error)
	DoThisForMeCheck(ctx context.Context, in *DoThisForMeCheckRequest, opts ...grpc.CallOption) (*DoThisForMeCheckResponse, error)
	StreamDoThisForMe(ctx context.Context, in *DoThisForMeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DoThisForMeResponseWrapped], error)
	StreamChatToolformer(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatToolformerResponse], error)
	StreamChatToolformerContinue(ctx context.Context, in *StreamChatToolformerContinueRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatToolformerResponse], error)
	PushAiThought(ctx context.Context, in *PushAiThoughtRequest, opts ...grpc.CallOption) (*PushAiThoughtResponse, error)
	CheckDoableAsTask(ctx context.Context, in *CheckDoableAsTaskRequest, opts ...grpc.CallOption) (*CheckDoableAsTaskResponse, error)
	ReportGroundTruthCandidate(ctx context.Context, in *ReportGroundTruthCandidateRequest, opts ...grpc.CallOption) (*ReportGroundTruthCandidateResponse, error)
	ReportCmdKFate(ctx context.Context, in *ReportCmdKFateRequest, opts ...grpc.CallOption) (*ReportCmdKFateResponse, error)
	ShowWelcomeScreen(ctx context.Context, in *ShowWelcomeScreenRequest, opts ...grpc.CallOption) (*ShowWelcomeScreenResponse, error)
	InterfaceAgentInit(ctx context.Context, in *InterfaceAgentInitRequest, opts ...grpc.CallOption) (*InterfaceAgentInitResponse, error)
	StreamInterfaceAgentStatus(ctx context.Context, in *StreamInterfaceAgentStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamInterfaceAgentStatusResponse], error)
	TaskGetInterfaceAgentStatus(ctx context.Context, in *TaskGetInterfaceAgentStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskGetInterfaceAgentStatusResponseWrapped], error)
	UpdateVscodeProfile(ctx context.Context, in *UpdateVscodeProfileRequest, opts ...grpc.CallOption) (*UpdateVscodeProfileResponse, error)
	TaskInit(ctx context.Context, in *TaskInitRequest, opts ...grpc.CallOption) (*TaskInitResponse, error)
	TaskPause(ctx context.Context, in *TaskPauseRequest, opts ...grpc.CallOption) (*TaskPauseResponse, error)
	TaskInfo(ctx context.Context, in *TaskInfoRequest, opts ...grpc.CallOption) (*TaskInfoResponse, error)
	TaskStreamLog(ctx context.Context, in *TaskStreamLogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskStreamLogResponse], error)
	TaskSendMessage(ctx context.Context, in *TaskSendMessageRequest, opts ...grpc.CallOption) (*TaskSendMessageResponse, error)
	TaskProvideResult(ctx context.Context, in *TaskProvideResultRequest, opts ...grpc.CallOption) (*TaskProvideResultResponse, error)
	CreateExperimentalIndex(ctx context.Context, in *CreateExperimentalIndexRequest, opts ...grpc.CallOption) (*CreateExperimentalIndexResponse, error)
	ListExperimentalIndexFiles(ctx context.Context, in *ListExperimentalIndexFilesRequest, opts ...grpc.CallOption) (*ListExperimentalIndexFilesResponse, error)
	ListenExperimentalIndex(ctx context.Context, in *ListenExperimentalIndexRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListenExperimentalIndexResponse], error)
	RegisterFileToIndex(ctx context.Context, in *RegisterFileToIndexRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error)
	SetupIndexDependencies(ctx context.Context, in *SetupIndexDependenciesRequest, opts ...grpc.CallOption) (*SetupIndexDependenciesResponse, error)
	ComputeIndexTopoSort(ctx context.Context, in *ComputeIndexTopoSortRequest, opts ...grpc.CallOption) (*ComputeIndexTopoSortResponse, error)
	StreamChatDeepContext(ctx context.Context, in *StreamChatDeepContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatDeepContextResponse], error)
	ChooseCodeReferences(ctx context.Context, in *ChooseCodeReferencesRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error)
	RegisterCodeReferences(ctx context.Context, in *RegisterCodeReferencesRequest, opts ...grpc.CallOption) (*RegisterCodeReferencesResponse, error)
	ExtractPaths(ctx context.Context, in *ExtractPathsRequest, opts ...grpc.CallOption) (*ExtractPathsResponse, error)
	SummarizeWithReferences(ctx context.Context, in *SummarizeWithReferencesRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error)
	DocumentationQuery(ctx context.Context, in *DocumentationQueryRequest, opts ...grpc.CallOption) (*DocumentationQueryResponse, error)
	AvailableDocs(ctx context.Context, in *AvailableDocsRequest, opts ...grpc.CallOption) (*AvailableDocsResponse, error)
	ReportFeedback(ctx context.Context, in *ReportFeedbackRequest, opts ...grpc.CallOption) (*ReportFeedbackResponse, error)
	ReportBug(ctx context.Context, in *ReportBugRequest, opts ...grpc.CallOption) (*ReportBugResponse, error)
	StreamChatContext(ctx context.Context, in *StreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatContextResponse], error)
	GenerateTldr(ctx context.Context, in *GenerateTldrRequest, opts ...grpc.CallOption) (*GenerateTldrResponse, error)
	TaskStreamChatContext(ctx context.Context, in *TaskStreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskStreamChatContextResponseWrapped], error)
	RerankResults(ctx context.Context, in *RerankerRequest, opts ...grpc.CallOption) (*RerankerResponse, error)
	ModelQuery(ctx context.Context, in *ModelQueryRequest, opts ...grpc.CallOption) (*ModelQueryResponse, error)
	ModelQueryV2(ctx context.Context, in *ModelQueryRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ModelQueryResponseV2], error)
	IntentPrediction(ctx context.Context, in *IntentPredictionRequest, opts ...grpc.CallOption) (*IntentPredictionResponse, error)
	GetChatSuggestions(ctx context.Context, in *GetChatSuggestionsRequest, opts ...grpc.CallOption) (*GetChatSuggestionsResponse, error)
	GetUserInstructions(ctx context.Context, in *GetUserInstructionsRequest, opts ...grpc.CallOption) (*GetUserInstructionsResponse, error)
	StreamCursorTutor(ctx context.Context, in *StreamCursorTutorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCursorTutorResponse], error)
	CheckFeatureStatus(ctx context.Context, in *CheckFeatureStatusRequest, opts ...grpc.CallOption) (*CheckFeatureStatusResponse, error)
	CheckFeaturesStatus(ctx context.Context, in *CheckFeaturesStatusRequest, opts ...grpc.CallOption) (*CheckFeaturesStatusResponse, error)
	CheckFeatureStatusUnauthenticated(ctx context.Context, in *CheckFeatureStatusRequest, opts ...grpc.CallOption) (*CheckFeatureStatusResponse, error)
	GetEffectiveTokenLimit(ctx context.Context, in *GetEffectiveTokenLimitRequest, opts ...grpc.CallOption) (*GetEffectiveTokenLimitResponse, error)
	GetContextScores(ctx context.Context, in *ContextScoresRequest, opts ...grpc.CallOption) (*ContextScoresResponse, error)
	StreamCpp(ctx context.Context, in *StreamCppRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCppResponse], error)
	CppConfig(ctx context.Context, in *CppConfigRequest, opts ...grpc.CallOption) (*CppConfigResponse, error)
	CppEditHistoryStatus(ctx context.Context, in *CppEditHistoryStatusRequest, opts ...grpc.CallOption) (*CppEditHistoryStatusResponse, error)
	CppAppend(ctx context.Context, in *CppAppendRequest, opts ...grpc.CallOption) (*CppAppendResponse, error)
	RefreshTabContext(ctx context.Context, in *RefreshTabContextRequest, opts ...grpc.CallOption) (*RefreshTabContextResponse, error)
	CheckNumberConfig(ctx context.Context, in *CheckNumberConfigRequest, opts ...grpc.CallOption) (*CheckNumberConfigResponse, error)
	CheckNumberConfigUnauthenticated(ctx context.Context, in *CheckNumberConfigRequest, opts ...grpc.CallOption) (*CheckNumberConfigResponse, error)
	CheckNumberConfigs(ctx context.Context, in *CheckNumberConfigsRequest, opts ...grpc.CallOption) (*CheckNumberConfigsResponse, error)
	StreamTerminalAutocomplete(ctx context.Context, in *StreamTerminalAutocompleteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTerminalAutocompleteResponse], error)
	StreamPseudocodeGenerator(ctx context.Context, in *StreamPseudocodeGeneratorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPseudocodeGeneratorResponse], error)
	StreamPseudocodeMapper(ctx context.Context, in *StreamPseudocodeMapperRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPseudocodeMapperResponse], error)
	AcknowledgeGracePeriodDisclaimer(ctx context.Context, in *AcknowledgeGracePeriodDisclaimerRequest, opts ...grpc.CallOption) (*AcknowledgeGracePeriodDisclaimerResponse, error)
	StreamAiLintBug(ctx context.Context, in *StreamAiLintBugRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiLintBugResponse], error)
	StreamAiCursorHelp(ctx context.Context, in *StreamAiCursorHelpRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiCursorHelpResponse], error)
	LogUserLintReply(ctx context.Context, in *LogUserLintReplyRequest, opts ...grpc.CallOption) (*LogUserLintReplyResponse, error)
	LogLinterExplicitUserFeedback(ctx context.Context, in *LogLinterExplicitUserFeedbackRequest, opts ...grpc.CallOption) (*LogLinterExplicitUserFeedbackResponse, error)
	StreamFixMarkers(ctx context.Context, in *FixMarkersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FixMarkersResponse], error)
	ReportInlineAction(ctx context.Context, in *ReportInlineActionRequest, opts ...grpc.CallOption) (*ReportInlineActionResponse, error)
	StreamPriomptPrompt(ctx context.Context, in *StreamPriomptPromptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPriomptPromptResponse], error)
	StreamLint(ctx context.Context, in *StreamLintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	StreamNewLintRule(ctx context.Context, in *StreamNewRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error)
	AiProject(ctx context.Context, in *AiProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectResponse], error)
	ToCamelCase(ctx context.Context, in *ToCamelCaseRequest, opts ...grpc.CallOption) (*ToCamelCaseResponse, error)
	ReportGenerationFeedback(ctx context.Context, in *ReportGenerationFeedbackRequest, opts ...grpc.CallOption) (*ReportGenerationFeedbackResponse, error)
	GetThoughtAnnotation(ctx context.Context, in *GetThoughtAnnotationRequest, opts ...grpc.CallOption) (*GetThoughtAnnotationResponse, error)
	StreamWebCmdKV1(ctx context.Context, in *StreamWebCmdKV1Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamWebCmdKV1Response], error)
	StreamNextCursorPrediction(ctx context.Context, in *StreamNextCursorPredictionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamNextCursorPredictionResponse], error)
	IsCursorPredictionEnabled(ctx context.Context, in *IsCursorPredictionEnabledRequest, opts ...grpc.CallOption) (*IsCursorPredictionEnabledResponse, error)
	GetCppEditClassification(ctx context.Context, in *GetCppEditClassificationRequest, opts ...grpc.CallOption) (*GetCppEditClassificationResponse, error)
	GetTerminalCompletion(ctx context.Context, in *GetTerminalCompletionRequest, opts ...grpc.CallOption) (*GetTerminalCompletionResponse, error)
	TakeNotesOnCommitDiff(ctx context.Context, in *TakeNotesOnCommitDiffRequest, opts ...grpc.CallOption) (*TakeNotesOnCommitDiffResponse, error)
	BulkEmbed(ctx context.Context, in *BulkEmbedRequest, opts ...grpc.CallOption) (*BulkEmbedResponse, error)
	BackgroundCmdKEval(ctx context.Context, in *BackgroundCmdKEvalRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BackgroundCmdKEvalResponse], error)
	BackgroundCmdK(ctx context.Context, in *BackgroundCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BackgroundCmdKResponse], error)
	StreamCursorMotion(ctx context.Context, in *StreamCursorMotionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCursorMotionResponse], error)
	CalculateAutoSelection(ctx context.Context, in *CalculateAutoSelectionRequest, opts ...grpc.CallOption) (*CalculateAutoSelectionResponse, error)
	GetAtSymbolSuggestions(ctx context.Context, in *GetAtSymbolSuggestionsRequest, opts ...grpc.CallOption) (*GetAtSymbolSuggestionsResponse, error)
	GetCodebaseQuestions(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (*GetCodebaseQuestionsResponse, error)
	CppEditHistoryAppend(ctx context.Context, in *EditHistoryAppendChangesRequest, opts ...grpc.CallOption) (*EditHistoryAppendChangesResponse, error)
	DevOnlyGetPastRequestIds(ctx context.Context, in *DevOnlyGetPastRequestIdsRequest, opts ...grpc.CallOption) (*DevOnlyGetPastRequestIdsResponse, error)
	GetFilesForComposer(ctx context.Context, in *GetFilesForComposerRequest, opts ...grpc.CallOption) (*GetFilesForComposerResponse, error)
	TryParseTypeScriptTreeSitter(ctx context.Context, in *TryParseTypeScriptTreeSitterRequest, opts ...grpc.CallOption) (*TryParseTypeScriptTreeSitterResponse, error)
	NameTab(ctx context.Context, in *NameTabRequest, opts ...grpc.CallOption) (*NameTabResponse, error)
	IsTerminalFinishedV2(ctx context.Context, in *IsTerminalFinishedRequest, opts ...grpc.CallOption) (*IsTerminalFinishedResponseV2, error)
	TestModelStatus(ctx context.Context, in *TestModelStatusRequest, opts ...grpc.CallOption) (*TestModelStatusResponse, error)
	FindBugs(ctx context.Context, in *FindBugsRequest, opts ...grpc.CallOption) (*FindBugsResponse, error)
	ContextReranking(ctx context.Context, in *ContextRerankingRequest, opts ...grpc.CallOption) (*ContextRerankingResponse, error)
	AutoContext(ctx context.Context, in *AutoContextRequest, opts ...grpc.CallOption) (*AutoContextResponse, error)
	WriteGitCommitMessage(ctx context.Context, in *WriteGitCommitMessageRequest, opts ...grpc.CallOption) (*WriteGitCommitMessageResponse, error)
	WriteGitBranchName(ctx context.Context, in *WriteGitBranchNameRequest, opts ...grpc.CallOption) (*WriteGitBranchNameResponse, error)
	StreamBugBot(ctx context.Context, in *StreamBugBotRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotResponse], error)
	StreamBugBotAgentic(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage], error)
	StreamBugBotAgenticSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotAgenticServerMessage], error)
	StreamBugBotAgenticPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	StreamUiBestOfNJudge(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage], error)
	StreamUiBestOfNJudgeSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUiBestOfNJudgeServerMessage], error)
	StreamUiBestOfNJudgePoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	CheckBugBotPrice(ctx context.Context, in *CheckBugBotPriceRequest, opts ...grpc.CallOption) (*CheckBugBotPriceResponse, error)
	CheckBugBotTelemetryHealthy(ctx context.Context, in *CheckBugBotTelemetryHealthyRequest, opts ...grpc.CallOption) (*CheckBugBotTelemetryHealthyResponse, error)
	RecordIdeBugReaction(ctx context.Context, in *RecordIdeBugReactionRequest, opts ...grpc.CallOption) (*RecordIdeBugReactionResponse, error)
	GetSuggestedBugBotIterations(ctx context.Context, in *GetSuggestedBugBotIterationsRequest, opts ...grpc.CallOption) (*GetSuggestedBugBotIterationsResponse, error)
	GetEditorBugbotAutoRunStatus(ctx context.Context, in *GetEditorBugbotAutoRunStatusRequest, opts ...grpc.CallOption) (*GetEditorBugbotAutoRunStatusResponse, error)
	TestBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TestBidiRequest, TestBidiResponse], error)
	StreamDiffReview(ctx context.Context, in *GetDiffReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamDiffReviewResponse], error)
	StreamDiffReviewByFile(ctx context.Context, in *GetDiffReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamDiffReviewByFileResponse], error)
	GetModelLabels(ctx context.Context, in *GetModelLabelsRequest, opts ...grpc.CallOption) (*GetModelLabelsResponse, error)
	GetLastDefaultModelNudge(ctx context.Context, in *GetLastDefaultModelNudgeRequest, opts ...grpc.CallOption) (*GetLastDefaultModelNudgeResponse, error)
	GetDefaultModelNudgeData(ctx context.Context, in *GetDefaultModelNudgeDataRequest, opts ...grpc.CallOption) (*GetDefaultModelNudgeDataResponse, error)
	GetDefaultModel(ctx context.Context, in *GetDefaultModelRequest, opts ...grpc.CallOption) (*GetDefaultModelResponse, error)
	ReportCommitAiAnalytics(ctx context.Context, in *ReportCommitAiAnalyticsRequest, opts ...grpc.CallOption) (*ReportCommitAiAnalyticsResponse, error)
	TestBedrockCredentials(ctx context.Context, in *TestBedrockCredentialsRequest, opts ...grpc.CallOption) (*TestBedrockCredentialsResponse, error)
	ReportAiCodeChangeMetrics(ctx context.Context, in *ReportAiCodeChangeMetricsRequest, opts ...grpc.CallOption) (*ReportAiCodeChangeMetricsResponse, error)
	ReportProcessMetrics(ctx context.Context, in *ReportProcessMetricsRequest, opts ...grpc.CallOption) (*ReportProcessMetricsResponse, error)
	ReportProcessMetricsV2(ctx context.Context, in *ReportProcessMetricsV2Request, opts ...grpc.CallOption) (*ReportProcessMetricsV2Response, error)
	ReportClientNumericMetrics(ctx context.Context, in *ReportClientNumericMetricsRequest, opts ...grpc.CallOption) (*ReportClientNumericMetricsResponse, error)
	PotentiallyGenerateMemory(ctx context.Context, in *PotentiallyGenerateMemoryRequest, opts ...grpc.CallOption) (*PotentiallyGenerateMemoryResponse, error)
	KnowledgeBaseAdd(ctx context.Context, in *KnowledgeBaseAddRequest, opts ...grpc.CallOption) (*KnowledgeBaseAddResponse, error)
	KnowledgeBaseList(ctx context.Context, in *KnowledgeBaseListRequest, opts ...grpc.CallOption) (*KnowledgeBaseListResponse, error)
	KnowledgeBaseRemove(ctx context.Context, in *KnowledgeBaseRemoveRequest, opts ...grpc.CallOption) (*KnowledgeBaseRemoveResponse, error)
	KnowledgeBaseUpdate(ctx context.Context, in *KnowledgeBaseUpdateRequest, opts ...grpc.CallOption) (*KnowledgeBaseUpdateResponse, error)
	FetchRelevantKnowledgeForConversation(ctx context.Context, in *FetchRelevantKnowledgeForConversationRequest, opts ...grpc.CallOption) (*FetchRelevantKnowledgeForConversationResponse, error)
	InferBackgroundComposerScripts(ctx context.Context, in *InferBackgroundComposerScriptsRequest, opts ...grpc.CallOption) (*InferBackgroundComposerScriptsResponse, error)
	GetBackgroundComposerFeedbackLink(ctx context.Context, in *GetBackgroundComposerFeedbackLinkRequest, opts ...grpc.CallOption) (*GetBackgroundComposerFeedbackLinkResponse, error)
	GetUsableModels(ctx context.Context, in *GetUsableModelsRequest, opts ...grpc.CallOption) (*GetUsableModelsResponse, error)
	GetDefaultModelForCli(ctx context.Context, in *GetDefaultModelForCliRequest, opts ...grpc.CallOption) (*GetDefaultModelForCliResponse, error)
	StreamComposerEnhancer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage], error)
	StreamComposerEnhancerSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ComposerEnhancerServerMessage], error)
	StreamComposerEnhancerPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	StreamStt(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SttClientMessage, SttServerMessage], error)
	StreamSttSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SttServerMessage], error)
	StreamSttPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	NameAgent(ctx context.Context, in *NameAgentRequest, opts ...grpc.CallOption) (*NameAgentResponse, error)
	EvaluatePromptHook(ctx context.Context, in *EvaluatePromptHookRequest, opts ...grpc.CallOption) (*EvaluatePromptHookResponse, error)
}

type aiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAiServiceClient(cc grpc.ClientConnInterface) AiServiceClient {
	return &aiServiceClient{cc}
}

func (c *aiServiceClient) ServerTime(ctx context.Context, in *ServerTimeRequest, opts ...grpc.CallOption) (*ServerTimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerTimeResponse)
	err := c.cc.Invoke(ctx, AiService_ServerTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, AiService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) PrivacyCheck(ctx context.Context, in *PrivacyCheckRequest, opts ...grpc.CallOption) (*PrivacyCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrivacyCheckResponse)
	err := c.cc.Invoke(ctx, AiService_PrivacyCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TimeLeftHealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*TimeLeftHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimeLeftHealthCheckResponse)
	err := c.cc.Invoke(ctx, AiService_TimeLeftHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ThrowErrorCheck(ctx context.Context, in *ThrowErrorCheckRequest, opts ...grpc.CallOption) (*ThrowErrorCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ThrowErrorCheckResponse)
	err := c.cc.Invoke(ctx, AiService_ThrowErrorCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) AvailableModels(ctx context.Context, in *AvailableModelsRequest, opts ...grpc.CallOption) (*AvailableModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableModelsResponse)
	err := c.cc.Invoke(ctx, AiService_AvailableModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamChatTryReallyHard(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[0], AiService_StreamChatTryReallyHard_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetChatRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatTryReallyHardClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) RerankDocuments(ctx context.Context, in *RerankDocumentsRequest, opts ...grpc.CallOption) (*RerankDocumentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankDocumentsResponse)
	err := c.cc.Invoke(ctx, AiService_RerankDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamComposer(ctx context.Context, in *GetComposerChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[1], AiService_StreamComposer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetComposerChatRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) StreamComposerContext(ctx context.Context, in *StreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatContextResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[2], AiService_StreamComposerContext_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamChatContextRequest, StreamChatContextResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerContextClient = grpc.ServerStreamingClient[StreamChatContextResponse]

func (c *aiServiceClient) WarmComposerCache(ctx context.Context, in *GetComposerChatRequest, opts ...grpc.CallOption) (*WarmComposerCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmComposerCacheResponse)
	err := c.cc.Invoke(ctx, AiService_WarmComposerCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) KeepComposerCacheWarm(ctx context.Context, in *KeepComposerCacheWarmRequest, opts ...grpc.CallOption) (*KeepComposerCacheWarmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KeepComposerCacheWarmResponse)
	err := c.cc.Invoke(ctx, AiService_KeepComposerCacheWarm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CountTokens(ctx context.Context, in *CountTokensRequest, opts ...grpc.CallOption) (*CountTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountTokensResponse)
	err := c.cc.Invoke(ctx, AiService_CountTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamPotentialLocs(ctx context.Context, in *PotentialLocsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[3], AiService_StreamPotentialLocs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PotentialLocsRequest, PotentialLocsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsClient = grpc.ServerStreamingClient[PotentialLocsResponse]

func (c *aiServiceClient) StreamPotentialLocsUnderneath(ctx context.Context, in *PotentialLocsUnderneathRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsUnderneathResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[4], AiService_StreamPotentialLocsUnderneath_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PotentialLocsUnderneathRequest, PotentialLocsUnderneathResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsUnderneathClient = grpc.ServerStreamingClient[PotentialLocsUnderneathResponse]

func (c *aiServiceClient) StreamPotentialLocsInitialQueries(ctx context.Context, in *PotentialLocsInitialQueriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PotentialLocsInitialQueriesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[5], AiService_StreamPotentialLocsInitialQueries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PotentialLocsInitialQueriesRequest, PotentialLocsInitialQueriesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsInitialQueriesClient = grpc.ServerStreamingClient[PotentialLocsInitialQueriesResponse]

func (c *aiServiceClient) GetChatTitle(ctx context.Context, in *GetChatTitleRequest, opts ...grpc.CallOption) (*GetChatTitleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChatTitleResponse)
	err := c.cc.Invoke(ctx, AiService_GetChatTitle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetCompletion(ctx context.Context, in *GetCompletionRequest, opts ...grpc.CallOption) (*GetCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCompletionResponse)
	err := c.cc.Invoke(ctx, AiService_GetCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) IsolatedTreesitter(ctx context.Context, in *IsolatedTreesitterRequest, opts ...grpc.CallOption) (*IsolatedTreesitterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsolatedTreesitterResponse)
	err := c.cc.Invoke(ctx, AiService_IsolatedTreesitter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetSimplePrompt(ctx context.Context, in *GetSimplePromptRequest, opts ...grpc.CallOption) (*GetSimplePromptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSimplePromptResponse)
	err := c.cc.Invoke(ctx, AiService_GetSimplePrompt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetPassthroughPrompt(ctx context.Context, in *GetPassthroughPromptRequest, opts ...grpc.CallOption) (*GetPassthroughPromptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPassthroughPromptResponse)
	err := c.cc.Invoke(ctx, AiService_GetPassthroughPrompt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckLongFilesFit(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (*CheckLongFilesFitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckLongFilesFitResponse)
	err := c.cc.Invoke(ctx, AiService_CheckLongFilesFit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetEvaluationPrompt(ctx context.Context, in *GetEvaluationPromptRequest, opts ...grpc.CallOption) (*GetEvaluationPromptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEvaluationPromptResponse)
	err := c.cc.Invoke(ctx, AiService_GetEvaluationPrompt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInfoResponse)
	err := c.cc.Invoke(ctx, AiService_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamChat(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[6], AiService_StreamChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetChatRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) StreamChatWeb(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[7], AiService_StreamChatWeb_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetChatRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatWebClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) WarmChatCache(ctx context.Context, in *WarmChatCacheRequest, opts ...grpc.CallOption) (*WarmChatCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmChatCacheResponse)
	err := c.cc.Invoke(ctx, AiService_WarmChatCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamEdit(ctx context.Context, in *StreamEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[8], AiService_StreamEdit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamEditRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamEditClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) PreloadEdit(ctx context.Context, in *PreloadEditRequest, opts ...grpc.CallOption) (*PreloadEditResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PreloadEditResponse)
	err := c.cc.Invoke(ctx, AiService_PreloadEdit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamFastEdit(ctx context.Context, in *StreamFastEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamFastEditResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[9], AiService_StreamFastEdit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamFastEditRequest, StreamFastEditResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamFastEditClient = grpc.ServerStreamingClient[StreamFastEditResponse]

func (c *aiServiceClient) StreamGenerate(ctx context.Context, in *StreamGenerateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[10], AiService_StreamGenerate_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamGenerateRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamGenerateClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) StreamInlineLongCompletion(ctx context.Context, in *StreamInlineLongCompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[11], AiService_StreamInlineLongCompletion_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamInlineLongCompletionRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamInlineLongCompletionClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) SlashEdit(ctx context.Context, in *SlashEditRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SlashEditResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[12], AiService_SlashEdit_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SlashEditRequest, SlashEditResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_SlashEditClient = grpc.ServerStreamingClient[SlashEditResponse]

func (c *aiServiceClient) SlashEditFollowUpWithPreviousEdits(ctx context.Context, in *SlashEditFollowUpWithPreviousEditsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamSlashEditFollowUpWithPreviousEditsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[13], AiService_SlashEditFollowUpWithPreviousEdits_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SlashEditFollowUpWithPreviousEditsRequest, StreamSlashEditFollowUpWithPreviousEditsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_SlashEditFollowUpWithPreviousEditsClient = grpc.ServerStreamingClient[StreamSlashEditFollowUpWithPreviousEditsResponse]

func (c *aiServiceClient) StreamAiPreviews(ctx context.Context, in *StreamAiPreviewsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiPreviewsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[14], AiService_StreamAiPreviews_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamAiPreviewsRequest, StreamAiPreviewsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiPreviewsClient = grpc.ServerStreamingClient[StreamAiPreviewsResponse]

func (c *aiServiceClient) ShouldTurnOnCppOnboarding(ctx context.Context, in *ShouldTurnOnCppOnboardingRequest, opts ...grpc.CallOption) (*ShouldTurnOnCppOnboardingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShouldTurnOnCppOnboardingResponse)
	err := c.cc.Invoke(ctx, AiService_ShouldTurnOnCppOnboarding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetComposerAutocomplete(ctx context.Context, in *GetComposerAutocompleteRequest, opts ...grpc.CallOption) (*GetComposerAutocompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComposerAutocompleteResponse)
	err := c.cc.Invoke(ctx, AiService_GetComposerAutocomplete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamReview(ctx context.Context, in *ReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[15], AiService_StreamReview_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReviewRequest, ReviewResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamReviewClient = grpc.ServerStreamingClient[ReviewResponse]

func (c *aiServiceClient) StreamReviewChat(ctx context.Context, in *ReviewChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[16], AiService_StreamReviewChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReviewChatRequest, ReviewChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamReviewChatClient = grpc.ServerStreamingClient[ReviewChatResponse]

func (c *aiServiceClient) CheckQueuePosition(ctx context.Context, in *CheckQueuePositionRequest, opts ...grpc.CallOption) (*CheckQueuePositionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckQueuePositionResponse)
	err := c.cc.Invoke(ctx, AiService_CheckQueuePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckUsageBasedPrice(ctx context.Context, in *CheckUsageBasedPriceRequest, opts ...grpc.CallOption) (*CheckUsageBasedPriceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUsageBasedPriceResponse)
	err := c.cc.Invoke(ctx, AiService_CheckUsageBasedPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) DoThisForMeCheck(ctx context.Context, in *DoThisForMeCheckRequest, opts ...grpc.CallOption) (*DoThisForMeCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DoThisForMeCheckResponse)
	err := c.cc.Invoke(ctx, AiService_DoThisForMeCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamDoThisForMe(ctx context.Context, in *DoThisForMeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DoThisForMeResponseWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[17], AiService_StreamDoThisForMe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DoThisForMeRequest, DoThisForMeResponseWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDoThisForMeClient = grpc.ServerStreamingClient[DoThisForMeResponseWrapped]

func (c *aiServiceClient) StreamChatToolformer(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatToolformerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[18], AiService_StreamChatToolformer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetChatRequest, StreamChatToolformerResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatToolformerClient = grpc.ServerStreamingClient[StreamChatToolformerResponse]

func (c *aiServiceClient) StreamChatToolformerContinue(ctx context.Context, in *StreamChatToolformerContinueRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatToolformerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[19], AiService_StreamChatToolformerContinue_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamChatToolformerContinueRequest, StreamChatToolformerResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatToolformerContinueClient = grpc.ServerStreamingClient[StreamChatToolformerResponse]

func (c *aiServiceClient) PushAiThought(ctx context.Context, in *PushAiThoughtRequest, opts ...grpc.CallOption) (*PushAiThoughtResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushAiThoughtResponse)
	err := c.cc.Invoke(ctx, AiService_PushAiThought_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckDoableAsTask(ctx context.Context, in *CheckDoableAsTaskRequest, opts ...grpc.CallOption) (*CheckDoableAsTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckDoableAsTaskResponse)
	err := c.cc.Invoke(ctx, AiService_CheckDoableAsTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportGroundTruthCandidate(ctx context.Context, in *ReportGroundTruthCandidateRequest, opts ...grpc.CallOption) (*ReportGroundTruthCandidateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportGroundTruthCandidateResponse)
	err := c.cc.Invoke(ctx, AiService_ReportGroundTruthCandidate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportCmdKFate(ctx context.Context, in *ReportCmdKFateRequest, opts ...grpc.CallOption) (*ReportCmdKFateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportCmdKFateResponse)
	err := c.cc.Invoke(ctx, AiService_ReportCmdKFate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ShowWelcomeScreen(ctx context.Context, in *ShowWelcomeScreenRequest, opts ...grpc.CallOption) (*ShowWelcomeScreenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShowWelcomeScreenResponse)
	err := c.cc.Invoke(ctx, AiService_ShowWelcomeScreen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) InterfaceAgentInit(ctx context.Context, in *InterfaceAgentInitRequest, opts ...grpc.CallOption) (*InterfaceAgentInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InterfaceAgentInitResponse)
	err := c.cc.Invoke(ctx, AiService_InterfaceAgentInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamInterfaceAgentStatus(ctx context.Context, in *StreamInterfaceAgentStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamInterfaceAgentStatusResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[20], AiService_StreamInterfaceAgentStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamInterfaceAgentStatusRequest, StreamInterfaceAgentStatusResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamInterfaceAgentStatusClient = grpc.ServerStreamingClient[StreamInterfaceAgentStatusResponse]

func (c *aiServiceClient) TaskGetInterfaceAgentStatus(ctx context.Context, in *TaskGetInterfaceAgentStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskGetInterfaceAgentStatusResponseWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[21], AiService_TaskGetInterfaceAgentStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskGetInterfaceAgentStatusRequest, TaskGetInterfaceAgentStatusResponseWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskGetInterfaceAgentStatusClient = grpc.ServerStreamingClient[TaskGetInterfaceAgentStatusResponseWrapped]

func (c *aiServiceClient) UpdateVscodeProfile(ctx context.Context, in *UpdateVscodeProfileRequest, opts ...grpc.CallOption) (*UpdateVscodeProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVscodeProfileResponse)
	err := c.cc.Invoke(ctx, AiService_UpdateVscodeProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskInit(ctx context.Context, in *TaskInitRequest, opts ...grpc.CallOption) (*TaskInitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskInitResponse)
	err := c.cc.Invoke(ctx, AiService_TaskInit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskPause(ctx context.Context, in *TaskPauseRequest, opts ...grpc.CallOption) (*TaskPauseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskPauseResponse)
	err := c.cc.Invoke(ctx, AiService_TaskPause_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskInfo(ctx context.Context, in *TaskInfoRequest, opts ...grpc.CallOption) (*TaskInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskInfoResponse)
	err := c.cc.Invoke(ctx, AiService_TaskInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskStreamLog(ctx context.Context, in *TaskStreamLogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskStreamLogResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[22], AiService_TaskStreamLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskStreamLogRequest, TaskStreamLogResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskStreamLogClient = grpc.ServerStreamingClient[TaskStreamLogResponse]

func (c *aiServiceClient) TaskSendMessage(ctx context.Context, in *TaskSendMessageRequest, opts ...grpc.CallOption) (*TaskSendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskSendMessageResponse)
	err := c.cc.Invoke(ctx, AiService_TaskSendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskProvideResult(ctx context.Context, in *TaskProvideResultRequest, opts ...grpc.CallOption) (*TaskProvideResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskProvideResultResponse)
	err := c.cc.Invoke(ctx, AiService_TaskProvideResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CreateExperimentalIndex(ctx context.Context, in *CreateExperimentalIndexRequest, opts ...grpc.CallOption) (*CreateExperimentalIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateExperimentalIndexResponse)
	err := c.cc.Invoke(ctx, AiService_CreateExperimentalIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ListExperimentalIndexFiles(ctx context.Context, in *ListExperimentalIndexFilesRequest, opts ...grpc.CallOption) (*ListExperimentalIndexFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExperimentalIndexFilesResponse)
	err := c.cc.Invoke(ctx, AiService_ListExperimentalIndexFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ListenExperimentalIndex(ctx context.Context, in *ListenExperimentalIndexRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListenExperimentalIndexResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[23], AiService_ListenExperimentalIndex_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenExperimentalIndexRequest, ListenExperimentalIndexResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_ListenExperimentalIndexClient = grpc.ServerStreamingClient[ListenExperimentalIndexResponse]

func (c *aiServiceClient) RegisterFileToIndex(ctx context.Context, in *RegisterFileToIndexRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestReceivedResponse)
	err := c.cc.Invoke(ctx, AiService_RegisterFileToIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) SetupIndexDependencies(ctx context.Context, in *SetupIndexDependenciesRequest, opts ...grpc.CallOption) (*SetupIndexDependenciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupIndexDependenciesResponse)
	err := c.cc.Invoke(ctx, AiService_SetupIndexDependencies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ComputeIndexTopoSort(ctx context.Context, in *ComputeIndexTopoSortRequest, opts ...grpc.CallOption) (*ComputeIndexTopoSortResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComputeIndexTopoSortResponse)
	err := c.cc.Invoke(ctx, AiService_ComputeIndexTopoSort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamChatDeepContext(ctx context.Context, in *StreamChatDeepContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatDeepContextResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[24], AiService_StreamChatDeepContext_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamChatDeepContextRequest, StreamChatDeepContextResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatDeepContextClient = grpc.ServerStreamingClient[StreamChatDeepContextResponse]

func (c *aiServiceClient) ChooseCodeReferences(ctx context.Context, in *ChooseCodeReferencesRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestReceivedResponse)
	err := c.cc.Invoke(ctx, AiService_ChooseCodeReferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) RegisterCodeReferences(ctx context.Context, in *RegisterCodeReferencesRequest, opts ...grpc.CallOption) (*RegisterCodeReferencesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterCodeReferencesResponse)
	err := c.cc.Invoke(ctx, AiService_RegisterCodeReferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ExtractPaths(ctx context.Context, in *ExtractPathsRequest, opts ...grpc.CallOption) (*ExtractPathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtractPathsResponse)
	err := c.cc.Invoke(ctx, AiService_ExtractPaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) SummarizeWithReferences(ctx context.Context, in *SummarizeWithReferencesRequest, opts ...grpc.CallOption) (*RequestReceivedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestReceivedResponse)
	err := c.cc.Invoke(ctx, AiService_SummarizeWithReferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) DocumentationQuery(ctx context.Context, in *DocumentationQueryRequest, opts ...grpc.CallOption) (*DocumentationQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DocumentationQueryResponse)
	err := c.cc.Invoke(ctx, AiService_DocumentationQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) AvailableDocs(ctx context.Context, in *AvailableDocsRequest, opts ...grpc.CallOption) (*AvailableDocsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableDocsResponse)
	err := c.cc.Invoke(ctx, AiService_AvailableDocs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportFeedback(ctx context.Context, in *ReportFeedbackRequest, opts ...grpc.CallOption) (*ReportFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportFeedbackResponse)
	err := c.cc.Invoke(ctx, AiService_ReportFeedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportBug(ctx context.Context, in *ReportBugRequest, opts ...grpc.CallOption) (*ReportBugResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportBugResponse)
	err := c.cc.Invoke(ctx, AiService_ReportBug_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamChatContext(ctx context.Context, in *StreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatContextResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[25], AiService_StreamChatContext_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamChatContextRequest, StreamChatContextResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatContextClient = grpc.ServerStreamingClient[StreamChatContextResponse]

func (c *aiServiceClient) GenerateTldr(ctx context.Context, in *GenerateTldrRequest, opts ...grpc.CallOption) (*GenerateTldrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateTldrResponse)
	err := c.cc.Invoke(ctx, AiService_GenerateTldr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TaskStreamChatContext(ctx context.Context, in *TaskStreamChatContextRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskStreamChatContextResponseWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[26], AiService_TaskStreamChatContext_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskStreamChatContextRequest, TaskStreamChatContextResponseWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskStreamChatContextClient = grpc.ServerStreamingClient[TaskStreamChatContextResponseWrapped]

func (c *aiServiceClient) RerankResults(ctx context.Context, in *RerankerRequest, opts ...grpc.CallOption) (*RerankerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankerResponse)
	err := c.cc.Invoke(ctx, AiService_RerankResults_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ModelQuery(ctx context.Context, in *ModelQueryRequest, opts ...grpc.CallOption) (*ModelQueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelQueryResponse)
	err := c.cc.Invoke(ctx, AiService_ModelQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ModelQueryV2(ctx context.Context, in *ModelQueryRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ModelQueryResponseV2], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[27], AiService_ModelQueryV2_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ModelQueryRequest, ModelQueryResponseV2]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_ModelQueryV2Client = grpc.ServerStreamingClient[ModelQueryResponseV2]

func (c *aiServiceClient) IntentPrediction(ctx context.Context, in *IntentPredictionRequest, opts ...grpc.CallOption) (*IntentPredictionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntentPredictionResponse)
	err := c.cc.Invoke(ctx, AiService_IntentPrediction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetChatSuggestions(ctx context.Context, in *GetChatSuggestionsRequest, opts ...grpc.CallOption) (*GetChatSuggestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChatSuggestionsResponse)
	err := c.cc.Invoke(ctx, AiService_GetChatSuggestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetUserInstructions(ctx context.Context, in *GetUserInstructionsRequest, opts ...grpc.CallOption) (*GetUserInstructionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInstructionsResponse)
	err := c.cc.Invoke(ctx, AiService_GetUserInstructions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamCursorTutor(ctx context.Context, in *StreamCursorTutorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCursorTutorResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[28], AiService_StreamCursorTutor_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCursorTutorRequest, StreamCursorTutorResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCursorTutorClient = grpc.ServerStreamingClient[StreamCursorTutorResponse]

func (c *aiServiceClient) CheckFeatureStatus(ctx context.Context, in *CheckFeatureStatusRequest, opts ...grpc.CallOption) (*CheckFeatureStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckFeatureStatusResponse)
	err := c.cc.Invoke(ctx, AiService_CheckFeatureStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckFeaturesStatus(ctx context.Context, in *CheckFeaturesStatusRequest, opts ...grpc.CallOption) (*CheckFeaturesStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckFeaturesStatusResponse)
	err := c.cc.Invoke(ctx, AiService_CheckFeaturesStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckFeatureStatusUnauthenticated(ctx context.Context, in *CheckFeatureStatusRequest, opts ...grpc.CallOption) (*CheckFeatureStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckFeatureStatusResponse)
	err := c.cc.Invoke(ctx, AiService_CheckFeatureStatusUnauthenticated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetEffectiveTokenLimit(ctx context.Context, in *GetEffectiveTokenLimitRequest, opts ...grpc.CallOption) (*GetEffectiveTokenLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEffectiveTokenLimitResponse)
	err := c.cc.Invoke(ctx, AiService_GetEffectiveTokenLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetContextScores(ctx context.Context, in *ContextScoresRequest, opts ...grpc.CallOption) (*ContextScoresResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextScoresResponse)
	err := c.cc.Invoke(ctx, AiService_GetContextScores_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamCpp(ctx context.Context, in *StreamCppRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCppResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[29], AiService_StreamCpp_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCppRequest, StreamCppResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCppClient = grpc.ServerStreamingClient[StreamCppResponse]

func (c *aiServiceClient) CppConfig(ctx context.Context, in *CppConfigRequest, opts ...grpc.CallOption) (*CppConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CppConfigResponse)
	err := c.cc.Invoke(ctx, AiService_CppConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CppEditHistoryStatus(ctx context.Context, in *CppEditHistoryStatusRequest, opts ...grpc.CallOption) (*CppEditHistoryStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CppEditHistoryStatusResponse)
	err := c.cc.Invoke(ctx, AiService_CppEditHistoryStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CppAppend(ctx context.Context, in *CppAppendRequest, opts ...grpc.CallOption) (*CppAppendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CppAppendResponse)
	err := c.cc.Invoke(ctx, AiService_CppAppend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) RefreshTabContext(ctx context.Context, in *RefreshTabContextRequest, opts ...grpc.CallOption) (*RefreshTabContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTabContextResponse)
	err := c.cc.Invoke(ctx, AiService_RefreshTabContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckNumberConfig(ctx context.Context, in *CheckNumberConfigRequest, opts ...grpc.CallOption) (*CheckNumberConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckNumberConfigResponse)
	err := c.cc.Invoke(ctx, AiService_CheckNumberConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckNumberConfigUnauthenticated(ctx context.Context, in *CheckNumberConfigRequest, opts ...grpc.CallOption) (*CheckNumberConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckNumberConfigResponse)
	err := c.cc.Invoke(ctx, AiService_CheckNumberConfigUnauthenticated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckNumberConfigs(ctx context.Context, in *CheckNumberConfigsRequest, opts ...grpc.CallOption) (*CheckNumberConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckNumberConfigsResponse)
	err := c.cc.Invoke(ctx, AiService_CheckNumberConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamTerminalAutocomplete(ctx context.Context, in *StreamTerminalAutocompleteRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTerminalAutocompleteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[30], AiService_StreamTerminalAutocomplete_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamTerminalAutocompleteRequest, StreamTerminalAutocompleteResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamTerminalAutocompleteClient = grpc.ServerStreamingClient[StreamTerminalAutocompleteResponse]

func (c *aiServiceClient) StreamPseudocodeGenerator(ctx context.Context, in *StreamPseudocodeGeneratorRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPseudocodeGeneratorResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[31], AiService_StreamPseudocodeGenerator_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPseudocodeGeneratorRequest, StreamPseudocodeGeneratorResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPseudocodeGeneratorClient = grpc.ServerStreamingClient[StreamPseudocodeGeneratorResponse]

func (c *aiServiceClient) StreamPseudocodeMapper(ctx context.Context, in *StreamPseudocodeMapperRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPseudocodeMapperResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[32], AiService_StreamPseudocodeMapper_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPseudocodeMapperRequest, StreamPseudocodeMapperResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPseudocodeMapperClient = grpc.ServerStreamingClient[StreamPseudocodeMapperResponse]

func (c *aiServiceClient) AcknowledgeGracePeriodDisclaimer(ctx context.Context, in *AcknowledgeGracePeriodDisclaimerRequest, opts ...grpc.CallOption) (*AcknowledgeGracePeriodDisclaimerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcknowledgeGracePeriodDisclaimerResponse)
	err := c.cc.Invoke(ctx, AiService_AcknowledgeGracePeriodDisclaimer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamAiLintBug(ctx context.Context, in *StreamAiLintBugRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiLintBugResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[33], AiService_StreamAiLintBug_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamAiLintBugRequest, StreamAiLintBugResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiLintBugClient = grpc.ServerStreamingClient[StreamAiLintBugResponse]

func (c *aiServiceClient) StreamAiCursorHelp(ctx context.Context, in *StreamAiCursorHelpRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamAiCursorHelpResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[34], AiService_StreamAiCursorHelp_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamAiCursorHelpRequest, StreamAiCursorHelpResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiCursorHelpClient = grpc.ServerStreamingClient[StreamAiCursorHelpResponse]

func (c *aiServiceClient) LogUserLintReply(ctx context.Context, in *LogUserLintReplyRequest, opts ...grpc.CallOption) (*LogUserLintReplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogUserLintReplyResponse)
	err := c.cc.Invoke(ctx, AiService_LogUserLintReply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) LogLinterExplicitUserFeedback(ctx context.Context, in *LogLinterExplicitUserFeedbackRequest, opts ...grpc.CallOption) (*LogLinterExplicitUserFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogLinterExplicitUserFeedbackResponse)
	err := c.cc.Invoke(ctx, AiService_LogLinterExplicitUserFeedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamFixMarkers(ctx context.Context, in *FixMarkersRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FixMarkersResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[35], AiService_StreamFixMarkers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FixMarkersRequest, FixMarkersResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamFixMarkersClient = grpc.ServerStreamingClient[FixMarkersResponse]

func (c *aiServiceClient) ReportInlineAction(ctx context.Context, in *ReportInlineActionRequest, opts ...grpc.CallOption) (*ReportInlineActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportInlineActionResponse)
	err := c.cc.Invoke(ctx, AiService_ReportInlineAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamPriomptPrompt(ctx context.Context, in *StreamPriomptPromptRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamPriomptPromptResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[36], AiService_StreamPriomptPrompt_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPriomptPromptRequest, StreamPriomptPromptResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPriomptPromptClient = grpc.ServerStreamingClient[StreamPriomptPromptResponse]

func (c *aiServiceClient) StreamLint(ctx context.Context, in *StreamLintRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[37], AiService_StreamLint_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamLintRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamLintClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) StreamNewLintRule(ctx context.Context, in *StreamNewRuleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[38], AiService_StreamNewLintRule_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamNewRuleRequest, StreamChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamNewLintRuleClient = grpc.ServerStreamingClient[StreamChatResponse]

func (c *aiServiceClient) AiProject(ctx context.Context, in *AiProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AiProjectResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[39], AiService_AiProject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AiProjectRequest, AiProjectResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_AiProjectClient = grpc.ServerStreamingClient[AiProjectResponse]

func (c *aiServiceClient) ToCamelCase(ctx context.Context, in *ToCamelCaseRequest, opts ...grpc.CallOption) (*ToCamelCaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ToCamelCaseResponse)
	err := c.cc.Invoke(ctx, AiService_ToCamelCase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportGenerationFeedback(ctx context.Context, in *ReportGenerationFeedbackRequest, opts ...grpc.CallOption) (*ReportGenerationFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportGenerationFeedbackResponse)
	err := c.cc.Invoke(ctx, AiService_ReportGenerationFeedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetThoughtAnnotation(ctx context.Context, in *GetThoughtAnnotationRequest, opts ...grpc.CallOption) (*GetThoughtAnnotationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetThoughtAnnotationResponse)
	err := c.cc.Invoke(ctx, AiService_GetThoughtAnnotation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamWebCmdKV1(ctx context.Context, in *StreamWebCmdKV1Request, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamWebCmdKV1Response], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[40], AiService_StreamWebCmdKV1_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamWebCmdKV1Request, StreamWebCmdKV1Response]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamWebCmdKV1Client = grpc.ServerStreamingClient[StreamWebCmdKV1Response]

func (c *aiServiceClient) StreamNextCursorPrediction(ctx context.Context, in *StreamNextCursorPredictionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamNextCursorPredictionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[41], AiService_StreamNextCursorPrediction_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamNextCursorPredictionRequest, StreamNextCursorPredictionResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamNextCursorPredictionClient = grpc.ServerStreamingClient[StreamNextCursorPredictionResponse]

func (c *aiServiceClient) IsCursorPredictionEnabled(ctx context.Context, in *IsCursorPredictionEnabledRequest, opts ...grpc.CallOption) (*IsCursorPredictionEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsCursorPredictionEnabledResponse)
	err := c.cc.Invoke(ctx, AiService_IsCursorPredictionEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetCppEditClassification(ctx context.Context, in *GetCppEditClassificationRequest, opts ...grpc.CallOption) (*GetCppEditClassificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCppEditClassificationResponse)
	err := c.cc.Invoke(ctx, AiService_GetCppEditClassification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetTerminalCompletion(ctx context.Context, in *GetTerminalCompletionRequest, opts ...grpc.CallOption) (*GetTerminalCompletionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTerminalCompletionResponse)
	err := c.cc.Invoke(ctx, AiService_GetTerminalCompletion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TakeNotesOnCommitDiff(ctx context.Context, in *TakeNotesOnCommitDiffRequest, opts ...grpc.CallOption) (*TakeNotesOnCommitDiffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TakeNotesOnCommitDiffResponse)
	err := c.cc.Invoke(ctx, AiService_TakeNotesOnCommitDiff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) BulkEmbed(ctx context.Context, in *BulkEmbedRequest, opts ...grpc.CallOption) (*BulkEmbedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BulkEmbedResponse)
	err := c.cc.Invoke(ctx, AiService_BulkEmbed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) BackgroundCmdKEval(ctx context.Context, in *BackgroundCmdKEvalRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BackgroundCmdKEvalResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[42], AiService_BackgroundCmdKEval_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BackgroundCmdKEvalRequest, BackgroundCmdKEvalResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_BackgroundCmdKEvalClient = grpc.ServerStreamingClient[BackgroundCmdKEvalResponse]

func (c *aiServiceClient) BackgroundCmdK(ctx context.Context, in *BackgroundCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BackgroundCmdKResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[43], AiService_BackgroundCmdK_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BackgroundCmdKRequest, BackgroundCmdKResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_BackgroundCmdKClient = grpc.ServerStreamingClient[BackgroundCmdKResponse]

func (c *aiServiceClient) StreamCursorMotion(ctx context.Context, in *StreamCursorMotionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCursorMotionResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[44], AiService_StreamCursorMotion_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCursorMotionRequest, StreamCursorMotionResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCursorMotionClient = grpc.ServerStreamingClient[StreamCursorMotionResponse]

func (c *aiServiceClient) CalculateAutoSelection(ctx context.Context, in *CalculateAutoSelectionRequest, opts ...grpc.CallOption) (*CalculateAutoSelectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalculateAutoSelectionResponse)
	err := c.cc.Invoke(ctx, AiService_CalculateAutoSelection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetAtSymbolSuggestions(ctx context.Context, in *GetAtSymbolSuggestionsRequest, opts ...grpc.CallOption) (*GetAtSymbolSuggestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAtSymbolSuggestionsResponse)
	err := c.cc.Invoke(ctx, AiService_GetAtSymbolSuggestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetCodebaseQuestions(ctx context.Context, in *GetChatRequest, opts ...grpc.CallOption) (*GetCodebaseQuestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCodebaseQuestionsResponse)
	err := c.cc.Invoke(ctx, AiService_GetCodebaseQuestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CppEditHistoryAppend(ctx context.Context, in *EditHistoryAppendChangesRequest, opts ...grpc.CallOption) (*EditHistoryAppendChangesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditHistoryAppendChangesResponse)
	err := c.cc.Invoke(ctx, AiService_CppEditHistoryAppend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) DevOnlyGetPastRequestIds(ctx context.Context, in *DevOnlyGetPastRequestIdsRequest, opts ...grpc.CallOption) (*DevOnlyGetPastRequestIdsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DevOnlyGetPastRequestIdsResponse)
	err := c.cc.Invoke(ctx, AiService_DevOnlyGetPastRequestIds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetFilesForComposer(ctx context.Context, in *GetFilesForComposerRequest, opts ...grpc.CallOption) (*GetFilesForComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFilesForComposerResponse)
	err := c.cc.Invoke(ctx, AiService_GetFilesForComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TryParseTypeScriptTreeSitter(ctx context.Context, in *TryParseTypeScriptTreeSitterRequest, opts ...grpc.CallOption) (*TryParseTypeScriptTreeSitterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TryParseTypeScriptTreeSitterResponse)
	err := c.cc.Invoke(ctx, AiService_TryParseTypeScriptTreeSitter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) NameTab(ctx context.Context, in *NameTabRequest, opts ...grpc.CallOption) (*NameTabResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NameTabResponse)
	err := c.cc.Invoke(ctx, AiService_NameTab_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) IsTerminalFinishedV2(ctx context.Context, in *IsTerminalFinishedRequest, opts ...grpc.CallOption) (*IsTerminalFinishedResponseV2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsTerminalFinishedResponseV2)
	err := c.cc.Invoke(ctx, AiService_IsTerminalFinishedV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TestModelStatus(ctx context.Context, in *TestModelStatusRequest, opts ...grpc.CallOption) (*TestModelStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestModelStatusResponse)
	err := c.cc.Invoke(ctx, AiService_TestModelStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) FindBugs(ctx context.Context, in *FindBugsRequest, opts ...grpc.CallOption) (*FindBugsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindBugsResponse)
	err := c.cc.Invoke(ctx, AiService_FindBugs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ContextReranking(ctx context.Context, in *ContextRerankingRequest, opts ...grpc.CallOption) (*ContextRerankingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextRerankingResponse)
	err := c.cc.Invoke(ctx, AiService_ContextReranking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) AutoContext(ctx context.Context, in *AutoContextRequest, opts ...grpc.CallOption) (*AutoContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AutoContextResponse)
	err := c.cc.Invoke(ctx, AiService_AutoContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) WriteGitCommitMessage(ctx context.Context, in *WriteGitCommitMessageRequest, opts ...grpc.CallOption) (*WriteGitCommitMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteGitCommitMessageResponse)
	err := c.cc.Invoke(ctx, AiService_WriteGitCommitMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) WriteGitBranchName(ctx context.Context, in *WriteGitBranchNameRequest, opts ...grpc.CallOption) (*WriteGitBranchNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteGitBranchNameResponse)
	err := c.cc.Invoke(ctx, AiService_WriteGitBranchName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamBugBot(ctx context.Context, in *StreamBugBotRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[45], AiService_StreamBugBot_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamBugBotRequest, StreamBugBotResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotClient = grpc.ServerStreamingClient[StreamBugBotResponse]

func (c *aiServiceClient) StreamBugBotAgentic(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[46], AiService_StreamBugBotAgentic_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticClient = grpc.BidiStreamingClient[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]

func (c *aiServiceClient) StreamBugBotAgenticSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotAgenticServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[47], AiService_StreamBugBotAgenticSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, StreamBugBotAgenticServerMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticSSEClient = grpc.ServerStreamingClient[StreamBugBotAgenticServerMessage]

func (c *aiServiceClient) StreamBugBotAgenticPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[48], AiService_StreamBugBotAgenticPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *aiServiceClient) StreamUiBestOfNJudge(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[49], AiService_StreamUiBestOfNJudge_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgeClient = grpc.BidiStreamingClient[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]

func (c *aiServiceClient) StreamUiBestOfNJudgeSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUiBestOfNJudgeServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[50], AiService_StreamUiBestOfNJudgeSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, StreamUiBestOfNJudgeServerMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgeSSEClient = grpc.ServerStreamingClient[StreamUiBestOfNJudgeServerMessage]

func (c *aiServiceClient) StreamUiBestOfNJudgePoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[51], AiService_StreamUiBestOfNJudgePoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgePollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *aiServiceClient) CheckBugBotPrice(ctx context.Context, in *CheckBugBotPriceRequest, opts ...grpc.CallOption) (*CheckBugBotPriceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckBugBotPriceResponse)
	err := c.cc.Invoke(ctx, AiService_CheckBugBotPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) CheckBugBotTelemetryHealthy(ctx context.Context, in *CheckBugBotTelemetryHealthyRequest, opts ...grpc.CallOption) (*CheckBugBotTelemetryHealthyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckBugBotTelemetryHealthyResponse)
	err := c.cc.Invoke(ctx, AiService_CheckBugBotTelemetryHealthy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) RecordIdeBugReaction(ctx context.Context, in *RecordIdeBugReactionRequest, opts ...grpc.CallOption) (*RecordIdeBugReactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordIdeBugReactionResponse)
	err := c.cc.Invoke(ctx, AiService_RecordIdeBugReaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetSuggestedBugBotIterations(ctx context.Context, in *GetSuggestedBugBotIterationsRequest, opts ...grpc.CallOption) (*GetSuggestedBugBotIterationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSuggestedBugBotIterationsResponse)
	err := c.cc.Invoke(ctx, AiService_GetSuggestedBugBotIterations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetEditorBugbotAutoRunStatus(ctx context.Context, in *GetEditorBugbotAutoRunStatusRequest, opts ...grpc.CallOption) (*GetEditorBugbotAutoRunStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEditorBugbotAutoRunStatusResponse)
	err := c.cc.Invoke(ctx, AiService_GetEditorBugbotAutoRunStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TestBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[TestBidiRequest, TestBidiResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[52], AiService_TestBidi_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TestBidiRequest, TestBidiResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TestBidiClient = grpc.BidiStreamingClient[TestBidiRequest, TestBidiResponse]

func (c *aiServiceClient) StreamDiffReview(ctx context.Context, in *GetDiffReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamDiffReviewResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[53], AiService_StreamDiffReview_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetDiffReviewRequest, StreamDiffReviewResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDiffReviewClient = grpc.ServerStreamingClient[StreamDiffReviewResponse]

func (c *aiServiceClient) StreamDiffReviewByFile(ctx context.Context, in *GetDiffReviewRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamDiffReviewByFileResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[54], AiService_StreamDiffReviewByFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetDiffReviewRequest, StreamDiffReviewByFileResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDiffReviewByFileClient = grpc.ServerStreamingClient[StreamDiffReviewByFileResponse]

func (c *aiServiceClient) GetModelLabels(ctx context.Context, in *GetModelLabelsRequest, opts ...grpc.CallOption) (*GetModelLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelLabelsResponse)
	err := c.cc.Invoke(ctx, AiService_GetModelLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetLastDefaultModelNudge(ctx context.Context, in *GetLastDefaultModelNudgeRequest, opts ...grpc.CallOption) (*GetLastDefaultModelNudgeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLastDefaultModelNudgeResponse)
	err := c.cc.Invoke(ctx, AiService_GetLastDefaultModelNudge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetDefaultModelNudgeData(ctx context.Context, in *GetDefaultModelNudgeDataRequest, opts ...grpc.CallOption) (*GetDefaultModelNudgeDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDefaultModelNudgeDataResponse)
	err := c.cc.Invoke(ctx, AiService_GetDefaultModelNudgeData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetDefaultModel(ctx context.Context, in *GetDefaultModelRequest, opts ...grpc.CallOption) (*GetDefaultModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDefaultModelResponse)
	err := c.cc.Invoke(ctx, AiService_GetDefaultModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportCommitAiAnalytics(ctx context.Context, in *ReportCommitAiAnalyticsRequest, opts ...grpc.CallOption) (*ReportCommitAiAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportCommitAiAnalyticsResponse)
	err := c.cc.Invoke(ctx, AiService_ReportCommitAiAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) TestBedrockCredentials(ctx context.Context, in *TestBedrockCredentialsRequest, opts ...grpc.CallOption) (*TestBedrockCredentialsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestBedrockCredentialsResponse)
	err := c.cc.Invoke(ctx, AiService_TestBedrockCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportAiCodeChangeMetrics(ctx context.Context, in *ReportAiCodeChangeMetricsRequest, opts ...grpc.CallOption) (*ReportAiCodeChangeMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportAiCodeChangeMetricsResponse)
	err := c.cc.Invoke(ctx, AiService_ReportAiCodeChangeMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportProcessMetrics(ctx context.Context, in *ReportProcessMetricsRequest, opts ...grpc.CallOption) (*ReportProcessMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportProcessMetricsResponse)
	err := c.cc.Invoke(ctx, AiService_ReportProcessMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportProcessMetricsV2(ctx context.Context, in *ReportProcessMetricsV2Request, opts ...grpc.CallOption) (*ReportProcessMetricsV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportProcessMetricsV2Response)
	err := c.cc.Invoke(ctx, AiService_ReportProcessMetricsV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) ReportClientNumericMetrics(ctx context.Context, in *ReportClientNumericMetricsRequest, opts ...grpc.CallOption) (*ReportClientNumericMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportClientNumericMetricsResponse)
	err := c.cc.Invoke(ctx, AiService_ReportClientNumericMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) PotentiallyGenerateMemory(ctx context.Context, in *PotentiallyGenerateMemoryRequest, opts ...grpc.CallOption) (*PotentiallyGenerateMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PotentiallyGenerateMemoryResponse)
	err := c.cc.Invoke(ctx, AiService_PotentiallyGenerateMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) KnowledgeBaseAdd(ctx context.Context, in *KnowledgeBaseAddRequest, opts ...grpc.CallOption) (*KnowledgeBaseAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KnowledgeBaseAddResponse)
	err := c.cc.Invoke(ctx, AiService_KnowledgeBaseAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) KnowledgeBaseList(ctx context.Context, in *KnowledgeBaseListRequest, opts ...grpc.CallOption) (*KnowledgeBaseListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KnowledgeBaseListResponse)
	err := c.cc.Invoke(ctx, AiService_KnowledgeBaseList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) KnowledgeBaseRemove(ctx context.Context, in *KnowledgeBaseRemoveRequest, opts ...grpc.CallOption) (*KnowledgeBaseRemoveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KnowledgeBaseRemoveResponse)
	err := c.cc.Invoke(ctx, AiService_KnowledgeBaseRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) KnowledgeBaseUpdate(ctx context.Context, in *KnowledgeBaseUpdateRequest, opts ...grpc.CallOption) (*KnowledgeBaseUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KnowledgeBaseUpdateResponse)
	err := c.cc.Invoke(ctx, AiService_KnowledgeBaseUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) FetchRelevantKnowledgeForConversation(ctx context.Context, in *FetchRelevantKnowledgeForConversationRequest, opts ...grpc.CallOption) (*FetchRelevantKnowledgeForConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchRelevantKnowledgeForConversationResponse)
	err := c.cc.Invoke(ctx, AiService_FetchRelevantKnowledgeForConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) InferBackgroundComposerScripts(ctx context.Context, in *InferBackgroundComposerScriptsRequest, opts ...grpc.CallOption) (*InferBackgroundComposerScriptsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InferBackgroundComposerScriptsResponse)
	err := c.cc.Invoke(ctx, AiService_InferBackgroundComposerScripts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetBackgroundComposerFeedbackLink(ctx context.Context, in *GetBackgroundComposerFeedbackLinkRequest, opts ...grpc.CallOption) (*GetBackgroundComposerFeedbackLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerFeedbackLinkResponse)
	err := c.cc.Invoke(ctx, AiService_GetBackgroundComposerFeedbackLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetUsableModels(ctx context.Context, in *GetUsableModelsRequest, opts ...grpc.CallOption) (*GetUsableModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsableModelsResponse)
	err := c.cc.Invoke(ctx, AiService_GetUsableModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) GetDefaultModelForCli(ctx context.Context, in *GetDefaultModelForCliRequest, opts ...grpc.CallOption) (*GetDefaultModelForCliResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDefaultModelForCliResponse)
	err := c.cc.Invoke(ctx, AiService_GetDefaultModelForCli_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) StreamComposerEnhancer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[55], AiService_StreamComposerEnhancer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerClient = grpc.BidiStreamingClient[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]

func (c *aiServiceClient) StreamComposerEnhancerSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ComposerEnhancerServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[56], AiService_StreamComposerEnhancerSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, ComposerEnhancerServerMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerSSEClient = grpc.ServerStreamingClient[ComposerEnhancerServerMessage]

func (c *aiServiceClient) StreamComposerEnhancerPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[57], AiService_StreamComposerEnhancerPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *aiServiceClient) StreamStt(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SttClientMessage, SttServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[58], AiService_StreamStt_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SttClientMessage, SttServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttClient = grpc.BidiStreamingClient[SttClientMessage, SttServerMessage]

func (c *aiServiceClient) StreamSttSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SttServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[59], AiService_StreamSttSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, SttServerMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttSSEClient = grpc.ServerStreamingClient[SttServerMessage]

func (c *aiServiceClient) StreamSttPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AiService_ServiceDesc.Streams[60], AiService_StreamSttPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *aiServiceClient) NameAgent(ctx context.Context, in *NameAgentRequest, opts ...grpc.CallOption) (*NameAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NameAgentResponse)
	err := c.cc.Invoke(ctx, AiService_NameAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiServiceClient) EvaluatePromptHook(ctx context.Context, in *EvaluatePromptHookRequest, opts ...grpc.CallOption) (*EvaluatePromptHookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvaluatePromptHookResponse)
	err := c.cc.Invoke(ctx, AiService_EvaluatePromptHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AiServiceServer is the server API for AiService service.
// All implementations must embed UnimplementedAiServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AiService (var: Wze)
type AiServiceServer interface {
	ServerTime(context.Context, *ServerTimeRequest) (*ServerTimeResponse, error)
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	PrivacyCheck(context.Context, *PrivacyCheckRequest) (*PrivacyCheckResponse, error)
	TimeLeftHealthCheck(context.Context, *HealthCheckRequest) (*TimeLeftHealthCheckResponse, error)
	ThrowErrorCheck(context.Context, *ThrowErrorCheckRequest) (*ThrowErrorCheckResponse, error)
	AvailableModels(context.Context, *AvailableModelsRequest) (*AvailableModelsResponse, error)
	StreamChatTryReallyHard(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	RerankDocuments(context.Context, *RerankDocumentsRequest) (*RerankDocumentsResponse, error)
	StreamComposer(*GetComposerChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	StreamComposerContext(*StreamChatContextRequest, grpc.ServerStreamingServer[StreamChatContextResponse]) error
	WarmComposerCache(context.Context, *GetComposerChatRequest) (*WarmComposerCacheResponse, error)
	KeepComposerCacheWarm(context.Context, *KeepComposerCacheWarmRequest) (*KeepComposerCacheWarmResponse, error)
	CountTokens(context.Context, *CountTokensRequest) (*CountTokensResponse, error)
	StreamPotentialLocs(*PotentialLocsRequest, grpc.ServerStreamingServer[PotentialLocsResponse]) error
	StreamPotentialLocsUnderneath(*PotentialLocsUnderneathRequest, grpc.ServerStreamingServer[PotentialLocsUnderneathResponse]) error
	StreamPotentialLocsInitialQueries(*PotentialLocsInitialQueriesRequest, grpc.ServerStreamingServer[PotentialLocsInitialQueriesResponse]) error
	GetChatTitle(context.Context, *GetChatTitleRequest) (*GetChatTitleResponse, error)
	GetCompletion(context.Context, *GetCompletionRequest) (*GetCompletionResponse, error)
	IsolatedTreesitter(context.Context, *IsolatedTreesitterRequest) (*IsolatedTreesitterResponse, error)
	GetSimplePrompt(context.Context, *GetSimplePromptRequest) (*GetSimplePromptResponse, error)
	GetPassthroughPrompt(context.Context, *GetPassthroughPromptRequest) (*GetPassthroughPromptResponse, error)
	CheckLongFilesFit(context.Context, *GetChatRequest) (*CheckLongFilesFitResponse, error)
	GetEvaluationPrompt(context.Context, *GetEvaluationPromptRequest) (*GetEvaluationPromptResponse, error)
	GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
	StreamChat(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	StreamChatWeb(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	WarmChatCache(context.Context, *WarmChatCacheRequest) (*WarmChatCacheResponse, error)
	StreamEdit(*StreamEditRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	PreloadEdit(context.Context, *PreloadEditRequest) (*PreloadEditResponse, error)
	StreamFastEdit(*StreamFastEditRequest, grpc.ServerStreamingServer[StreamFastEditResponse]) error
	StreamGenerate(*StreamGenerateRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	StreamInlineLongCompletion(*StreamInlineLongCompletionRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	SlashEdit(*SlashEditRequest, grpc.ServerStreamingServer[SlashEditResponse]) error
	SlashEditFollowUpWithPreviousEdits(*SlashEditFollowUpWithPreviousEditsRequest, grpc.ServerStreamingServer[StreamSlashEditFollowUpWithPreviousEditsResponse]) error
	StreamAiPreviews(*StreamAiPreviewsRequest, grpc.ServerStreamingServer[StreamAiPreviewsResponse]) error
	ShouldTurnOnCppOnboarding(context.Context, *ShouldTurnOnCppOnboardingRequest) (*ShouldTurnOnCppOnboardingResponse, error)
	GetComposerAutocomplete(context.Context, *GetComposerAutocompleteRequest) (*GetComposerAutocompleteResponse, error)
	StreamReview(*ReviewRequest, grpc.ServerStreamingServer[ReviewResponse]) error
	StreamReviewChat(*ReviewChatRequest, grpc.ServerStreamingServer[ReviewChatResponse]) error
	CheckQueuePosition(context.Context, *CheckQueuePositionRequest) (*CheckQueuePositionResponse, error)
	CheckUsageBasedPrice(context.Context, *CheckUsageBasedPriceRequest) (*CheckUsageBasedPriceResponse, error)
	DoThisForMeCheck(context.Context, *DoThisForMeCheckRequest) (*DoThisForMeCheckResponse, error)
	StreamDoThisForMe(*DoThisForMeRequest, grpc.ServerStreamingServer[DoThisForMeResponseWrapped]) error
	StreamChatToolformer(*GetChatRequest, grpc.ServerStreamingServer[StreamChatToolformerResponse]) error
	StreamChatToolformerContinue(*StreamChatToolformerContinueRequest, grpc.ServerStreamingServer[StreamChatToolformerResponse]) error
	PushAiThought(context.Context, *PushAiThoughtRequest) (*PushAiThoughtResponse, error)
	CheckDoableAsTask(context.Context, *CheckDoableAsTaskRequest) (*CheckDoableAsTaskResponse, error)
	ReportGroundTruthCandidate(context.Context, *ReportGroundTruthCandidateRequest) (*ReportGroundTruthCandidateResponse, error)
	ReportCmdKFate(context.Context, *ReportCmdKFateRequest) (*ReportCmdKFateResponse, error)
	ShowWelcomeScreen(context.Context, *ShowWelcomeScreenRequest) (*ShowWelcomeScreenResponse, error)
	InterfaceAgentInit(context.Context, *InterfaceAgentInitRequest) (*InterfaceAgentInitResponse, error)
	StreamInterfaceAgentStatus(*StreamInterfaceAgentStatusRequest, grpc.ServerStreamingServer[StreamInterfaceAgentStatusResponse]) error
	TaskGetInterfaceAgentStatus(*TaskGetInterfaceAgentStatusRequest, grpc.ServerStreamingServer[TaskGetInterfaceAgentStatusResponseWrapped]) error
	UpdateVscodeProfile(context.Context, *UpdateVscodeProfileRequest) (*UpdateVscodeProfileResponse, error)
	TaskInit(context.Context, *TaskInitRequest) (*TaskInitResponse, error)
	TaskPause(context.Context, *TaskPauseRequest) (*TaskPauseResponse, error)
	TaskInfo(context.Context, *TaskInfoRequest) (*TaskInfoResponse, error)
	TaskStreamLog(*TaskStreamLogRequest, grpc.ServerStreamingServer[TaskStreamLogResponse]) error
	TaskSendMessage(context.Context, *TaskSendMessageRequest) (*TaskSendMessageResponse, error)
	TaskProvideResult(context.Context, *TaskProvideResultRequest) (*TaskProvideResultResponse, error)
	CreateExperimentalIndex(context.Context, *CreateExperimentalIndexRequest) (*CreateExperimentalIndexResponse, error)
	ListExperimentalIndexFiles(context.Context, *ListExperimentalIndexFilesRequest) (*ListExperimentalIndexFilesResponse, error)
	ListenExperimentalIndex(*ListenExperimentalIndexRequest, grpc.ServerStreamingServer[ListenExperimentalIndexResponse]) error
	RegisterFileToIndex(context.Context, *RegisterFileToIndexRequest) (*RequestReceivedResponse, error)
	SetupIndexDependencies(context.Context, *SetupIndexDependenciesRequest) (*SetupIndexDependenciesResponse, error)
	ComputeIndexTopoSort(context.Context, *ComputeIndexTopoSortRequest) (*ComputeIndexTopoSortResponse, error)
	StreamChatDeepContext(*StreamChatDeepContextRequest, grpc.ServerStreamingServer[StreamChatDeepContextResponse]) error
	ChooseCodeReferences(context.Context, *ChooseCodeReferencesRequest) (*RequestReceivedResponse, error)
	RegisterCodeReferences(context.Context, *RegisterCodeReferencesRequest) (*RegisterCodeReferencesResponse, error)
	ExtractPaths(context.Context, *ExtractPathsRequest) (*ExtractPathsResponse, error)
	SummarizeWithReferences(context.Context, *SummarizeWithReferencesRequest) (*RequestReceivedResponse, error)
	DocumentationQuery(context.Context, *DocumentationQueryRequest) (*DocumentationQueryResponse, error)
	AvailableDocs(context.Context, *AvailableDocsRequest) (*AvailableDocsResponse, error)
	ReportFeedback(context.Context, *ReportFeedbackRequest) (*ReportFeedbackResponse, error)
	ReportBug(context.Context, *ReportBugRequest) (*ReportBugResponse, error)
	StreamChatContext(*StreamChatContextRequest, grpc.ServerStreamingServer[StreamChatContextResponse]) error
	GenerateTldr(context.Context, *GenerateTldrRequest) (*GenerateTldrResponse, error)
	TaskStreamChatContext(*TaskStreamChatContextRequest, grpc.ServerStreamingServer[TaskStreamChatContextResponseWrapped]) error
	RerankResults(context.Context, *RerankerRequest) (*RerankerResponse, error)
	ModelQuery(context.Context, *ModelQueryRequest) (*ModelQueryResponse, error)
	ModelQueryV2(*ModelQueryRequest, grpc.ServerStreamingServer[ModelQueryResponseV2]) error
	IntentPrediction(context.Context, *IntentPredictionRequest) (*IntentPredictionResponse, error)
	GetChatSuggestions(context.Context, *GetChatSuggestionsRequest) (*GetChatSuggestionsResponse, error)
	GetUserInstructions(context.Context, *GetUserInstructionsRequest) (*GetUserInstructionsResponse, error)
	StreamCursorTutor(*StreamCursorTutorRequest, grpc.ServerStreamingServer[StreamCursorTutorResponse]) error
	CheckFeatureStatus(context.Context, *CheckFeatureStatusRequest) (*CheckFeatureStatusResponse, error)
	CheckFeaturesStatus(context.Context, *CheckFeaturesStatusRequest) (*CheckFeaturesStatusResponse, error)
	CheckFeatureStatusUnauthenticated(context.Context, *CheckFeatureStatusRequest) (*CheckFeatureStatusResponse, error)
	GetEffectiveTokenLimit(context.Context, *GetEffectiveTokenLimitRequest) (*GetEffectiveTokenLimitResponse, error)
	GetContextScores(context.Context, *ContextScoresRequest) (*ContextScoresResponse, error)
	StreamCpp(*StreamCppRequest, grpc.ServerStreamingServer[StreamCppResponse]) error
	CppConfig(context.Context, *CppConfigRequest) (*CppConfigResponse, error)
	CppEditHistoryStatus(context.Context, *CppEditHistoryStatusRequest) (*CppEditHistoryStatusResponse, error)
	CppAppend(context.Context, *CppAppendRequest) (*CppAppendResponse, error)
	RefreshTabContext(context.Context, *RefreshTabContextRequest) (*RefreshTabContextResponse, error)
	CheckNumberConfig(context.Context, *CheckNumberConfigRequest) (*CheckNumberConfigResponse, error)
	CheckNumberConfigUnauthenticated(context.Context, *CheckNumberConfigRequest) (*CheckNumberConfigResponse, error)
	CheckNumberConfigs(context.Context, *CheckNumberConfigsRequest) (*CheckNumberConfigsResponse, error)
	StreamTerminalAutocomplete(*StreamTerminalAutocompleteRequest, grpc.ServerStreamingServer[StreamTerminalAutocompleteResponse]) error
	StreamPseudocodeGenerator(*StreamPseudocodeGeneratorRequest, grpc.ServerStreamingServer[StreamPseudocodeGeneratorResponse]) error
	StreamPseudocodeMapper(*StreamPseudocodeMapperRequest, grpc.ServerStreamingServer[StreamPseudocodeMapperResponse]) error
	AcknowledgeGracePeriodDisclaimer(context.Context, *AcknowledgeGracePeriodDisclaimerRequest) (*AcknowledgeGracePeriodDisclaimerResponse, error)
	StreamAiLintBug(*StreamAiLintBugRequest, grpc.ServerStreamingServer[StreamAiLintBugResponse]) error
	StreamAiCursorHelp(*StreamAiCursorHelpRequest, grpc.ServerStreamingServer[StreamAiCursorHelpResponse]) error
	LogUserLintReply(context.Context, *LogUserLintReplyRequest) (*LogUserLintReplyResponse, error)
	LogLinterExplicitUserFeedback(context.Context, *LogLinterExplicitUserFeedbackRequest) (*LogLinterExplicitUserFeedbackResponse, error)
	StreamFixMarkers(*FixMarkersRequest, grpc.ServerStreamingServer[FixMarkersResponse]) error
	ReportInlineAction(context.Context, *ReportInlineActionRequest) (*ReportInlineActionResponse, error)
	StreamPriomptPrompt(*StreamPriomptPromptRequest, grpc.ServerStreamingServer[StreamPriomptPromptResponse]) error
	StreamLint(*StreamLintRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	StreamNewLintRule(*StreamNewRuleRequest, grpc.ServerStreamingServer[StreamChatResponse]) error
	AiProject(*AiProjectRequest, grpc.ServerStreamingServer[AiProjectResponse]) error
	ToCamelCase(context.Context, *ToCamelCaseRequest) (*ToCamelCaseResponse, error)
	ReportGenerationFeedback(context.Context, *ReportGenerationFeedbackRequest) (*ReportGenerationFeedbackResponse, error)
	GetThoughtAnnotation(context.Context, *GetThoughtAnnotationRequest) (*GetThoughtAnnotationResponse, error)
	StreamWebCmdKV1(*StreamWebCmdKV1Request, grpc.ServerStreamingServer[StreamWebCmdKV1Response]) error
	StreamNextCursorPrediction(*StreamNextCursorPredictionRequest, grpc.ServerStreamingServer[StreamNextCursorPredictionResponse]) error
	IsCursorPredictionEnabled(context.Context, *IsCursorPredictionEnabledRequest) (*IsCursorPredictionEnabledResponse, error)
	GetCppEditClassification(context.Context, *GetCppEditClassificationRequest) (*GetCppEditClassificationResponse, error)
	GetTerminalCompletion(context.Context, *GetTerminalCompletionRequest) (*GetTerminalCompletionResponse, error)
	TakeNotesOnCommitDiff(context.Context, *TakeNotesOnCommitDiffRequest) (*TakeNotesOnCommitDiffResponse, error)
	BulkEmbed(context.Context, *BulkEmbedRequest) (*BulkEmbedResponse, error)
	BackgroundCmdKEval(*BackgroundCmdKEvalRequest, grpc.ServerStreamingServer[BackgroundCmdKEvalResponse]) error
	BackgroundCmdK(*BackgroundCmdKRequest, grpc.ServerStreamingServer[BackgroundCmdKResponse]) error
	StreamCursorMotion(*StreamCursorMotionRequest, grpc.ServerStreamingServer[StreamCursorMotionResponse]) error
	CalculateAutoSelection(context.Context, *CalculateAutoSelectionRequest) (*CalculateAutoSelectionResponse, error)
	GetAtSymbolSuggestions(context.Context, *GetAtSymbolSuggestionsRequest) (*GetAtSymbolSuggestionsResponse, error)
	GetCodebaseQuestions(context.Context, *GetChatRequest) (*GetCodebaseQuestionsResponse, error)
	CppEditHistoryAppend(context.Context, *EditHistoryAppendChangesRequest) (*EditHistoryAppendChangesResponse, error)
	DevOnlyGetPastRequestIds(context.Context, *DevOnlyGetPastRequestIdsRequest) (*DevOnlyGetPastRequestIdsResponse, error)
	GetFilesForComposer(context.Context, *GetFilesForComposerRequest) (*GetFilesForComposerResponse, error)
	TryParseTypeScriptTreeSitter(context.Context, *TryParseTypeScriptTreeSitterRequest) (*TryParseTypeScriptTreeSitterResponse, error)
	NameTab(context.Context, *NameTabRequest) (*NameTabResponse, error)
	IsTerminalFinishedV2(context.Context, *IsTerminalFinishedRequest) (*IsTerminalFinishedResponseV2, error)
	TestModelStatus(context.Context, *TestModelStatusRequest) (*TestModelStatusResponse, error)
	FindBugs(context.Context, *FindBugsRequest) (*FindBugsResponse, error)
	ContextReranking(context.Context, *ContextRerankingRequest) (*ContextRerankingResponse, error)
	AutoContext(context.Context, *AutoContextRequest) (*AutoContextResponse, error)
	WriteGitCommitMessage(context.Context, *WriteGitCommitMessageRequest) (*WriteGitCommitMessageResponse, error)
	WriteGitBranchName(context.Context, *WriteGitBranchNameRequest) (*WriteGitBranchNameResponse, error)
	StreamBugBot(*StreamBugBotRequest, grpc.ServerStreamingServer[StreamBugBotResponse]) error
	StreamBugBotAgentic(grpc.BidiStreamingServer[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]) error
	StreamBugBotAgenticSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamBugBotAgenticServerMessage]) error
	StreamBugBotAgenticPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	StreamUiBestOfNJudge(grpc.BidiStreamingServer[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]) error
	StreamUiBestOfNJudgeSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUiBestOfNJudgeServerMessage]) error
	StreamUiBestOfNJudgePoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	CheckBugBotPrice(context.Context, *CheckBugBotPriceRequest) (*CheckBugBotPriceResponse, error)
	CheckBugBotTelemetryHealthy(context.Context, *CheckBugBotTelemetryHealthyRequest) (*CheckBugBotTelemetryHealthyResponse, error)
	RecordIdeBugReaction(context.Context, *RecordIdeBugReactionRequest) (*RecordIdeBugReactionResponse, error)
	GetSuggestedBugBotIterations(context.Context, *GetSuggestedBugBotIterationsRequest) (*GetSuggestedBugBotIterationsResponse, error)
	GetEditorBugbotAutoRunStatus(context.Context, *GetEditorBugbotAutoRunStatusRequest) (*GetEditorBugbotAutoRunStatusResponse, error)
	TestBidi(grpc.BidiStreamingServer[TestBidiRequest, TestBidiResponse]) error
	StreamDiffReview(*GetDiffReviewRequest, grpc.ServerStreamingServer[StreamDiffReviewResponse]) error
	StreamDiffReviewByFile(*GetDiffReviewRequest, grpc.ServerStreamingServer[StreamDiffReviewByFileResponse]) error
	GetModelLabels(context.Context, *GetModelLabelsRequest) (*GetModelLabelsResponse, error)
	GetLastDefaultModelNudge(context.Context, *GetLastDefaultModelNudgeRequest) (*GetLastDefaultModelNudgeResponse, error)
	GetDefaultModelNudgeData(context.Context, *GetDefaultModelNudgeDataRequest) (*GetDefaultModelNudgeDataResponse, error)
	GetDefaultModel(context.Context, *GetDefaultModelRequest) (*GetDefaultModelResponse, error)
	ReportCommitAiAnalytics(context.Context, *ReportCommitAiAnalyticsRequest) (*ReportCommitAiAnalyticsResponse, error)
	TestBedrockCredentials(context.Context, *TestBedrockCredentialsRequest) (*TestBedrockCredentialsResponse, error)
	ReportAiCodeChangeMetrics(context.Context, *ReportAiCodeChangeMetricsRequest) (*ReportAiCodeChangeMetricsResponse, error)
	ReportProcessMetrics(context.Context, *ReportProcessMetricsRequest) (*ReportProcessMetricsResponse, error)
	ReportProcessMetricsV2(context.Context, *ReportProcessMetricsV2Request) (*ReportProcessMetricsV2Response, error)
	ReportClientNumericMetrics(context.Context, *ReportClientNumericMetricsRequest) (*ReportClientNumericMetricsResponse, error)
	PotentiallyGenerateMemory(context.Context, *PotentiallyGenerateMemoryRequest) (*PotentiallyGenerateMemoryResponse, error)
	KnowledgeBaseAdd(context.Context, *KnowledgeBaseAddRequest) (*KnowledgeBaseAddResponse, error)
	KnowledgeBaseList(context.Context, *KnowledgeBaseListRequest) (*KnowledgeBaseListResponse, error)
	KnowledgeBaseRemove(context.Context, *KnowledgeBaseRemoveRequest) (*KnowledgeBaseRemoveResponse, error)
	KnowledgeBaseUpdate(context.Context, *KnowledgeBaseUpdateRequest) (*KnowledgeBaseUpdateResponse, error)
	FetchRelevantKnowledgeForConversation(context.Context, *FetchRelevantKnowledgeForConversationRequest) (*FetchRelevantKnowledgeForConversationResponse, error)
	InferBackgroundComposerScripts(context.Context, *InferBackgroundComposerScriptsRequest) (*InferBackgroundComposerScriptsResponse, error)
	GetBackgroundComposerFeedbackLink(context.Context, *GetBackgroundComposerFeedbackLinkRequest) (*GetBackgroundComposerFeedbackLinkResponse, error)
	GetUsableModels(context.Context, *GetUsableModelsRequest) (*GetUsableModelsResponse, error)
	GetDefaultModelForCli(context.Context, *GetDefaultModelForCliRequest) (*GetDefaultModelForCliResponse, error)
	StreamComposerEnhancer(grpc.BidiStreamingServer[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]) error
	StreamComposerEnhancerSSE(*BidiRequestId, grpc.ServerStreamingServer[ComposerEnhancerServerMessage]) error
	StreamComposerEnhancerPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	StreamStt(grpc.BidiStreamingServer[SttClientMessage, SttServerMessage]) error
	StreamSttSSE(*BidiRequestId, grpc.ServerStreamingServer[SttServerMessage]) error
	StreamSttPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	NameAgent(context.Context, *NameAgentRequest) (*NameAgentResponse, error)
	EvaluatePromptHook(context.Context, *EvaluatePromptHookRequest) (*EvaluatePromptHookResponse, error)
	mustEmbedUnimplementedAiServiceServer()
}

// UnimplementedAiServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAiServiceServer struct{}

func (UnimplementedAiServiceServer) ServerTime(context.Context, *ServerTimeRequest) (*ServerTimeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ServerTime not implemented")
}
func (UnimplementedAiServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedAiServiceServer) PrivacyCheck(context.Context, *PrivacyCheckRequest) (*PrivacyCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PrivacyCheck not implemented")
}
func (UnimplementedAiServiceServer) TimeLeftHealthCheck(context.Context, *HealthCheckRequest) (*TimeLeftHealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TimeLeftHealthCheck not implemented")
}
func (UnimplementedAiServiceServer) ThrowErrorCheck(context.Context, *ThrowErrorCheckRequest) (*ThrowErrorCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ThrowErrorCheck not implemented")
}
func (UnimplementedAiServiceServer) AvailableModels(context.Context, *AvailableModelsRequest) (*AvailableModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AvailableModels not implemented")
}
func (UnimplementedAiServiceServer) StreamChatTryReallyHard(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatTryReallyHard not implemented")
}
func (UnimplementedAiServiceServer) RerankDocuments(context.Context, *RerankDocumentsRequest) (*RerankDocumentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RerankDocuments not implemented")
}
func (UnimplementedAiServiceServer) StreamComposer(*GetComposerChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamComposer not implemented")
}
func (UnimplementedAiServiceServer) StreamComposerContext(*StreamChatContextRequest, grpc.ServerStreamingServer[StreamChatContextResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamComposerContext not implemented")
}
func (UnimplementedAiServiceServer) WarmComposerCache(context.Context, *GetComposerChatRequest) (*WarmComposerCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmComposerCache not implemented")
}
func (UnimplementedAiServiceServer) KeepComposerCacheWarm(context.Context, *KeepComposerCacheWarmRequest) (*KeepComposerCacheWarmResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KeepComposerCacheWarm not implemented")
}
func (UnimplementedAiServiceServer) CountTokens(context.Context, *CountTokensRequest) (*CountTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CountTokens not implemented")
}
func (UnimplementedAiServiceServer) StreamPotentialLocs(*PotentialLocsRequest, grpc.ServerStreamingServer[PotentialLocsResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPotentialLocs not implemented")
}
func (UnimplementedAiServiceServer) StreamPotentialLocsUnderneath(*PotentialLocsUnderneathRequest, grpc.ServerStreamingServer[PotentialLocsUnderneathResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPotentialLocsUnderneath not implemented")
}
func (UnimplementedAiServiceServer) StreamPotentialLocsInitialQueries(*PotentialLocsInitialQueriesRequest, grpc.ServerStreamingServer[PotentialLocsInitialQueriesResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPotentialLocsInitialQueries not implemented")
}
func (UnimplementedAiServiceServer) GetChatTitle(context.Context, *GetChatTitleRequest) (*GetChatTitleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChatTitle not implemented")
}
func (UnimplementedAiServiceServer) GetCompletion(context.Context, *GetCompletionRequest) (*GetCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCompletion not implemented")
}
func (UnimplementedAiServiceServer) IsolatedTreesitter(context.Context, *IsolatedTreesitterRequest) (*IsolatedTreesitterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsolatedTreesitter not implemented")
}
func (UnimplementedAiServiceServer) GetSimplePrompt(context.Context, *GetSimplePromptRequest) (*GetSimplePromptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSimplePrompt not implemented")
}
func (UnimplementedAiServiceServer) GetPassthroughPrompt(context.Context, *GetPassthroughPromptRequest) (*GetPassthroughPromptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPassthroughPrompt not implemented")
}
func (UnimplementedAiServiceServer) CheckLongFilesFit(context.Context, *GetChatRequest) (*CheckLongFilesFitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckLongFilesFit not implemented")
}
func (UnimplementedAiServiceServer) GetEvaluationPrompt(context.Context, *GetEvaluationPromptRequest) (*GetEvaluationPromptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEvaluationPrompt not implemented")
}
func (UnimplementedAiServiceServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedAiServiceServer) StreamChat(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChat not implemented")
}
func (UnimplementedAiServiceServer) StreamChatWeb(*GetChatRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatWeb not implemented")
}
func (UnimplementedAiServiceServer) WarmChatCache(context.Context, *WarmChatCacheRequest) (*WarmChatCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmChatCache not implemented")
}
func (UnimplementedAiServiceServer) StreamEdit(*StreamEditRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamEdit not implemented")
}
func (UnimplementedAiServiceServer) PreloadEdit(context.Context, *PreloadEditRequest) (*PreloadEditResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PreloadEdit not implemented")
}
func (UnimplementedAiServiceServer) StreamFastEdit(*StreamFastEditRequest, grpc.ServerStreamingServer[StreamFastEditResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamFastEdit not implemented")
}
func (UnimplementedAiServiceServer) StreamGenerate(*StreamGenerateRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamGenerate not implemented")
}
func (UnimplementedAiServiceServer) StreamInlineLongCompletion(*StreamInlineLongCompletionRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamInlineLongCompletion not implemented")
}
func (UnimplementedAiServiceServer) SlashEdit(*SlashEditRequest, grpc.ServerStreamingServer[SlashEditResponse]) error {
	return status.Error(codes.Unimplemented, "method SlashEdit not implemented")
}
func (UnimplementedAiServiceServer) SlashEditFollowUpWithPreviousEdits(*SlashEditFollowUpWithPreviousEditsRequest, grpc.ServerStreamingServer[StreamSlashEditFollowUpWithPreviousEditsResponse]) error {
	return status.Error(codes.Unimplemented, "method SlashEditFollowUpWithPreviousEdits not implemented")
}
func (UnimplementedAiServiceServer) StreamAiPreviews(*StreamAiPreviewsRequest, grpc.ServerStreamingServer[StreamAiPreviewsResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamAiPreviews not implemented")
}
func (UnimplementedAiServiceServer) ShouldTurnOnCppOnboarding(context.Context, *ShouldTurnOnCppOnboardingRequest) (*ShouldTurnOnCppOnboardingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShouldTurnOnCppOnboarding not implemented")
}
func (UnimplementedAiServiceServer) GetComposerAutocomplete(context.Context, *GetComposerAutocompleteRequest) (*GetComposerAutocompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComposerAutocomplete not implemented")
}
func (UnimplementedAiServiceServer) StreamReview(*ReviewRequest, grpc.ServerStreamingServer[ReviewResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamReview not implemented")
}
func (UnimplementedAiServiceServer) StreamReviewChat(*ReviewChatRequest, grpc.ServerStreamingServer[ReviewChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamReviewChat not implemented")
}
func (UnimplementedAiServiceServer) CheckQueuePosition(context.Context, *CheckQueuePositionRequest) (*CheckQueuePositionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckQueuePosition not implemented")
}
func (UnimplementedAiServiceServer) CheckUsageBasedPrice(context.Context, *CheckUsageBasedPriceRequest) (*CheckUsageBasedPriceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckUsageBasedPrice not implemented")
}
func (UnimplementedAiServiceServer) DoThisForMeCheck(context.Context, *DoThisForMeCheckRequest) (*DoThisForMeCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DoThisForMeCheck not implemented")
}
func (UnimplementedAiServiceServer) StreamDoThisForMe(*DoThisForMeRequest, grpc.ServerStreamingServer[DoThisForMeResponseWrapped]) error {
	return status.Error(codes.Unimplemented, "method StreamDoThisForMe not implemented")
}
func (UnimplementedAiServiceServer) StreamChatToolformer(*GetChatRequest, grpc.ServerStreamingServer[StreamChatToolformerResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatToolformer not implemented")
}
func (UnimplementedAiServiceServer) StreamChatToolformerContinue(*StreamChatToolformerContinueRequest, grpc.ServerStreamingServer[StreamChatToolformerResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatToolformerContinue not implemented")
}
func (UnimplementedAiServiceServer) PushAiThought(context.Context, *PushAiThoughtRequest) (*PushAiThoughtResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PushAiThought not implemented")
}
func (UnimplementedAiServiceServer) CheckDoableAsTask(context.Context, *CheckDoableAsTaskRequest) (*CheckDoableAsTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckDoableAsTask not implemented")
}
func (UnimplementedAiServiceServer) ReportGroundTruthCandidate(context.Context, *ReportGroundTruthCandidateRequest) (*ReportGroundTruthCandidateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportGroundTruthCandidate not implemented")
}
func (UnimplementedAiServiceServer) ReportCmdKFate(context.Context, *ReportCmdKFateRequest) (*ReportCmdKFateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportCmdKFate not implemented")
}
func (UnimplementedAiServiceServer) ShowWelcomeScreen(context.Context, *ShowWelcomeScreenRequest) (*ShowWelcomeScreenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShowWelcomeScreen not implemented")
}
func (UnimplementedAiServiceServer) InterfaceAgentInit(context.Context, *InterfaceAgentInitRequest) (*InterfaceAgentInitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InterfaceAgentInit not implemented")
}
func (UnimplementedAiServiceServer) StreamInterfaceAgentStatus(*StreamInterfaceAgentStatusRequest, grpc.ServerStreamingServer[StreamInterfaceAgentStatusResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamInterfaceAgentStatus not implemented")
}
func (UnimplementedAiServiceServer) TaskGetInterfaceAgentStatus(*TaskGetInterfaceAgentStatusRequest, grpc.ServerStreamingServer[TaskGetInterfaceAgentStatusResponseWrapped]) error {
	return status.Error(codes.Unimplemented, "method TaskGetInterfaceAgentStatus not implemented")
}
func (UnimplementedAiServiceServer) UpdateVscodeProfile(context.Context, *UpdateVscodeProfileRequest) (*UpdateVscodeProfileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateVscodeProfile not implemented")
}
func (UnimplementedAiServiceServer) TaskInit(context.Context, *TaskInitRequest) (*TaskInitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TaskInit not implemented")
}
func (UnimplementedAiServiceServer) TaskPause(context.Context, *TaskPauseRequest) (*TaskPauseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TaskPause not implemented")
}
func (UnimplementedAiServiceServer) TaskInfo(context.Context, *TaskInfoRequest) (*TaskInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TaskInfo not implemented")
}
func (UnimplementedAiServiceServer) TaskStreamLog(*TaskStreamLogRequest, grpc.ServerStreamingServer[TaskStreamLogResponse]) error {
	return status.Error(codes.Unimplemented, "method TaskStreamLog not implemented")
}
func (UnimplementedAiServiceServer) TaskSendMessage(context.Context, *TaskSendMessageRequest) (*TaskSendMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TaskSendMessage not implemented")
}
func (UnimplementedAiServiceServer) TaskProvideResult(context.Context, *TaskProvideResultRequest) (*TaskProvideResultResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TaskProvideResult not implemented")
}
func (UnimplementedAiServiceServer) CreateExperimentalIndex(context.Context, *CreateExperimentalIndexRequest) (*CreateExperimentalIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateExperimentalIndex not implemented")
}
func (UnimplementedAiServiceServer) ListExperimentalIndexFiles(context.Context, *ListExperimentalIndexFilesRequest) (*ListExperimentalIndexFilesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListExperimentalIndexFiles not implemented")
}
func (UnimplementedAiServiceServer) ListenExperimentalIndex(*ListenExperimentalIndexRequest, grpc.ServerStreamingServer[ListenExperimentalIndexResponse]) error {
	return status.Error(codes.Unimplemented, "method ListenExperimentalIndex not implemented")
}
func (UnimplementedAiServiceServer) RegisterFileToIndex(context.Context, *RegisterFileToIndexRequest) (*RequestReceivedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterFileToIndex not implemented")
}
func (UnimplementedAiServiceServer) SetupIndexDependencies(context.Context, *SetupIndexDependenciesRequest) (*SetupIndexDependenciesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetupIndexDependencies not implemented")
}
func (UnimplementedAiServiceServer) ComputeIndexTopoSort(context.Context, *ComputeIndexTopoSortRequest) (*ComputeIndexTopoSortResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ComputeIndexTopoSort not implemented")
}
func (UnimplementedAiServiceServer) StreamChatDeepContext(*StreamChatDeepContextRequest, grpc.ServerStreamingServer[StreamChatDeepContextResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatDeepContext not implemented")
}
func (UnimplementedAiServiceServer) ChooseCodeReferences(context.Context, *ChooseCodeReferencesRequest) (*RequestReceivedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChooseCodeReferences not implemented")
}
func (UnimplementedAiServiceServer) RegisterCodeReferences(context.Context, *RegisterCodeReferencesRequest) (*RegisterCodeReferencesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterCodeReferences not implemented")
}
func (UnimplementedAiServiceServer) ExtractPaths(context.Context, *ExtractPathsRequest) (*ExtractPathsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExtractPaths not implemented")
}
func (UnimplementedAiServiceServer) SummarizeWithReferences(context.Context, *SummarizeWithReferencesRequest) (*RequestReceivedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SummarizeWithReferences not implemented")
}
func (UnimplementedAiServiceServer) DocumentationQuery(context.Context, *DocumentationQueryRequest) (*DocumentationQueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DocumentationQuery not implemented")
}
func (UnimplementedAiServiceServer) AvailableDocs(context.Context, *AvailableDocsRequest) (*AvailableDocsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AvailableDocs not implemented")
}
func (UnimplementedAiServiceServer) ReportFeedback(context.Context, *ReportFeedbackRequest) (*ReportFeedbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportFeedback not implemented")
}
func (UnimplementedAiServiceServer) ReportBug(context.Context, *ReportBugRequest) (*ReportBugResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportBug not implemented")
}
func (UnimplementedAiServiceServer) StreamChatContext(*StreamChatContextRequest, grpc.ServerStreamingServer[StreamChatContextResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamChatContext not implemented")
}
func (UnimplementedAiServiceServer) GenerateTldr(context.Context, *GenerateTldrRequest) (*GenerateTldrResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateTldr not implemented")
}
func (UnimplementedAiServiceServer) TaskStreamChatContext(*TaskStreamChatContextRequest, grpc.ServerStreamingServer[TaskStreamChatContextResponseWrapped]) error {
	return status.Error(codes.Unimplemented, "method TaskStreamChatContext not implemented")
}
func (UnimplementedAiServiceServer) RerankResults(context.Context, *RerankerRequest) (*RerankerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RerankResults not implemented")
}
func (UnimplementedAiServiceServer) ModelQuery(context.Context, *ModelQueryRequest) (*ModelQueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ModelQuery not implemented")
}
func (UnimplementedAiServiceServer) ModelQueryV2(*ModelQueryRequest, grpc.ServerStreamingServer[ModelQueryResponseV2]) error {
	return status.Error(codes.Unimplemented, "method ModelQueryV2 not implemented")
}
func (UnimplementedAiServiceServer) IntentPrediction(context.Context, *IntentPredictionRequest) (*IntentPredictionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IntentPrediction not implemented")
}
func (UnimplementedAiServiceServer) GetChatSuggestions(context.Context, *GetChatSuggestionsRequest) (*GetChatSuggestionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChatSuggestions not implemented")
}
func (UnimplementedAiServiceServer) GetUserInstructions(context.Context, *GetUserInstructionsRequest) (*GetUserInstructionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserInstructions not implemented")
}
func (UnimplementedAiServiceServer) StreamCursorTutor(*StreamCursorTutorRequest, grpc.ServerStreamingServer[StreamCursorTutorResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamCursorTutor not implemented")
}
func (UnimplementedAiServiceServer) CheckFeatureStatus(context.Context, *CheckFeatureStatusRequest) (*CheckFeatureStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckFeatureStatus not implemented")
}
func (UnimplementedAiServiceServer) CheckFeaturesStatus(context.Context, *CheckFeaturesStatusRequest) (*CheckFeaturesStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckFeaturesStatus not implemented")
}
func (UnimplementedAiServiceServer) CheckFeatureStatusUnauthenticated(context.Context, *CheckFeatureStatusRequest) (*CheckFeatureStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckFeatureStatusUnauthenticated not implemented")
}
func (UnimplementedAiServiceServer) GetEffectiveTokenLimit(context.Context, *GetEffectiveTokenLimitRequest) (*GetEffectiveTokenLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEffectiveTokenLimit not implemented")
}
func (UnimplementedAiServiceServer) GetContextScores(context.Context, *ContextScoresRequest) (*ContextScoresResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetContextScores not implemented")
}
func (UnimplementedAiServiceServer) StreamCpp(*StreamCppRequest, grpc.ServerStreamingServer[StreamCppResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamCpp not implemented")
}
func (UnimplementedAiServiceServer) CppConfig(context.Context, *CppConfigRequest) (*CppConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CppConfig not implemented")
}
func (UnimplementedAiServiceServer) CppEditHistoryStatus(context.Context, *CppEditHistoryStatusRequest) (*CppEditHistoryStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CppEditHistoryStatus not implemented")
}
func (UnimplementedAiServiceServer) CppAppend(context.Context, *CppAppendRequest) (*CppAppendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CppAppend not implemented")
}
func (UnimplementedAiServiceServer) RefreshTabContext(context.Context, *RefreshTabContextRequest) (*RefreshTabContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshTabContext not implemented")
}
func (UnimplementedAiServiceServer) CheckNumberConfig(context.Context, *CheckNumberConfigRequest) (*CheckNumberConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckNumberConfig not implemented")
}
func (UnimplementedAiServiceServer) CheckNumberConfigUnauthenticated(context.Context, *CheckNumberConfigRequest) (*CheckNumberConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckNumberConfigUnauthenticated not implemented")
}
func (UnimplementedAiServiceServer) CheckNumberConfigs(context.Context, *CheckNumberConfigsRequest) (*CheckNumberConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckNumberConfigs not implemented")
}
func (UnimplementedAiServiceServer) StreamTerminalAutocomplete(*StreamTerminalAutocompleteRequest, grpc.ServerStreamingServer[StreamTerminalAutocompleteResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamTerminalAutocomplete not implemented")
}
func (UnimplementedAiServiceServer) StreamPseudocodeGenerator(*StreamPseudocodeGeneratorRequest, grpc.ServerStreamingServer[StreamPseudocodeGeneratorResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPseudocodeGenerator not implemented")
}
func (UnimplementedAiServiceServer) StreamPseudocodeMapper(*StreamPseudocodeMapperRequest, grpc.ServerStreamingServer[StreamPseudocodeMapperResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPseudocodeMapper not implemented")
}
func (UnimplementedAiServiceServer) AcknowledgeGracePeriodDisclaimer(context.Context, *AcknowledgeGracePeriodDisclaimerRequest) (*AcknowledgeGracePeriodDisclaimerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcknowledgeGracePeriodDisclaimer not implemented")
}
func (UnimplementedAiServiceServer) StreamAiLintBug(*StreamAiLintBugRequest, grpc.ServerStreamingServer[StreamAiLintBugResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamAiLintBug not implemented")
}
func (UnimplementedAiServiceServer) StreamAiCursorHelp(*StreamAiCursorHelpRequest, grpc.ServerStreamingServer[StreamAiCursorHelpResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamAiCursorHelp not implemented")
}
func (UnimplementedAiServiceServer) LogUserLintReply(context.Context, *LogUserLintReplyRequest) (*LogUserLintReplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogUserLintReply not implemented")
}
func (UnimplementedAiServiceServer) LogLinterExplicitUserFeedback(context.Context, *LogLinterExplicitUserFeedbackRequest) (*LogLinterExplicitUserFeedbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogLinterExplicitUserFeedback not implemented")
}
func (UnimplementedAiServiceServer) StreamFixMarkers(*FixMarkersRequest, grpc.ServerStreamingServer[FixMarkersResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamFixMarkers not implemented")
}
func (UnimplementedAiServiceServer) ReportInlineAction(context.Context, *ReportInlineActionRequest) (*ReportInlineActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportInlineAction not implemented")
}
func (UnimplementedAiServiceServer) StreamPriomptPrompt(*StreamPriomptPromptRequest, grpc.ServerStreamingServer[StreamPriomptPromptResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamPriomptPrompt not implemented")
}
func (UnimplementedAiServiceServer) StreamLint(*StreamLintRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamLint not implemented")
}
func (UnimplementedAiServiceServer) StreamNewLintRule(*StreamNewRuleRequest, grpc.ServerStreamingServer[StreamChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamNewLintRule not implemented")
}
func (UnimplementedAiServiceServer) AiProject(*AiProjectRequest, grpc.ServerStreamingServer[AiProjectResponse]) error {
	return status.Error(codes.Unimplemented, "method AiProject not implemented")
}
func (UnimplementedAiServiceServer) ToCamelCase(context.Context, *ToCamelCaseRequest) (*ToCamelCaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ToCamelCase not implemented")
}
func (UnimplementedAiServiceServer) ReportGenerationFeedback(context.Context, *ReportGenerationFeedbackRequest) (*ReportGenerationFeedbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportGenerationFeedback not implemented")
}
func (UnimplementedAiServiceServer) GetThoughtAnnotation(context.Context, *GetThoughtAnnotationRequest) (*GetThoughtAnnotationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetThoughtAnnotation not implemented")
}
func (UnimplementedAiServiceServer) StreamWebCmdKV1(*StreamWebCmdKV1Request, grpc.ServerStreamingServer[StreamWebCmdKV1Response]) error {
	return status.Error(codes.Unimplemented, "method StreamWebCmdKV1 not implemented")
}
func (UnimplementedAiServiceServer) StreamNextCursorPrediction(*StreamNextCursorPredictionRequest, grpc.ServerStreamingServer[StreamNextCursorPredictionResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamNextCursorPrediction not implemented")
}
func (UnimplementedAiServiceServer) IsCursorPredictionEnabled(context.Context, *IsCursorPredictionEnabledRequest) (*IsCursorPredictionEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsCursorPredictionEnabled not implemented")
}
func (UnimplementedAiServiceServer) GetCppEditClassification(context.Context, *GetCppEditClassificationRequest) (*GetCppEditClassificationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCppEditClassification not implemented")
}
func (UnimplementedAiServiceServer) GetTerminalCompletion(context.Context, *GetTerminalCompletionRequest) (*GetTerminalCompletionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTerminalCompletion not implemented")
}
func (UnimplementedAiServiceServer) TakeNotesOnCommitDiff(context.Context, *TakeNotesOnCommitDiffRequest) (*TakeNotesOnCommitDiffResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TakeNotesOnCommitDiff not implemented")
}
func (UnimplementedAiServiceServer) BulkEmbed(context.Context, *BulkEmbedRequest) (*BulkEmbedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BulkEmbed not implemented")
}
func (UnimplementedAiServiceServer) BackgroundCmdKEval(*BackgroundCmdKEvalRequest, grpc.ServerStreamingServer[BackgroundCmdKEvalResponse]) error {
	return status.Error(codes.Unimplemented, "method BackgroundCmdKEval not implemented")
}
func (UnimplementedAiServiceServer) BackgroundCmdK(*BackgroundCmdKRequest, grpc.ServerStreamingServer[BackgroundCmdKResponse]) error {
	return status.Error(codes.Unimplemented, "method BackgroundCmdK not implemented")
}
func (UnimplementedAiServiceServer) StreamCursorMotion(*StreamCursorMotionRequest, grpc.ServerStreamingServer[StreamCursorMotionResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamCursorMotion not implemented")
}
func (UnimplementedAiServiceServer) CalculateAutoSelection(context.Context, *CalculateAutoSelectionRequest) (*CalculateAutoSelectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CalculateAutoSelection not implemented")
}
func (UnimplementedAiServiceServer) GetAtSymbolSuggestions(context.Context, *GetAtSymbolSuggestionsRequest) (*GetAtSymbolSuggestionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAtSymbolSuggestions not implemented")
}
func (UnimplementedAiServiceServer) GetCodebaseQuestions(context.Context, *GetChatRequest) (*GetCodebaseQuestionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCodebaseQuestions not implemented")
}
func (UnimplementedAiServiceServer) CppEditHistoryAppend(context.Context, *EditHistoryAppendChangesRequest) (*EditHistoryAppendChangesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CppEditHistoryAppend not implemented")
}
func (UnimplementedAiServiceServer) DevOnlyGetPastRequestIds(context.Context, *DevOnlyGetPastRequestIdsRequest) (*DevOnlyGetPastRequestIdsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DevOnlyGetPastRequestIds not implemented")
}
func (UnimplementedAiServiceServer) GetFilesForComposer(context.Context, *GetFilesForComposerRequest) (*GetFilesForComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFilesForComposer not implemented")
}
func (UnimplementedAiServiceServer) TryParseTypeScriptTreeSitter(context.Context, *TryParseTypeScriptTreeSitterRequest) (*TryParseTypeScriptTreeSitterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TryParseTypeScriptTreeSitter not implemented")
}
func (UnimplementedAiServiceServer) NameTab(context.Context, *NameTabRequest) (*NameTabResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NameTab not implemented")
}
func (UnimplementedAiServiceServer) IsTerminalFinishedV2(context.Context, *IsTerminalFinishedRequest) (*IsTerminalFinishedResponseV2, error) {
	return nil, status.Error(codes.Unimplemented, "method IsTerminalFinishedV2 not implemented")
}
func (UnimplementedAiServiceServer) TestModelStatus(context.Context, *TestModelStatusRequest) (*TestModelStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestModelStatus not implemented")
}
func (UnimplementedAiServiceServer) FindBugs(context.Context, *FindBugsRequest) (*FindBugsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FindBugs not implemented")
}
func (UnimplementedAiServiceServer) ContextReranking(context.Context, *ContextRerankingRequest) (*ContextRerankingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ContextReranking not implemented")
}
func (UnimplementedAiServiceServer) AutoContext(context.Context, *AutoContextRequest) (*AutoContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AutoContext not implemented")
}
func (UnimplementedAiServiceServer) WriteGitCommitMessage(context.Context, *WriteGitCommitMessageRequest) (*WriteGitCommitMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteGitCommitMessage not implemented")
}
func (UnimplementedAiServiceServer) WriteGitBranchName(context.Context, *WriteGitBranchNameRequest) (*WriteGitBranchNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteGitBranchName not implemented")
}
func (UnimplementedAiServiceServer) StreamBugBot(*StreamBugBotRequest, grpc.ServerStreamingServer[StreamBugBotResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBugBot not implemented")
}
func (UnimplementedAiServiceServer) StreamBugBotAgentic(grpc.BidiStreamingServer[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamBugBotAgentic not implemented")
}
func (UnimplementedAiServiceServer) StreamBugBotAgenticSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamBugBotAgenticServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamBugBotAgenticSSE not implemented")
}
func (UnimplementedAiServiceServer) StreamBugBotAgenticPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBugBotAgenticPoll not implemented")
}
func (UnimplementedAiServiceServer) StreamUiBestOfNJudge(grpc.BidiStreamingServer[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamUiBestOfNJudge not implemented")
}
func (UnimplementedAiServiceServer) StreamUiBestOfNJudgeSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUiBestOfNJudgeServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamUiBestOfNJudgeSSE not implemented")
}
func (UnimplementedAiServiceServer) StreamUiBestOfNJudgePoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamUiBestOfNJudgePoll not implemented")
}
func (UnimplementedAiServiceServer) CheckBugBotPrice(context.Context, *CheckBugBotPriceRequest) (*CheckBugBotPriceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckBugBotPrice not implemented")
}
func (UnimplementedAiServiceServer) CheckBugBotTelemetryHealthy(context.Context, *CheckBugBotTelemetryHealthyRequest) (*CheckBugBotTelemetryHealthyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckBugBotTelemetryHealthy not implemented")
}
func (UnimplementedAiServiceServer) RecordIdeBugReaction(context.Context, *RecordIdeBugReactionRequest) (*RecordIdeBugReactionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordIdeBugReaction not implemented")
}
func (UnimplementedAiServiceServer) GetSuggestedBugBotIterations(context.Context, *GetSuggestedBugBotIterationsRequest) (*GetSuggestedBugBotIterationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSuggestedBugBotIterations not implemented")
}
func (UnimplementedAiServiceServer) GetEditorBugbotAutoRunStatus(context.Context, *GetEditorBugbotAutoRunStatusRequest) (*GetEditorBugbotAutoRunStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEditorBugbotAutoRunStatus not implemented")
}
func (UnimplementedAiServiceServer) TestBidi(grpc.BidiStreamingServer[TestBidiRequest, TestBidiResponse]) error {
	return status.Error(codes.Unimplemented, "method TestBidi not implemented")
}
func (UnimplementedAiServiceServer) StreamDiffReview(*GetDiffReviewRequest, grpc.ServerStreamingServer[StreamDiffReviewResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamDiffReview not implemented")
}
func (UnimplementedAiServiceServer) StreamDiffReviewByFile(*GetDiffReviewRequest, grpc.ServerStreamingServer[StreamDiffReviewByFileResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamDiffReviewByFile not implemented")
}
func (UnimplementedAiServiceServer) GetModelLabels(context.Context, *GetModelLabelsRequest) (*GetModelLabelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetModelLabels not implemented")
}
func (UnimplementedAiServiceServer) GetLastDefaultModelNudge(context.Context, *GetLastDefaultModelNudgeRequest) (*GetLastDefaultModelNudgeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLastDefaultModelNudge not implemented")
}
func (UnimplementedAiServiceServer) GetDefaultModelNudgeData(context.Context, *GetDefaultModelNudgeDataRequest) (*GetDefaultModelNudgeDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDefaultModelNudgeData not implemented")
}
func (UnimplementedAiServiceServer) GetDefaultModel(context.Context, *GetDefaultModelRequest) (*GetDefaultModelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDefaultModel not implemented")
}
func (UnimplementedAiServiceServer) ReportCommitAiAnalytics(context.Context, *ReportCommitAiAnalyticsRequest) (*ReportCommitAiAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportCommitAiAnalytics not implemented")
}
func (UnimplementedAiServiceServer) TestBedrockCredentials(context.Context, *TestBedrockCredentialsRequest) (*TestBedrockCredentialsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestBedrockCredentials not implemented")
}
func (UnimplementedAiServiceServer) ReportAiCodeChangeMetrics(context.Context, *ReportAiCodeChangeMetricsRequest) (*ReportAiCodeChangeMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportAiCodeChangeMetrics not implemented")
}
func (UnimplementedAiServiceServer) ReportProcessMetrics(context.Context, *ReportProcessMetricsRequest) (*ReportProcessMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportProcessMetrics not implemented")
}
func (UnimplementedAiServiceServer) ReportProcessMetricsV2(context.Context, *ReportProcessMetricsV2Request) (*ReportProcessMetricsV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportProcessMetricsV2 not implemented")
}
func (UnimplementedAiServiceServer) ReportClientNumericMetrics(context.Context, *ReportClientNumericMetricsRequest) (*ReportClientNumericMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportClientNumericMetrics not implemented")
}
func (UnimplementedAiServiceServer) PotentiallyGenerateMemory(context.Context, *PotentiallyGenerateMemoryRequest) (*PotentiallyGenerateMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PotentiallyGenerateMemory not implemented")
}
func (UnimplementedAiServiceServer) KnowledgeBaseAdd(context.Context, *KnowledgeBaseAddRequest) (*KnowledgeBaseAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KnowledgeBaseAdd not implemented")
}
func (UnimplementedAiServiceServer) KnowledgeBaseList(context.Context, *KnowledgeBaseListRequest) (*KnowledgeBaseListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KnowledgeBaseList not implemented")
}
func (UnimplementedAiServiceServer) KnowledgeBaseRemove(context.Context, *KnowledgeBaseRemoveRequest) (*KnowledgeBaseRemoveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KnowledgeBaseRemove not implemented")
}
func (UnimplementedAiServiceServer) KnowledgeBaseUpdate(context.Context, *KnowledgeBaseUpdateRequest) (*KnowledgeBaseUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method KnowledgeBaseUpdate not implemented")
}
func (UnimplementedAiServiceServer) FetchRelevantKnowledgeForConversation(context.Context, *FetchRelevantKnowledgeForConversationRequest) (*FetchRelevantKnowledgeForConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchRelevantKnowledgeForConversation not implemented")
}
func (UnimplementedAiServiceServer) InferBackgroundComposerScripts(context.Context, *InferBackgroundComposerScriptsRequest) (*InferBackgroundComposerScriptsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InferBackgroundComposerScripts not implemented")
}
func (UnimplementedAiServiceServer) GetBackgroundComposerFeedbackLink(context.Context, *GetBackgroundComposerFeedbackLinkRequest) (*GetBackgroundComposerFeedbackLinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerFeedbackLink not implemented")
}
func (UnimplementedAiServiceServer) GetUsableModels(context.Context, *GetUsableModelsRequest) (*GetUsableModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUsableModels not implemented")
}
func (UnimplementedAiServiceServer) GetDefaultModelForCli(context.Context, *GetDefaultModelForCliRequest) (*GetDefaultModelForCliResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDefaultModelForCli not implemented")
}
func (UnimplementedAiServiceServer) StreamComposerEnhancer(grpc.BidiStreamingServer[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamComposerEnhancer not implemented")
}
func (UnimplementedAiServiceServer) StreamComposerEnhancerSSE(*BidiRequestId, grpc.ServerStreamingServer[ComposerEnhancerServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamComposerEnhancerSSE not implemented")
}
func (UnimplementedAiServiceServer) StreamComposerEnhancerPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamComposerEnhancerPoll not implemented")
}
func (UnimplementedAiServiceServer) StreamStt(grpc.BidiStreamingServer[SttClientMessage, SttServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamStt not implemented")
}
func (UnimplementedAiServiceServer) StreamSttSSE(*BidiRequestId, grpc.ServerStreamingServer[SttServerMessage]) error {
	return status.Error(codes.Unimplemented, "method StreamSttSSE not implemented")
}
func (UnimplementedAiServiceServer) StreamSttPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamSttPoll not implemented")
}
func (UnimplementedAiServiceServer) NameAgent(context.Context, *NameAgentRequest) (*NameAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NameAgent not implemented")
}
func (UnimplementedAiServiceServer) EvaluatePromptHook(context.Context, *EvaluatePromptHookRequest) (*EvaluatePromptHookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EvaluatePromptHook not implemented")
}
func (UnimplementedAiServiceServer) mustEmbedUnimplementedAiServiceServer() {}
func (UnimplementedAiServiceServer) testEmbeddedByValue()                   {}

// UnsafeAiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AiServiceServer will
// result in compilation errors.
type UnsafeAiServiceServer interface {
	mustEmbedUnimplementedAiServiceServer()
}

func RegisterAiServiceServer(s grpc.ServiceRegistrar, srv AiServiceServer) {
	// If the following call panics, it indicates UnimplementedAiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AiService_ServiceDesc, srv)
}

func _AiService_ServerTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ServerTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ServerTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ServerTime(ctx, req.(*ServerTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_PrivacyCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrivacyCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).PrivacyCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_PrivacyCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).PrivacyCheck(ctx, req.(*PrivacyCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TimeLeftHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TimeLeftHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TimeLeftHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TimeLeftHealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ThrowErrorCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThrowErrorCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ThrowErrorCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ThrowErrorCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ThrowErrorCheck(ctx, req.(*ThrowErrorCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_AvailableModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailableModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).AvailableModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_AvailableModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).AvailableModels(ctx, req.(*AvailableModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamChatTryReallyHard_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatTryReallyHard(m, &grpc.GenericServerStream[GetChatRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatTryReallyHardServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_RerankDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RerankDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RerankDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RerankDocuments(ctx, req.(*RerankDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamComposer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetComposerChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamComposer(m, &grpc.GenericServerStream[GetComposerChatRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_StreamComposerContext_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamChatContextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamComposerContext(m, &grpc.GenericServerStream[StreamChatContextRequest, StreamChatContextResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerContextServer = grpc.ServerStreamingServer[StreamChatContextResponse]

func _AiService_WarmComposerCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComposerChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).WarmComposerCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_WarmComposerCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).WarmComposerCache(ctx, req.(*GetComposerChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_KeepComposerCacheWarm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeepComposerCacheWarmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).KeepComposerCacheWarm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_KeepComposerCacheWarm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).KeepComposerCacheWarm(ctx, req.(*KeepComposerCacheWarmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CountTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CountTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CountTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CountTokens(ctx, req.(*CountTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamPotentialLocs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PotentialLocsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPotentialLocs(m, &grpc.GenericServerStream[PotentialLocsRequest, PotentialLocsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsServer = grpc.ServerStreamingServer[PotentialLocsResponse]

func _AiService_StreamPotentialLocsUnderneath_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PotentialLocsUnderneathRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPotentialLocsUnderneath(m, &grpc.GenericServerStream[PotentialLocsUnderneathRequest, PotentialLocsUnderneathResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsUnderneathServer = grpc.ServerStreamingServer[PotentialLocsUnderneathResponse]

func _AiService_StreamPotentialLocsInitialQueries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PotentialLocsInitialQueriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPotentialLocsInitialQueries(m, &grpc.GenericServerStream[PotentialLocsInitialQueriesRequest, PotentialLocsInitialQueriesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPotentialLocsInitialQueriesServer = grpc.ServerStreamingServer[PotentialLocsInitialQueriesResponse]

func _AiService_GetChatTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatTitleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetChatTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetChatTitle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetChatTitle(ctx, req.(*GetChatTitleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetCompletion(ctx, req.(*GetCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_IsolatedTreesitter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsolatedTreesitterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).IsolatedTreesitter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_IsolatedTreesitter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).IsolatedTreesitter(ctx, req.(*IsolatedTreesitterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetSimplePrompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSimplePromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetSimplePrompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetSimplePrompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetSimplePrompt(ctx, req.(*GetSimplePromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetPassthroughPrompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPassthroughPromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetPassthroughPrompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetPassthroughPrompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetPassthroughPrompt(ctx, req.(*GetPassthroughPromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckLongFilesFit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckLongFilesFit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckLongFilesFit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckLongFilesFit(ctx, req.(*GetChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetEvaluationPrompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvaluationPromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetEvaluationPrompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetEvaluationPrompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetEvaluationPrompt(ctx, req.(*GetEvaluationPromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChat(m, &grpc.GenericServerStream[GetChatRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_StreamChatWeb_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatWeb(m, &grpc.GenericServerStream[GetChatRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatWebServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_WarmChatCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WarmChatCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).WarmChatCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_WarmChatCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).WarmChatCache(ctx, req.(*WarmChatCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamEdit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamEditRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamEdit(m, &grpc.GenericServerStream[StreamEditRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamEditServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_PreloadEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreloadEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).PreloadEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_PreloadEdit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).PreloadEdit(ctx, req.(*PreloadEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamFastEdit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamFastEditRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamFastEdit(m, &grpc.GenericServerStream[StreamFastEditRequest, StreamFastEditResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamFastEditServer = grpc.ServerStreamingServer[StreamFastEditResponse]

func _AiService_StreamGenerate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamGenerateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamGenerate(m, &grpc.GenericServerStream[StreamGenerateRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamGenerateServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_StreamInlineLongCompletion_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamInlineLongCompletionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamInlineLongCompletion(m, &grpc.GenericServerStream[StreamInlineLongCompletionRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamInlineLongCompletionServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_SlashEdit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SlashEditRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).SlashEdit(m, &grpc.GenericServerStream[SlashEditRequest, SlashEditResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_SlashEditServer = grpc.ServerStreamingServer[SlashEditResponse]

func _AiService_SlashEditFollowUpWithPreviousEdits_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SlashEditFollowUpWithPreviousEditsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).SlashEditFollowUpWithPreviousEdits(m, &grpc.GenericServerStream[SlashEditFollowUpWithPreviousEditsRequest, StreamSlashEditFollowUpWithPreviousEditsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_SlashEditFollowUpWithPreviousEditsServer = grpc.ServerStreamingServer[StreamSlashEditFollowUpWithPreviousEditsResponse]

func _AiService_StreamAiPreviews_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamAiPreviewsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamAiPreviews(m, &grpc.GenericServerStream[StreamAiPreviewsRequest, StreamAiPreviewsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiPreviewsServer = grpc.ServerStreamingServer[StreamAiPreviewsResponse]

func _AiService_ShouldTurnOnCppOnboarding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShouldTurnOnCppOnboardingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ShouldTurnOnCppOnboarding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ShouldTurnOnCppOnboarding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ShouldTurnOnCppOnboarding(ctx, req.(*ShouldTurnOnCppOnboardingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetComposerAutocomplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComposerAutocompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetComposerAutocomplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetComposerAutocomplete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetComposerAutocomplete(ctx, req.(*GetComposerAutocompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamReview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReviewRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamReview(m, &grpc.GenericServerStream[ReviewRequest, ReviewResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamReviewServer = grpc.ServerStreamingServer[ReviewResponse]

func _AiService_StreamReviewChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReviewChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamReviewChat(m, &grpc.GenericServerStream[ReviewChatRequest, ReviewChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamReviewChatServer = grpc.ServerStreamingServer[ReviewChatResponse]

func _AiService_CheckQueuePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckQueuePositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckQueuePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckQueuePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckQueuePosition(ctx, req.(*CheckQueuePositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckUsageBasedPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUsageBasedPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckUsageBasedPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckUsageBasedPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckUsageBasedPrice(ctx, req.(*CheckUsageBasedPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_DoThisForMeCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoThisForMeCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).DoThisForMeCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_DoThisForMeCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).DoThisForMeCheck(ctx, req.(*DoThisForMeCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamDoThisForMe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DoThisForMeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamDoThisForMe(m, &grpc.GenericServerStream[DoThisForMeRequest, DoThisForMeResponseWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDoThisForMeServer = grpc.ServerStreamingServer[DoThisForMeResponseWrapped]

func _AiService_StreamChatToolformer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatToolformer(m, &grpc.GenericServerStream[GetChatRequest, StreamChatToolformerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatToolformerServer = grpc.ServerStreamingServer[StreamChatToolformerResponse]

func _AiService_StreamChatToolformerContinue_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamChatToolformerContinueRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatToolformerContinue(m, &grpc.GenericServerStream[StreamChatToolformerContinueRequest, StreamChatToolformerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatToolformerContinueServer = grpc.ServerStreamingServer[StreamChatToolformerResponse]

func _AiService_PushAiThought_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushAiThoughtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).PushAiThought(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_PushAiThought_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).PushAiThought(ctx, req.(*PushAiThoughtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckDoableAsTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDoableAsTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckDoableAsTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckDoableAsTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckDoableAsTask(ctx, req.(*CheckDoableAsTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportGroundTruthCandidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportGroundTruthCandidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportGroundTruthCandidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportGroundTruthCandidate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportGroundTruthCandidate(ctx, req.(*ReportGroundTruthCandidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportCmdKFate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCmdKFateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportCmdKFate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportCmdKFate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportCmdKFate(ctx, req.(*ReportCmdKFateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ShowWelcomeScreen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowWelcomeScreenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ShowWelcomeScreen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ShowWelcomeScreen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ShowWelcomeScreen(ctx, req.(*ShowWelcomeScreenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_InterfaceAgentInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceAgentInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).InterfaceAgentInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_InterfaceAgentInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).InterfaceAgentInit(ctx, req.(*InterfaceAgentInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamInterfaceAgentStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamInterfaceAgentStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamInterfaceAgentStatus(m, &grpc.GenericServerStream[StreamInterfaceAgentStatusRequest, StreamInterfaceAgentStatusResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamInterfaceAgentStatusServer = grpc.ServerStreamingServer[StreamInterfaceAgentStatusResponse]

func _AiService_TaskGetInterfaceAgentStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskGetInterfaceAgentStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).TaskGetInterfaceAgentStatus(m, &grpc.GenericServerStream[TaskGetInterfaceAgentStatusRequest, TaskGetInterfaceAgentStatusResponseWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskGetInterfaceAgentStatusServer = grpc.ServerStreamingServer[TaskGetInterfaceAgentStatusResponseWrapped]

func _AiService_UpdateVscodeProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVscodeProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).UpdateVscodeProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_UpdateVscodeProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).UpdateVscodeProfile(ctx, req.(*UpdateVscodeProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TaskInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TaskInit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TaskInit(ctx, req.(*TaskInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskPause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskPauseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TaskPause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TaskPause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TaskPause(ctx, req.(*TaskPauseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TaskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TaskInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TaskInfo(ctx, req.(*TaskInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskStreamLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskStreamLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).TaskStreamLog(m, &grpc.GenericServerStream[TaskStreamLogRequest, TaskStreamLogResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskStreamLogServer = grpc.ServerStreamingServer[TaskStreamLogResponse]

func _AiService_TaskSendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskSendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TaskSendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TaskSendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TaskSendMessage(ctx, req.(*TaskSendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskProvideResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskProvideResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TaskProvideResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TaskProvideResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TaskProvideResult(ctx, req.(*TaskProvideResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CreateExperimentalIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExperimentalIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CreateExperimentalIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CreateExperimentalIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CreateExperimentalIndex(ctx, req.(*CreateExperimentalIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ListExperimentalIndexFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExperimentalIndexFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ListExperimentalIndexFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ListExperimentalIndexFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ListExperimentalIndexFiles(ctx, req.(*ListExperimentalIndexFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ListenExperimentalIndex_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenExperimentalIndexRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).ListenExperimentalIndex(m, &grpc.GenericServerStream[ListenExperimentalIndexRequest, ListenExperimentalIndexResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_ListenExperimentalIndexServer = grpc.ServerStreamingServer[ListenExperimentalIndexResponse]

func _AiService_RegisterFileToIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFileToIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RegisterFileToIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RegisterFileToIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RegisterFileToIndex(ctx, req.(*RegisterFileToIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_SetupIndexDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupIndexDependenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).SetupIndexDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_SetupIndexDependencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).SetupIndexDependencies(ctx, req.(*SetupIndexDependenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ComputeIndexTopoSort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComputeIndexTopoSortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ComputeIndexTopoSort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ComputeIndexTopoSort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ComputeIndexTopoSort(ctx, req.(*ComputeIndexTopoSortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamChatDeepContext_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamChatDeepContextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatDeepContext(m, &grpc.GenericServerStream[StreamChatDeepContextRequest, StreamChatDeepContextResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatDeepContextServer = grpc.ServerStreamingServer[StreamChatDeepContextResponse]

func _AiService_ChooseCodeReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChooseCodeReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ChooseCodeReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ChooseCodeReferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ChooseCodeReferences(ctx, req.(*ChooseCodeReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_RegisterCodeReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterCodeReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RegisterCodeReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RegisterCodeReferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RegisterCodeReferences(ctx, req.(*RegisterCodeReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ExtractPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ExtractPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ExtractPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ExtractPaths(ctx, req.(*ExtractPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_SummarizeWithReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SummarizeWithReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).SummarizeWithReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_SummarizeWithReferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).SummarizeWithReferences(ctx, req.(*SummarizeWithReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_DocumentationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentationQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).DocumentationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_DocumentationQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).DocumentationQuery(ctx, req.(*DocumentationQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_AvailableDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailableDocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).AvailableDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_AvailableDocs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).AvailableDocs(ctx, req.(*AvailableDocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportFeedback(ctx, req.(*ReportFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportBug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportBugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportBug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportBug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportBug(ctx, req.(*ReportBugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamChatContext_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamChatContextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamChatContext(m, &grpc.GenericServerStream[StreamChatContextRequest, StreamChatContextResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamChatContextServer = grpc.ServerStreamingServer[StreamChatContextResponse]

func _AiService_GenerateTldr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateTldrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GenerateTldr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GenerateTldr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GenerateTldr(ctx, req.(*GenerateTldrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TaskStreamChatContext_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskStreamChatContextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).TaskStreamChatContext(m, &grpc.GenericServerStream[TaskStreamChatContextRequest, TaskStreamChatContextResponseWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TaskStreamChatContextServer = grpc.ServerStreamingServer[TaskStreamChatContextResponseWrapped]

func _AiService_RerankResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RerankResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RerankResults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RerankResults(ctx, req.(*RerankerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ModelQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModelQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ModelQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ModelQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ModelQuery(ctx, req.(*ModelQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ModelQueryV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ModelQueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).ModelQueryV2(m, &grpc.GenericServerStream[ModelQueryRequest, ModelQueryResponseV2]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_ModelQueryV2Server = grpc.ServerStreamingServer[ModelQueryResponseV2]

func _AiService_IntentPrediction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntentPredictionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).IntentPrediction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_IntentPrediction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).IntentPrediction(ctx, req.(*IntentPredictionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetChatSuggestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatSuggestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetChatSuggestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetChatSuggestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetChatSuggestions(ctx, req.(*GetChatSuggestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetUserInstructions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInstructionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetUserInstructions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetUserInstructions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetUserInstructions(ctx, req.(*GetUserInstructionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamCursorTutor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamCursorTutorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamCursorTutor(m, &grpc.GenericServerStream[StreamCursorTutorRequest, StreamCursorTutorResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCursorTutorServer = grpc.ServerStreamingServer[StreamCursorTutorResponse]

func _AiService_CheckFeatureStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFeatureStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckFeatureStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckFeatureStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckFeatureStatus(ctx, req.(*CheckFeatureStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckFeaturesStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFeaturesStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckFeaturesStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckFeaturesStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckFeaturesStatus(ctx, req.(*CheckFeaturesStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckFeatureStatusUnauthenticated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFeatureStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckFeatureStatusUnauthenticated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckFeatureStatusUnauthenticated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckFeatureStatusUnauthenticated(ctx, req.(*CheckFeatureStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetEffectiveTokenLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEffectiveTokenLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetEffectiveTokenLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetEffectiveTokenLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetEffectiveTokenLimit(ctx, req.(*GetEffectiveTokenLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetContextScores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextScoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetContextScores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetContextScores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetContextScores(ctx, req.(*ContextScoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamCpp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamCppRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamCpp(m, &grpc.GenericServerStream[StreamCppRequest, StreamCppResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCppServer = grpc.ServerStreamingServer[StreamCppResponse]

func _AiService_CppConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CppConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CppConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CppConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CppConfig(ctx, req.(*CppConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CppEditHistoryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CppEditHistoryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CppEditHistoryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CppEditHistoryStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CppEditHistoryStatus(ctx, req.(*CppEditHistoryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CppAppend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CppAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CppAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CppAppend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CppAppend(ctx, req.(*CppAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_RefreshTabContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTabContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RefreshTabContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RefreshTabContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RefreshTabContext(ctx, req.(*RefreshTabContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckNumberConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckNumberConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckNumberConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckNumberConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckNumberConfig(ctx, req.(*CheckNumberConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckNumberConfigUnauthenticated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckNumberConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckNumberConfigUnauthenticated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckNumberConfigUnauthenticated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckNumberConfigUnauthenticated(ctx, req.(*CheckNumberConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckNumberConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckNumberConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckNumberConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckNumberConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckNumberConfigs(ctx, req.(*CheckNumberConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamTerminalAutocomplete_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamTerminalAutocompleteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamTerminalAutocomplete(m, &grpc.GenericServerStream[StreamTerminalAutocompleteRequest, StreamTerminalAutocompleteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamTerminalAutocompleteServer = grpc.ServerStreamingServer[StreamTerminalAutocompleteResponse]

func _AiService_StreamPseudocodeGenerator_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPseudocodeGeneratorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPseudocodeGenerator(m, &grpc.GenericServerStream[StreamPseudocodeGeneratorRequest, StreamPseudocodeGeneratorResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPseudocodeGeneratorServer = grpc.ServerStreamingServer[StreamPseudocodeGeneratorResponse]

func _AiService_StreamPseudocodeMapper_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPseudocodeMapperRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPseudocodeMapper(m, &grpc.GenericServerStream[StreamPseudocodeMapperRequest, StreamPseudocodeMapperResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPseudocodeMapperServer = grpc.ServerStreamingServer[StreamPseudocodeMapperResponse]

func _AiService_AcknowledgeGracePeriodDisclaimer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcknowledgeGracePeriodDisclaimerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).AcknowledgeGracePeriodDisclaimer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_AcknowledgeGracePeriodDisclaimer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).AcknowledgeGracePeriodDisclaimer(ctx, req.(*AcknowledgeGracePeriodDisclaimerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamAiLintBug_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamAiLintBugRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamAiLintBug(m, &grpc.GenericServerStream[StreamAiLintBugRequest, StreamAiLintBugResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiLintBugServer = grpc.ServerStreamingServer[StreamAiLintBugResponse]

func _AiService_StreamAiCursorHelp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamAiCursorHelpRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamAiCursorHelp(m, &grpc.GenericServerStream[StreamAiCursorHelpRequest, StreamAiCursorHelpResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamAiCursorHelpServer = grpc.ServerStreamingServer[StreamAiCursorHelpResponse]

func _AiService_LogUserLintReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogUserLintReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).LogUserLintReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_LogUserLintReply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).LogUserLintReply(ctx, req.(*LogUserLintReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_LogLinterExplicitUserFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogLinterExplicitUserFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).LogLinterExplicitUserFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_LogLinterExplicitUserFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).LogLinterExplicitUserFeedback(ctx, req.(*LogLinterExplicitUserFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamFixMarkers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FixMarkersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamFixMarkers(m, &grpc.GenericServerStream[FixMarkersRequest, FixMarkersResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamFixMarkersServer = grpc.ServerStreamingServer[FixMarkersResponse]

func _AiService_ReportInlineAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportInlineActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportInlineAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportInlineAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportInlineAction(ctx, req.(*ReportInlineActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamPriomptPrompt_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPriomptPromptRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamPriomptPrompt(m, &grpc.GenericServerStream[StreamPriomptPromptRequest, StreamPriomptPromptResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamPriomptPromptServer = grpc.ServerStreamingServer[StreamPriomptPromptResponse]

func _AiService_StreamLint_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamLintRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamLint(m, &grpc.GenericServerStream[StreamLintRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamLintServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_StreamNewLintRule_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamNewRuleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamNewLintRule(m, &grpc.GenericServerStream[StreamNewRuleRequest, StreamChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamNewLintRuleServer = grpc.ServerStreamingServer[StreamChatResponse]

func _AiService_AiProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AiProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).AiProject(m, &grpc.GenericServerStream[AiProjectRequest, AiProjectResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_AiProjectServer = grpc.ServerStreamingServer[AiProjectResponse]

func _AiService_ToCamelCase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToCamelCaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ToCamelCase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ToCamelCase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ToCamelCase(ctx, req.(*ToCamelCaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportGenerationFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportGenerationFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportGenerationFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportGenerationFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportGenerationFeedback(ctx, req.(*ReportGenerationFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetThoughtAnnotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThoughtAnnotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetThoughtAnnotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetThoughtAnnotation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetThoughtAnnotation(ctx, req.(*GetThoughtAnnotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamWebCmdKV1_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamWebCmdKV1Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamWebCmdKV1(m, &grpc.GenericServerStream[StreamWebCmdKV1Request, StreamWebCmdKV1Response]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamWebCmdKV1Server = grpc.ServerStreamingServer[StreamWebCmdKV1Response]

func _AiService_StreamNextCursorPrediction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamNextCursorPredictionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamNextCursorPrediction(m, &grpc.GenericServerStream[StreamNextCursorPredictionRequest, StreamNextCursorPredictionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamNextCursorPredictionServer = grpc.ServerStreamingServer[StreamNextCursorPredictionResponse]

func _AiService_IsCursorPredictionEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsCursorPredictionEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).IsCursorPredictionEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_IsCursorPredictionEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).IsCursorPredictionEnabled(ctx, req.(*IsCursorPredictionEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetCppEditClassification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCppEditClassificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetCppEditClassification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetCppEditClassification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetCppEditClassification(ctx, req.(*GetCppEditClassificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetTerminalCompletion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTerminalCompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetTerminalCompletion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetTerminalCompletion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetTerminalCompletion(ctx, req.(*GetTerminalCompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TakeNotesOnCommitDiff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeNotesOnCommitDiffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TakeNotesOnCommitDiff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TakeNotesOnCommitDiff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TakeNotesOnCommitDiff(ctx, req.(*TakeNotesOnCommitDiffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_BulkEmbed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkEmbedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).BulkEmbed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_BulkEmbed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).BulkEmbed(ctx, req.(*BulkEmbedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_BackgroundCmdKEval_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackgroundCmdKEvalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).BackgroundCmdKEval(m, &grpc.GenericServerStream[BackgroundCmdKEvalRequest, BackgroundCmdKEvalResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_BackgroundCmdKEvalServer = grpc.ServerStreamingServer[BackgroundCmdKEvalResponse]

func _AiService_BackgroundCmdK_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackgroundCmdKRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).BackgroundCmdK(m, &grpc.GenericServerStream[BackgroundCmdKRequest, BackgroundCmdKResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_BackgroundCmdKServer = grpc.ServerStreamingServer[BackgroundCmdKResponse]

func _AiService_StreamCursorMotion_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamCursorMotionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamCursorMotion(m, &grpc.GenericServerStream[StreamCursorMotionRequest, StreamCursorMotionResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamCursorMotionServer = grpc.ServerStreamingServer[StreamCursorMotionResponse]

func _AiService_CalculateAutoSelection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculateAutoSelectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CalculateAutoSelection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CalculateAutoSelection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CalculateAutoSelection(ctx, req.(*CalculateAutoSelectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetAtSymbolSuggestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAtSymbolSuggestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetAtSymbolSuggestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetAtSymbolSuggestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetAtSymbolSuggestions(ctx, req.(*GetAtSymbolSuggestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetCodebaseQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetCodebaseQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetCodebaseQuestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetCodebaseQuestions(ctx, req.(*GetChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CppEditHistoryAppend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditHistoryAppendChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CppEditHistoryAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CppEditHistoryAppend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CppEditHistoryAppend(ctx, req.(*EditHistoryAppendChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_DevOnlyGetPastRequestIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DevOnlyGetPastRequestIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).DevOnlyGetPastRequestIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_DevOnlyGetPastRequestIds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).DevOnlyGetPastRequestIds(ctx, req.(*DevOnlyGetPastRequestIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetFilesForComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilesForComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetFilesForComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetFilesForComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetFilesForComposer(ctx, req.(*GetFilesForComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TryParseTypeScriptTreeSitter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TryParseTypeScriptTreeSitterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TryParseTypeScriptTreeSitter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TryParseTypeScriptTreeSitter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TryParseTypeScriptTreeSitter(ctx, req.(*TryParseTypeScriptTreeSitterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_NameTab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameTabRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).NameTab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_NameTab_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).NameTab(ctx, req.(*NameTabRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_IsTerminalFinishedV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsTerminalFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).IsTerminalFinishedV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_IsTerminalFinishedV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).IsTerminalFinishedV2(ctx, req.(*IsTerminalFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TestModelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestModelStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TestModelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TestModelStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TestModelStatus(ctx, req.(*TestModelStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_FindBugs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindBugsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).FindBugs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_FindBugs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).FindBugs(ctx, req.(*FindBugsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ContextReranking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextRerankingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ContextReranking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ContextReranking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ContextReranking(ctx, req.(*ContextRerankingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_AutoContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).AutoContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_AutoContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).AutoContext(ctx, req.(*AutoContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_WriteGitCommitMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteGitCommitMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).WriteGitCommitMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_WriteGitCommitMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).WriteGitCommitMessage(ctx, req.(*WriteGitCommitMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_WriteGitBranchName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteGitBranchNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).WriteGitBranchName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_WriteGitBranchName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).WriteGitBranchName(ctx, req.(*WriteGitBranchNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamBugBot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamBugBotRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamBugBot(m, &grpc.GenericServerStream[StreamBugBotRequest, StreamBugBotResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotServer = grpc.ServerStreamingServer[StreamBugBotResponse]

func _AiService_StreamBugBotAgentic_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AiServiceServer).StreamBugBotAgentic(&grpc.GenericServerStream[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticServer = grpc.BidiStreamingServer[StreamBugBotAgenticClientMessage, StreamBugBotAgenticServerMessage]

func _AiService_StreamBugBotAgenticSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamBugBotAgenticSSE(m, &grpc.GenericServerStream[BidiRequestId, StreamBugBotAgenticServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticSSEServer = grpc.ServerStreamingServer[StreamBugBotAgenticServerMessage]

func _AiService_StreamBugBotAgenticPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamBugBotAgenticPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamBugBotAgenticPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _AiService_StreamUiBestOfNJudge_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AiServiceServer).StreamUiBestOfNJudge(&grpc.GenericServerStream[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgeServer = grpc.BidiStreamingServer[StreamUiBestOfNJudgeClientMessage, StreamUiBestOfNJudgeServerMessage]

func _AiService_StreamUiBestOfNJudgeSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamUiBestOfNJudgeSSE(m, &grpc.GenericServerStream[BidiRequestId, StreamUiBestOfNJudgeServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgeSSEServer = grpc.ServerStreamingServer[StreamUiBestOfNJudgeServerMessage]

func _AiService_StreamUiBestOfNJudgePoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamUiBestOfNJudgePoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamUiBestOfNJudgePollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _AiService_CheckBugBotPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBugBotPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckBugBotPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckBugBotPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckBugBotPrice(ctx, req.(*CheckBugBotPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_CheckBugBotTelemetryHealthy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBugBotTelemetryHealthyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).CheckBugBotTelemetryHealthy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_CheckBugBotTelemetryHealthy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).CheckBugBotTelemetryHealthy(ctx, req.(*CheckBugBotTelemetryHealthyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_RecordIdeBugReaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordIdeBugReactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).RecordIdeBugReaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_RecordIdeBugReaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).RecordIdeBugReaction(ctx, req.(*RecordIdeBugReactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetSuggestedBugBotIterations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedBugBotIterationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetSuggestedBugBotIterations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetSuggestedBugBotIterations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetSuggestedBugBotIterations(ctx, req.(*GetSuggestedBugBotIterationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetEditorBugbotAutoRunStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEditorBugbotAutoRunStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetEditorBugbotAutoRunStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetEditorBugbotAutoRunStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetEditorBugbotAutoRunStatus(ctx, req.(*GetEditorBugbotAutoRunStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TestBidi_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AiServiceServer).TestBidi(&grpc.GenericServerStream[TestBidiRequest, TestBidiResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_TestBidiServer = grpc.BidiStreamingServer[TestBidiRequest, TestBidiResponse]

func _AiService_StreamDiffReview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDiffReviewRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamDiffReview(m, &grpc.GenericServerStream[GetDiffReviewRequest, StreamDiffReviewResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDiffReviewServer = grpc.ServerStreamingServer[StreamDiffReviewResponse]

func _AiService_StreamDiffReviewByFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDiffReviewRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamDiffReviewByFile(m, &grpc.GenericServerStream[GetDiffReviewRequest, StreamDiffReviewByFileResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamDiffReviewByFileServer = grpc.ServerStreamingServer[StreamDiffReviewByFileResponse]

func _AiService_GetModelLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelLabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetModelLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetModelLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetModelLabels(ctx, req.(*GetModelLabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetLastDefaultModelNudge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastDefaultModelNudgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetLastDefaultModelNudge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetLastDefaultModelNudge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetLastDefaultModelNudge(ctx, req.(*GetLastDefaultModelNudgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetDefaultModelNudgeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultModelNudgeDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetDefaultModelNudgeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetDefaultModelNudgeData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetDefaultModelNudgeData(ctx, req.(*GetDefaultModelNudgeDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetDefaultModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetDefaultModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetDefaultModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetDefaultModel(ctx, req.(*GetDefaultModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportCommitAiAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCommitAiAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportCommitAiAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportCommitAiAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportCommitAiAnalytics(ctx, req.(*ReportCommitAiAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_TestBedrockCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestBedrockCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).TestBedrockCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_TestBedrockCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).TestBedrockCredentials(ctx, req.(*TestBedrockCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportAiCodeChangeMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAiCodeChangeMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportAiCodeChangeMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportAiCodeChangeMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportAiCodeChangeMetrics(ctx, req.(*ReportAiCodeChangeMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportProcessMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportProcessMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportProcessMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportProcessMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportProcessMetrics(ctx, req.(*ReportProcessMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportProcessMetricsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportProcessMetricsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportProcessMetricsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportProcessMetricsV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportProcessMetricsV2(ctx, req.(*ReportProcessMetricsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_ReportClientNumericMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportClientNumericMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).ReportClientNumericMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_ReportClientNumericMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).ReportClientNumericMetrics(ctx, req.(*ReportClientNumericMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_PotentiallyGenerateMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PotentiallyGenerateMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).PotentiallyGenerateMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_PotentiallyGenerateMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).PotentiallyGenerateMemory(ctx, req.(*PotentiallyGenerateMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_KnowledgeBaseAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBaseAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).KnowledgeBaseAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_KnowledgeBaseAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).KnowledgeBaseAdd(ctx, req.(*KnowledgeBaseAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_KnowledgeBaseList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBaseListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).KnowledgeBaseList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_KnowledgeBaseList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).KnowledgeBaseList(ctx, req.(*KnowledgeBaseListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_KnowledgeBaseRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBaseRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).KnowledgeBaseRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_KnowledgeBaseRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).KnowledgeBaseRemove(ctx, req.(*KnowledgeBaseRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_KnowledgeBaseUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnowledgeBaseUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).KnowledgeBaseUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_KnowledgeBaseUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).KnowledgeBaseUpdate(ctx, req.(*KnowledgeBaseUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_FetchRelevantKnowledgeForConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchRelevantKnowledgeForConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).FetchRelevantKnowledgeForConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_FetchRelevantKnowledgeForConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).FetchRelevantKnowledgeForConversation(ctx, req.(*FetchRelevantKnowledgeForConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_InferBackgroundComposerScripts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InferBackgroundComposerScriptsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).InferBackgroundComposerScripts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_InferBackgroundComposerScripts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).InferBackgroundComposerScripts(ctx, req.(*InferBackgroundComposerScriptsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetBackgroundComposerFeedbackLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerFeedbackLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetBackgroundComposerFeedbackLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetBackgroundComposerFeedbackLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetBackgroundComposerFeedbackLink(ctx, req.(*GetBackgroundComposerFeedbackLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetUsableModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsableModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetUsableModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetUsableModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetUsableModels(ctx, req.(*GetUsableModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_GetDefaultModelForCli_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultModelForCliRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).GetDefaultModelForCli(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_GetDefaultModelForCli_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).GetDefaultModelForCli(ctx, req.(*GetDefaultModelForCliRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_StreamComposerEnhancer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AiServiceServer).StreamComposerEnhancer(&grpc.GenericServerStream[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerServer = grpc.BidiStreamingServer[ComposerEnhancerClientMessage, ComposerEnhancerServerMessage]

func _AiService_StreamComposerEnhancerSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamComposerEnhancerSSE(m, &grpc.GenericServerStream[BidiRequestId, ComposerEnhancerServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerSSEServer = grpc.ServerStreamingServer[ComposerEnhancerServerMessage]

func _AiService_StreamComposerEnhancerPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamComposerEnhancerPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamComposerEnhancerPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _AiService_StreamStt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AiServiceServer).StreamStt(&grpc.GenericServerStream[SttClientMessage, SttServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttServer = grpc.BidiStreamingServer[SttClientMessage, SttServerMessage]

func _AiService_StreamSttSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamSttSSE(m, &grpc.GenericServerStream[BidiRequestId, SttServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttSSEServer = grpc.ServerStreamingServer[SttServerMessage]

func _AiService_StreamSttPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AiServiceServer).StreamSttPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AiService_StreamSttPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _AiService_NameAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).NameAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_NameAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).NameAgent(ctx, req.(*NameAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiService_EvaluatePromptHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluatePromptHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiServiceServer).EvaluatePromptHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiService_EvaluatePromptHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiServiceServer).EvaluatePromptHook(ctx, req.(*EvaluatePromptHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AiService_ServiceDesc is the grpc.ServiceDesc for AiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AiService",
	HandlerType: (*AiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerTime",
			Handler:    _AiService_ServerTime_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _AiService_HealthCheck_Handler,
		},
		{
			MethodName: "PrivacyCheck",
			Handler:    _AiService_PrivacyCheck_Handler,
		},
		{
			MethodName: "TimeLeftHealthCheck",
			Handler:    _AiService_TimeLeftHealthCheck_Handler,
		},
		{
			MethodName: "ThrowErrorCheck",
			Handler:    _AiService_ThrowErrorCheck_Handler,
		},
		{
			MethodName: "AvailableModels",
			Handler:    _AiService_AvailableModels_Handler,
		},
		{
			MethodName: "RerankDocuments",
			Handler:    _AiService_RerankDocuments_Handler,
		},
		{
			MethodName: "WarmComposerCache",
			Handler:    _AiService_WarmComposerCache_Handler,
		},
		{
			MethodName: "KeepComposerCacheWarm",
			Handler:    _AiService_KeepComposerCacheWarm_Handler,
		},
		{
			MethodName: "CountTokens",
			Handler:    _AiService_CountTokens_Handler,
		},
		{
			MethodName: "GetChatTitle",
			Handler:    _AiService_GetChatTitle_Handler,
		},
		{
			MethodName: "GetCompletion",
			Handler:    _AiService_GetCompletion_Handler,
		},
		{
			MethodName: "IsolatedTreesitter",
			Handler:    _AiService_IsolatedTreesitter_Handler,
		},
		{
			MethodName: "GetSimplePrompt",
			Handler:    _AiService_GetSimplePrompt_Handler,
		},
		{
			MethodName: "GetPassthroughPrompt",
			Handler:    _AiService_GetPassthroughPrompt_Handler,
		},
		{
			MethodName: "CheckLongFilesFit",
			Handler:    _AiService_CheckLongFilesFit_Handler,
		},
		{
			MethodName: "GetEvaluationPrompt",
			Handler:    _AiService_GetEvaluationPrompt_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _AiService_GetUserInfo_Handler,
		},
		{
			MethodName: "WarmChatCache",
			Handler:    _AiService_WarmChatCache_Handler,
		},
		{
			MethodName: "PreloadEdit",
			Handler:    _AiService_PreloadEdit_Handler,
		},
		{
			MethodName: "ShouldTurnOnCppOnboarding",
			Handler:    _AiService_ShouldTurnOnCppOnboarding_Handler,
		},
		{
			MethodName: "GetComposerAutocomplete",
			Handler:    _AiService_GetComposerAutocomplete_Handler,
		},
		{
			MethodName: "CheckQueuePosition",
			Handler:    _AiService_CheckQueuePosition_Handler,
		},
		{
			MethodName: "CheckUsageBasedPrice",
			Handler:    _AiService_CheckUsageBasedPrice_Handler,
		},
		{
			MethodName: "DoThisForMeCheck",
			Handler:    _AiService_DoThisForMeCheck_Handler,
		},
		{
			MethodName: "PushAiThought",
			Handler:    _AiService_PushAiThought_Handler,
		},
		{
			MethodName: "CheckDoableAsTask",
			Handler:    _AiService_CheckDoableAsTask_Handler,
		},
		{
			MethodName: "ReportGroundTruthCandidate",
			Handler:    _AiService_ReportGroundTruthCandidate_Handler,
		},
		{
			MethodName: "ReportCmdKFate",
			Handler:    _AiService_ReportCmdKFate_Handler,
		},
		{
			MethodName: "ShowWelcomeScreen",
			Handler:    _AiService_ShowWelcomeScreen_Handler,
		},
		{
			MethodName: "InterfaceAgentInit",
			Handler:    _AiService_InterfaceAgentInit_Handler,
		},
		{
			MethodName: "UpdateVscodeProfile",
			Handler:    _AiService_UpdateVscodeProfile_Handler,
		},
		{
			MethodName: "TaskInit",
			Handler:    _AiService_TaskInit_Handler,
		},
		{
			MethodName: "TaskPause",
			Handler:    _AiService_TaskPause_Handler,
		},
		{
			MethodName: "TaskInfo",
			Handler:    _AiService_TaskInfo_Handler,
		},
		{
			MethodName: "TaskSendMessage",
			Handler:    _AiService_TaskSendMessage_Handler,
		},
		{
			MethodName: "TaskProvideResult",
			Handler:    _AiService_TaskProvideResult_Handler,
		},
		{
			MethodName: "CreateExperimentalIndex",
			Handler:    _AiService_CreateExperimentalIndex_Handler,
		},
		{
			MethodName: "ListExperimentalIndexFiles",
			Handler:    _AiService_ListExperimentalIndexFiles_Handler,
		},
		{
			MethodName: "RegisterFileToIndex",
			Handler:    _AiService_RegisterFileToIndex_Handler,
		},
		{
			MethodName: "SetupIndexDependencies",
			Handler:    _AiService_SetupIndexDependencies_Handler,
		},
		{
			MethodName: "ComputeIndexTopoSort",
			Handler:    _AiService_ComputeIndexTopoSort_Handler,
		},
		{
			MethodName: "ChooseCodeReferences",
			Handler:    _AiService_ChooseCodeReferences_Handler,
		},
		{
			MethodName: "RegisterCodeReferences",
			Handler:    _AiService_RegisterCodeReferences_Handler,
		},
		{
			MethodName: "ExtractPaths",
			Handler:    _AiService_ExtractPaths_Handler,
		},
		{
			MethodName: "SummarizeWithReferences",
			Handler:    _AiService_SummarizeWithReferences_Handler,
		},
		{
			MethodName: "DocumentationQuery",
			Handler:    _AiService_DocumentationQuery_Handler,
		},
		{
			MethodName: "AvailableDocs",
			Handler:    _AiService_AvailableDocs_Handler,
		},
		{
			MethodName: "ReportFeedback",
			Handler:    _AiService_ReportFeedback_Handler,
		},
		{
			MethodName: "ReportBug",
			Handler:    _AiService_ReportBug_Handler,
		},
		{
			MethodName: "GenerateTldr",
			Handler:    _AiService_GenerateTldr_Handler,
		},
		{
			MethodName: "RerankResults",
			Handler:    _AiService_RerankResults_Handler,
		},
		{
			MethodName: "ModelQuery",
			Handler:    _AiService_ModelQuery_Handler,
		},
		{
			MethodName: "IntentPrediction",
			Handler:    _AiService_IntentPrediction_Handler,
		},
		{
			MethodName: "GetChatSuggestions",
			Handler:    _AiService_GetChatSuggestions_Handler,
		},
		{
			MethodName: "GetUserInstructions",
			Handler:    _AiService_GetUserInstructions_Handler,
		},
		{
			MethodName: "CheckFeatureStatus",
			Handler:    _AiService_CheckFeatureStatus_Handler,
		},
		{
			MethodName: "CheckFeaturesStatus",
			Handler:    _AiService_CheckFeaturesStatus_Handler,
		},
		{
			MethodName: "CheckFeatureStatusUnauthenticated",
			Handler:    _AiService_CheckFeatureStatusUnauthenticated_Handler,
		},
		{
			MethodName: "GetEffectiveTokenLimit",
			Handler:    _AiService_GetEffectiveTokenLimit_Handler,
		},
		{
			MethodName: "GetContextScores",
			Handler:    _AiService_GetContextScores_Handler,
		},
		{
			MethodName: "CppConfig",
			Handler:    _AiService_CppConfig_Handler,
		},
		{
			MethodName: "CppEditHistoryStatus",
			Handler:    _AiService_CppEditHistoryStatus_Handler,
		},
		{
			MethodName: "CppAppend",
			Handler:    _AiService_CppAppend_Handler,
		},
		{
			MethodName: "RefreshTabContext",
			Handler:    _AiService_RefreshTabContext_Handler,
		},
		{
			MethodName: "CheckNumberConfig",
			Handler:    _AiService_CheckNumberConfig_Handler,
		},
		{
			MethodName: "CheckNumberConfigUnauthenticated",
			Handler:    _AiService_CheckNumberConfigUnauthenticated_Handler,
		},
		{
			MethodName: "CheckNumberConfigs",
			Handler:    _AiService_CheckNumberConfigs_Handler,
		},
		{
			MethodName: "AcknowledgeGracePeriodDisclaimer",
			Handler:    _AiService_AcknowledgeGracePeriodDisclaimer_Handler,
		},
		{
			MethodName: "LogUserLintReply",
			Handler:    _AiService_LogUserLintReply_Handler,
		},
		{
			MethodName: "LogLinterExplicitUserFeedback",
			Handler:    _AiService_LogLinterExplicitUserFeedback_Handler,
		},
		{
			MethodName: "ReportInlineAction",
			Handler:    _AiService_ReportInlineAction_Handler,
		},
		{
			MethodName: "ToCamelCase",
			Handler:    _AiService_ToCamelCase_Handler,
		},
		{
			MethodName: "ReportGenerationFeedback",
			Handler:    _AiService_ReportGenerationFeedback_Handler,
		},
		{
			MethodName: "GetThoughtAnnotation",
			Handler:    _AiService_GetThoughtAnnotation_Handler,
		},
		{
			MethodName: "IsCursorPredictionEnabled",
			Handler:    _AiService_IsCursorPredictionEnabled_Handler,
		},
		{
			MethodName: "GetCppEditClassification",
			Handler:    _AiService_GetCppEditClassification_Handler,
		},
		{
			MethodName: "GetTerminalCompletion",
			Handler:    _AiService_GetTerminalCompletion_Handler,
		},
		{
			MethodName: "TakeNotesOnCommitDiff",
			Handler:    _AiService_TakeNotesOnCommitDiff_Handler,
		},
		{
			MethodName: "BulkEmbed",
			Handler:    _AiService_BulkEmbed_Handler,
		},
		{
			MethodName: "CalculateAutoSelection",
			Handler:    _AiService_CalculateAutoSelection_Handler,
		},
		{
			MethodName: "GetAtSymbolSuggestions",
			Handler:    _AiService_GetAtSymbolSuggestions_Handler,
		},
		{
			MethodName: "GetCodebaseQuestions",
			Handler:    _AiService_GetCodebaseQuestions_Handler,
		},
		{
			MethodName: "CppEditHistoryAppend",
			Handler:    _AiService_CppEditHistoryAppend_Handler,
		},
		{
			MethodName: "DevOnlyGetPastRequestIds",
			Handler:    _AiService_DevOnlyGetPastRequestIds_Handler,
		},
		{
			MethodName: "GetFilesForComposer",
			Handler:    _AiService_GetFilesForComposer_Handler,
		},
		{
			MethodName: "TryParseTypeScriptTreeSitter",
			Handler:    _AiService_TryParseTypeScriptTreeSitter_Handler,
		},
		{
			MethodName: "NameTab",
			Handler:    _AiService_NameTab_Handler,
		},
		{
			MethodName: "IsTerminalFinishedV2",
			Handler:    _AiService_IsTerminalFinishedV2_Handler,
		},
		{
			MethodName: "TestModelStatus",
			Handler:    _AiService_TestModelStatus_Handler,
		},
		{
			MethodName: "FindBugs",
			Handler:    _AiService_FindBugs_Handler,
		},
		{
			MethodName: "ContextReranking",
			Handler:    _AiService_ContextReranking_Handler,
		},
		{
			MethodName: "AutoContext",
			Handler:    _AiService_AutoContext_Handler,
		},
		{
			MethodName: "WriteGitCommitMessage",
			Handler:    _AiService_WriteGitCommitMessage_Handler,
		},
		{
			MethodName: "WriteGitBranchName",
			Handler:    _AiService_WriteGitBranchName_Handler,
		},
		{
			MethodName: "CheckBugBotPrice",
			Handler:    _AiService_CheckBugBotPrice_Handler,
		},
		{
			MethodName: "CheckBugBotTelemetryHealthy",
			Handler:    _AiService_CheckBugBotTelemetryHealthy_Handler,
		},
		{
			MethodName: "RecordIdeBugReaction",
			Handler:    _AiService_RecordIdeBugReaction_Handler,
		},
		{
			MethodName: "GetSuggestedBugBotIterations",
			Handler:    _AiService_GetSuggestedBugBotIterations_Handler,
		},
		{
			MethodName: "GetEditorBugbotAutoRunStatus",
			Handler:    _AiService_GetEditorBugbotAutoRunStatus_Handler,
		},
		{
			MethodName: "GetModelLabels",
			Handler:    _AiService_GetModelLabels_Handler,
		},
		{
			MethodName: "GetLastDefaultModelNudge",
			Handler:    _AiService_GetLastDefaultModelNudge_Handler,
		},
		{
			MethodName: "GetDefaultModelNudgeData",
			Handler:    _AiService_GetDefaultModelNudgeData_Handler,
		},
		{
			MethodName: "GetDefaultModel",
			Handler:    _AiService_GetDefaultModel_Handler,
		},
		{
			MethodName: "ReportCommitAiAnalytics",
			Handler:    _AiService_ReportCommitAiAnalytics_Handler,
		},
		{
			MethodName: "TestBedrockCredentials",
			Handler:    _AiService_TestBedrockCredentials_Handler,
		},
		{
			MethodName: "ReportAiCodeChangeMetrics",
			Handler:    _AiService_ReportAiCodeChangeMetrics_Handler,
		},
		{
			MethodName: "ReportProcessMetrics",
			Handler:    _AiService_ReportProcessMetrics_Handler,
		},
		{
			MethodName: "ReportProcessMetricsV2",
			Handler:    _AiService_ReportProcessMetricsV2_Handler,
		},
		{
			MethodName: "ReportClientNumericMetrics",
			Handler:    _AiService_ReportClientNumericMetrics_Handler,
		},
		{
			MethodName: "PotentiallyGenerateMemory",
			Handler:    _AiService_PotentiallyGenerateMemory_Handler,
		},
		{
			MethodName: "KnowledgeBaseAdd",
			Handler:    _AiService_KnowledgeBaseAdd_Handler,
		},
		{
			MethodName: "KnowledgeBaseList",
			Handler:    _AiService_KnowledgeBaseList_Handler,
		},
		{
			MethodName: "KnowledgeBaseRemove",
			Handler:    _AiService_KnowledgeBaseRemove_Handler,
		},
		{
			MethodName: "KnowledgeBaseUpdate",
			Handler:    _AiService_KnowledgeBaseUpdate_Handler,
		},
		{
			MethodName: "FetchRelevantKnowledgeForConversation",
			Handler:    _AiService_FetchRelevantKnowledgeForConversation_Handler,
		},
		{
			MethodName: "InferBackgroundComposerScripts",
			Handler:    _AiService_InferBackgroundComposerScripts_Handler,
		},
		{
			MethodName: "GetBackgroundComposerFeedbackLink",
			Handler:    _AiService_GetBackgroundComposerFeedbackLink_Handler,
		},
		{
			MethodName: "GetUsableModels",
			Handler:    _AiService_GetUsableModels_Handler,
		},
		{
			MethodName: "GetDefaultModelForCli",
			Handler:    _AiService_GetDefaultModelForCli_Handler,
		},
		{
			MethodName: "NameAgent",
			Handler:    _AiService_NameAgent_Handler,
		},
		{
			MethodName: "EvaluatePromptHook",
			Handler:    _AiService_EvaluatePromptHook_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChatTryReallyHard",
			Handler:       _AiService_StreamChatTryReallyHard_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamComposer",
			Handler:       _AiService_StreamComposer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamComposerContext",
			Handler:       _AiService_StreamComposerContext_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPotentialLocs",
			Handler:       _AiService_StreamPotentialLocs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPotentialLocsUnderneath",
			Handler:       _AiService_StreamPotentialLocsUnderneath_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPotentialLocsInitialQueries",
			Handler:       _AiService_StreamPotentialLocsInitialQueries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChat",
			Handler:       _AiService_StreamChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChatWeb",
			Handler:       _AiService_StreamChatWeb_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamEdit",
			Handler:       _AiService_StreamEdit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamFastEdit",
			Handler:       _AiService_StreamFastEdit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamGenerate",
			Handler:       _AiService_StreamGenerate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamInlineLongCompletion",
			Handler:       _AiService_StreamInlineLongCompletion_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SlashEdit",
			Handler:       _AiService_SlashEdit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SlashEditFollowUpWithPreviousEdits",
			Handler:       _AiService_SlashEditFollowUpWithPreviousEdits_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAiPreviews",
			Handler:       _AiService_StreamAiPreviews_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamReview",
			Handler:       _AiService_StreamReview_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamReviewChat",
			Handler:       _AiService_StreamReviewChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamDoThisForMe",
			Handler:       _AiService_StreamDoThisForMe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChatToolformer",
			Handler:       _AiService_StreamChatToolformer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChatToolformerContinue",
			Handler:       _AiService_StreamChatToolformerContinue_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamInterfaceAgentStatus",
			Handler:       _AiService_StreamInterfaceAgentStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskGetInterfaceAgentStatus",
			Handler:       _AiService_TaskGetInterfaceAgentStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskStreamLog",
			Handler:       _AiService_TaskStreamLog_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListenExperimentalIndex",
			Handler:       _AiService_ListenExperimentalIndex_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChatDeepContext",
			Handler:       _AiService_StreamChatDeepContext_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChatContext",
			Handler:       _AiService_StreamChatContext_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TaskStreamChatContext",
			Handler:       _AiService_TaskStreamChatContext_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ModelQueryV2",
			Handler:       _AiService_ModelQueryV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCursorTutor",
			Handler:       _AiService_StreamCursorTutor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCpp",
			Handler:       _AiService_StreamCpp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTerminalAutocomplete",
			Handler:       _AiService_StreamTerminalAutocomplete_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPseudocodeGenerator",
			Handler:       _AiService_StreamPseudocodeGenerator_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPseudocodeMapper",
			Handler:       _AiService_StreamPseudocodeMapper_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAiLintBug",
			Handler:       _AiService_StreamAiLintBug_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamAiCursorHelp",
			Handler:       _AiService_StreamAiCursorHelp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamFixMarkers",
			Handler:       _AiService_StreamFixMarkers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPriomptPrompt",
			Handler:       _AiService_StreamPriomptPrompt_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamLint",
			Handler:       _AiService_StreamLint_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamNewLintRule",
			Handler:       _AiService_StreamNewLintRule_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AiProject",
			Handler:       _AiService_AiProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamWebCmdKV1",
			Handler:       _AiService_StreamWebCmdKV1_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamNextCursorPrediction",
			Handler:       _AiService_StreamNextCursorPrediction_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BackgroundCmdKEval",
			Handler:       _AiService_BackgroundCmdKEval_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BackgroundCmdK",
			Handler:       _AiService_BackgroundCmdK_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCursorMotion",
			Handler:       _AiService_StreamCursorMotion_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBugBot",
			Handler:       _AiService_StreamBugBot_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBugBotAgentic",
			Handler:       _AiService_StreamBugBotAgentic_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamBugBotAgenticSSE",
			Handler:       _AiService_StreamBugBotAgenticSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBugBotAgenticPoll",
			Handler:       _AiService_StreamBugBotAgenticPoll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUiBestOfNJudge",
			Handler:       _AiService_StreamUiBestOfNJudge_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamUiBestOfNJudgeSSE",
			Handler:       _AiService_StreamUiBestOfNJudgeSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUiBestOfNJudgePoll",
			Handler:       _AiService_StreamUiBestOfNJudgePoll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TestBidi",
			Handler:       _AiService_TestBidi_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamDiffReview",
			Handler:       _AiService_StreamDiffReview_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamDiffReviewByFile",
			Handler:       _AiService_StreamDiffReviewByFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamComposerEnhancer",
			Handler:       _AiService_StreamComposerEnhancer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamComposerEnhancerSSE",
			Handler:       _AiService_StreamComposerEnhancerSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamComposerEnhancerPoll",
			Handler:       _AiService_StreamComposerEnhancerPoll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamStt",
			Handler:       _AiService_StreamStt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamSttSSE",
			Handler:       _AiService_StreamSttSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSttPoll",
			Handler:       _AiService_StreamSttPoll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	AnalyticsService_TrackEvents_FullMethodName        = "/aiserver.v1.AnalyticsService/TrackEvents"
	AnalyticsService_Batch_FullMethodName              = "/aiserver.v1.AnalyticsService/Batch"
	AnalyticsService_BootstrapStatsig_FullMethodName   = "/aiserver.v1.AnalyticsService/BootstrapStatsig"
	AnalyticsService_SubmitLogs_FullMethodName         = "/aiserver.v1.AnalyticsService/SubmitLogs"
	AnalyticsService_IngestConversation_FullMethodName = "/aiserver.v1.AnalyticsService/IngestConversation"
)

// AnalyticsServiceClient is the client API for AnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AnalyticsService (var: Vze)
type AnalyticsServiceClient interface {
	TrackEvents(ctx context.Context, in *TrackEventsRequest, opts ...grpc.CallOption) (*TrackEventsResponse, error)
	Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error)
	BootstrapStatsig(ctx context.Context, in *BootstrapStatsigRequest, opts ...grpc.CallOption) (*BootstrapStatsigResponse, error)
	SubmitLogs(ctx context.Context, in *SubmitLogsRequest, opts ...grpc.CallOption) (*SubmitLogsResponse, error)
	IngestConversation(ctx context.Context, in *IngestConversationRequest, opts ...grpc.CallOption) (*IngestConversationResponse, error)
}

type analyticsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalyticsServiceClient(cc grpc.ClientConnInterface) AnalyticsServiceClient {
	return &analyticsServiceClient{cc}
}

func (c *analyticsServiceClient) TrackEvents(ctx context.Context, in *TrackEventsRequest, opts ...grpc.CallOption) (*TrackEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrackEventsResponse)
	err := c.cc.Invoke(ctx, AnalyticsService_TrackEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticsServiceClient) Batch(ctx context.Context, in *BatchRequest, opts ...grpc.CallOption) (*BatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchResponse)
	err := c.cc.Invoke(ctx, AnalyticsService_Batch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticsServiceClient) BootstrapStatsig(ctx context.Context, in *BootstrapStatsigRequest, opts ...grpc.CallOption) (*BootstrapStatsigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BootstrapStatsigResponse)
	err := c.cc.Invoke(ctx, AnalyticsService_BootstrapStatsig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticsServiceClient) SubmitLogs(ctx context.Context, in *SubmitLogsRequest, opts ...grpc.CallOption) (*SubmitLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitLogsResponse)
	err := c.cc.Invoke(ctx, AnalyticsService_SubmitLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *analyticsServiceClient) IngestConversation(ctx context.Context, in *IngestConversationRequest, opts ...grpc.CallOption) (*IngestConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestConversationResponse)
	err := c.cc.Invoke(ctx, AnalyticsService_IngestConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnalyticsServiceServer is the server API for AnalyticsService service.
// All implementations must embed UnimplementedAnalyticsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AnalyticsService (var: Vze)
type AnalyticsServiceServer interface {
	TrackEvents(context.Context, *TrackEventsRequest) (*TrackEventsResponse, error)
	Batch(context.Context, *BatchRequest) (*BatchResponse, error)
	BootstrapStatsig(context.Context, *BootstrapStatsigRequest) (*BootstrapStatsigResponse, error)
	SubmitLogs(context.Context, *SubmitLogsRequest) (*SubmitLogsResponse, error)
	IngestConversation(context.Context, *IngestConversationRequest) (*IngestConversationResponse, error)
	mustEmbedUnimplementedAnalyticsServiceServer()
}

// UnimplementedAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAnalyticsServiceServer struct{}

func (UnimplementedAnalyticsServiceServer) TrackEvents(context.Context, *TrackEventsRequest) (*TrackEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TrackEvents not implemented")
}
func (UnimplementedAnalyticsServiceServer) Batch(context.Context, *BatchRequest) (*BatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Batch not implemented")
}
func (UnimplementedAnalyticsServiceServer) BootstrapStatsig(context.Context, *BootstrapStatsigRequest) (*BootstrapStatsigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BootstrapStatsig not implemented")
}
func (UnimplementedAnalyticsServiceServer) SubmitLogs(context.Context, *SubmitLogsRequest) (*SubmitLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitLogs not implemented")
}
func (UnimplementedAnalyticsServiceServer) IngestConversation(context.Context, *IngestConversationRequest) (*IngestConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IngestConversation not implemented")
}
func (UnimplementedAnalyticsServiceServer) mustEmbedUnimplementedAnalyticsServiceServer() {}
func (UnimplementedAnalyticsServiceServer) testEmbeddedByValue()                          {}

// UnsafeAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalyticsServiceServer will
// result in compilation errors.
type UnsafeAnalyticsServiceServer interface {
	mustEmbedUnimplementedAnalyticsServiceServer()
}

func RegisterAnalyticsServiceServer(s grpc.ServiceRegistrar, srv AnalyticsServiceServer) {
	// If the following call panics, it indicates UnimplementedAnalyticsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AnalyticsService_ServiceDesc, srv)
}

func _AnalyticsService_TrackEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticsServiceServer).TrackEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnalyticsService_TrackEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticsServiceServer).TrackEvents(ctx, req.(*TrackEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnalyticsService_Batch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticsServiceServer).Batch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnalyticsService_Batch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticsServiceServer).Batch(ctx, req.(*BatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnalyticsService_BootstrapStatsig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapStatsigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticsServiceServer).BootstrapStatsig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnalyticsService_BootstrapStatsig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticsServiceServer).BootstrapStatsig(ctx, req.(*BootstrapStatsigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnalyticsService_SubmitLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticsServiceServer).SubmitLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnalyticsService_SubmitLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticsServiceServer).SubmitLogs(ctx, req.(*SubmitLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AnalyticsService_IngestConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnalyticsServiceServer).IngestConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AnalyticsService_IngestConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnalyticsServiceServer).IngestConversation(ctx, req.(*IngestConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AnalyticsService_ServiceDesc is the grpc.ServiceDesc for AnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnalyticsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AnalyticsService",
	HandlerType: (*AnalyticsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TrackEvents",
			Handler:    _AnalyticsService_TrackEvents_Handler,
		},
		{
			MethodName: "Batch",
			Handler:    _AnalyticsService_Batch_Handler,
		},
		{
			MethodName: "BootstrapStatsig",
			Handler:    _AnalyticsService_BootstrapStatsig_Handler,
		},
		{
			MethodName: "SubmitLogs",
			Handler:    _AnalyticsService_SubmitLogs_Handler,
		},
		{
			MethodName: "IngestConversation",
			Handler:    _AnalyticsService_IngestConversation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	AsyncPlatformService_CreatePlatformWorkflow_FullMethodName   = "/aiserver.v1.AsyncPlatformService/CreatePlatformWorkflow"
	AsyncPlatformService_ListPlatformWorkflows_FullMethodName    = "/aiserver.v1.AsyncPlatformService/ListPlatformWorkflows"
	AsyncPlatformService_GetPlatformWorkflow_FullMethodName      = "/aiserver.v1.AsyncPlatformService/GetPlatformWorkflow"
	AsyncPlatformService_UpdatePlatformWorkflow_FullMethodName   = "/aiserver.v1.AsyncPlatformService/UpdatePlatformWorkflow"
	AsyncPlatformService_DeletePlatformWorkflow_FullMethodName   = "/aiserver.v1.AsyncPlatformService/DeletePlatformWorkflow"
	AsyncPlatformService_TestPlatformWorkflow_FullMethodName     = "/aiserver.v1.AsyncPlatformService/TestPlatformWorkflow"
	AsyncPlatformService_ListPlatformWorkflowRuns_FullMethodName = "/aiserver.v1.AsyncPlatformService/ListPlatformWorkflowRuns"
	AsyncPlatformService_GetPlatformDepMatrix_FullMethodName     = "/aiserver.v1.AsyncPlatformService/GetPlatformDepMatrix"
)

// AsyncPlatformServiceClient is the client API for AsyncPlatformService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AsyncPlatformService (var: zze)
type AsyncPlatformServiceClient interface {
	CreatePlatformWorkflow(ctx context.Context, in *CreatePlatformWorkflowRequest, opts ...grpc.CallOption) (*CreatePlatformWorkflowResponse, error)
	ListPlatformWorkflows(ctx context.Context, in *ListPlatformWorkflowsRequest, opts ...grpc.CallOption) (*ListPlatformWorkflowsResponse, error)
	GetPlatformWorkflow(ctx context.Context, in *GetPlatformWorkflowRequest, opts ...grpc.CallOption) (*GetPlatformWorkflowResponse, error)
	UpdatePlatformWorkflow(ctx context.Context, in *UpdatePlatformWorkflowRequest, opts ...grpc.CallOption) (*UpdatePlatformWorkflowResponse, error)
	DeletePlatformWorkflow(ctx context.Context, in *DeletePlatformWorkflowRequest, opts ...grpc.CallOption) (*DeletePlatformWorkflowResponse, error)
	TestPlatformWorkflow(ctx context.Context, in *TestPlatformWorkflowRequest, opts ...grpc.CallOption) (*TestPlatformWorkflowResponse, error)
	ListPlatformWorkflowRuns(ctx context.Context, in *ListPlatformWorkflowRunsRequest, opts ...grpc.CallOption) (*ListPlatformWorkflowRunsResponse, error)
	GetPlatformDepMatrix(ctx context.Context, in *GetPlatformDepMatrixRequest, opts ...grpc.CallOption) (*GetPlatformDepMatrixResponse, error)
}

type asyncPlatformServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAsyncPlatformServiceClient(cc grpc.ClientConnInterface) AsyncPlatformServiceClient {
	return &asyncPlatformServiceClient{cc}
}

func (c *asyncPlatformServiceClient) CreatePlatformWorkflow(ctx context.Context, in *CreatePlatformWorkflowRequest, opts ...grpc.CallOption) (*CreatePlatformWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePlatformWorkflowResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_CreatePlatformWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) ListPlatformWorkflows(ctx context.Context, in *ListPlatformWorkflowsRequest, opts ...grpc.CallOption) (*ListPlatformWorkflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPlatformWorkflowsResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_ListPlatformWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) GetPlatformWorkflow(ctx context.Context, in *GetPlatformWorkflowRequest, opts ...grpc.CallOption) (*GetPlatformWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlatformWorkflowResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_GetPlatformWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) UpdatePlatformWorkflow(ctx context.Context, in *UpdatePlatformWorkflowRequest, opts ...grpc.CallOption) (*UpdatePlatformWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePlatformWorkflowResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_UpdatePlatformWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) DeletePlatformWorkflow(ctx context.Context, in *DeletePlatformWorkflowRequest, opts ...grpc.CallOption) (*DeletePlatformWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePlatformWorkflowResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_DeletePlatformWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) TestPlatformWorkflow(ctx context.Context, in *TestPlatformWorkflowRequest, opts ...grpc.CallOption) (*TestPlatformWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestPlatformWorkflowResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_TestPlatformWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) ListPlatformWorkflowRuns(ctx context.Context, in *ListPlatformWorkflowRunsRequest, opts ...grpc.CallOption) (*ListPlatformWorkflowRunsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPlatformWorkflowRunsResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_ListPlatformWorkflowRuns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *asyncPlatformServiceClient) GetPlatformDepMatrix(ctx context.Context, in *GetPlatformDepMatrixRequest, opts ...grpc.CallOption) (*GetPlatformDepMatrixResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlatformDepMatrixResponse)
	err := c.cc.Invoke(ctx, AsyncPlatformService_GetPlatformDepMatrix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AsyncPlatformServiceServer is the server API for AsyncPlatformService service.
// All implementations must embed UnimplementedAsyncPlatformServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AsyncPlatformService (var: zze)
type AsyncPlatformServiceServer interface {
	CreatePlatformWorkflow(context.Context, *CreatePlatformWorkflowRequest) (*CreatePlatformWorkflowResponse, error)
	ListPlatformWorkflows(context.Context, *ListPlatformWorkflowsRequest) (*ListPlatformWorkflowsResponse, error)
	GetPlatformWorkflow(context.Context, *GetPlatformWorkflowRequest) (*GetPlatformWorkflowResponse, error)
	UpdatePlatformWorkflow(context.Context, *UpdatePlatformWorkflowRequest) (*UpdatePlatformWorkflowResponse, error)
	DeletePlatformWorkflow(context.Context, *DeletePlatformWorkflowRequest) (*DeletePlatformWorkflowResponse, error)
	TestPlatformWorkflow(context.Context, *TestPlatformWorkflowRequest) (*TestPlatformWorkflowResponse, error)
	ListPlatformWorkflowRuns(context.Context, *ListPlatformWorkflowRunsRequest) (*ListPlatformWorkflowRunsResponse, error)
	GetPlatformDepMatrix(context.Context, *GetPlatformDepMatrixRequest) (*GetPlatformDepMatrixResponse, error)
	mustEmbedUnimplementedAsyncPlatformServiceServer()
}

// UnimplementedAsyncPlatformServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAsyncPlatformServiceServer struct{}

func (UnimplementedAsyncPlatformServiceServer) CreatePlatformWorkflow(context.Context, *CreatePlatformWorkflowRequest) (*CreatePlatformWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePlatformWorkflow not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) ListPlatformWorkflows(context.Context, *ListPlatformWorkflowsRequest) (*ListPlatformWorkflowsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPlatformWorkflows not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) GetPlatformWorkflow(context.Context, *GetPlatformWorkflowRequest) (*GetPlatformWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlatformWorkflow not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) UpdatePlatformWorkflow(context.Context, *UpdatePlatformWorkflowRequest) (*UpdatePlatformWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePlatformWorkflow not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) DeletePlatformWorkflow(context.Context, *DeletePlatformWorkflowRequest) (*DeletePlatformWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePlatformWorkflow not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) TestPlatformWorkflow(context.Context, *TestPlatformWorkflowRequest) (*TestPlatformWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestPlatformWorkflow not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) ListPlatformWorkflowRuns(context.Context, *ListPlatformWorkflowRunsRequest) (*ListPlatformWorkflowRunsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPlatformWorkflowRuns not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) GetPlatformDepMatrix(context.Context, *GetPlatformDepMatrixRequest) (*GetPlatformDepMatrixResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlatformDepMatrix not implemented")
}
func (UnimplementedAsyncPlatformServiceServer) mustEmbedUnimplementedAsyncPlatformServiceServer() {}
func (UnimplementedAsyncPlatformServiceServer) testEmbeddedByValue()                              {}

// UnsafeAsyncPlatformServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AsyncPlatformServiceServer will
// result in compilation errors.
type UnsafeAsyncPlatformServiceServer interface {
	mustEmbedUnimplementedAsyncPlatformServiceServer()
}

func RegisterAsyncPlatformServiceServer(s grpc.ServiceRegistrar, srv AsyncPlatformServiceServer) {
	// If the following call panics, it indicates UnimplementedAsyncPlatformServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AsyncPlatformService_ServiceDesc, srv)
}

func _AsyncPlatformService_CreatePlatformWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePlatformWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).CreatePlatformWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_CreatePlatformWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).CreatePlatformWorkflow(ctx, req.(*CreatePlatformWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_ListPlatformWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlatformWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).ListPlatformWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_ListPlatformWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).ListPlatformWorkflows(ctx, req.(*ListPlatformWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_GetPlatformWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlatformWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).GetPlatformWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_GetPlatformWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).GetPlatformWorkflow(ctx, req.(*GetPlatformWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_UpdatePlatformWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePlatformWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).UpdatePlatformWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_UpdatePlatformWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).UpdatePlatformWorkflow(ctx, req.(*UpdatePlatformWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_DeletePlatformWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePlatformWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).DeletePlatformWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_DeletePlatformWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).DeletePlatformWorkflow(ctx, req.(*DeletePlatformWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_TestPlatformWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestPlatformWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).TestPlatformWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_TestPlatformWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).TestPlatformWorkflow(ctx, req.(*TestPlatformWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_ListPlatformWorkflowRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlatformWorkflowRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).ListPlatformWorkflowRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_ListPlatformWorkflowRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).ListPlatformWorkflowRuns(ctx, req.(*ListPlatformWorkflowRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AsyncPlatformService_GetPlatformDepMatrix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlatformDepMatrixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AsyncPlatformServiceServer).GetPlatformDepMatrix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AsyncPlatformService_GetPlatformDepMatrix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AsyncPlatformServiceServer).GetPlatformDepMatrix(ctx, req.(*GetPlatformDepMatrixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AsyncPlatformService_ServiceDesc is the grpc.ServiceDesc for AsyncPlatformService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AsyncPlatformService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AsyncPlatformService",
	HandlerType: (*AsyncPlatformServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePlatformWorkflow",
			Handler:    _AsyncPlatformService_CreatePlatformWorkflow_Handler,
		},
		{
			MethodName: "ListPlatformWorkflows",
			Handler:    _AsyncPlatformService_ListPlatformWorkflows_Handler,
		},
		{
			MethodName: "GetPlatformWorkflow",
			Handler:    _AsyncPlatformService_GetPlatformWorkflow_Handler,
		},
		{
			MethodName: "UpdatePlatformWorkflow",
			Handler:    _AsyncPlatformService_UpdatePlatformWorkflow_Handler,
		},
		{
			MethodName: "DeletePlatformWorkflow",
			Handler:    _AsyncPlatformService_DeletePlatformWorkflow_Handler,
		},
		{
			MethodName: "TestPlatformWorkflow",
			Handler:    _AsyncPlatformService_TestPlatformWorkflow_Handler,
		},
		{
			MethodName: "ListPlatformWorkflowRuns",
			Handler:    _AsyncPlatformService_ListPlatformWorkflowRuns_Handler,
		},
		{
			MethodName: "GetPlatformDepMatrix",
			Handler:    _AsyncPlatformService_GetPlatformDepMatrix_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	AuthService_GetEmail_FullMethodName           = "/aiserver.v1.AuthService/GetEmail"
	AuthService_GetUserMeta_FullMethodName        = "/aiserver.v1.AuthService/GetUserMeta"
	AuthService_EmailValid_FullMethodName         = "/aiserver.v1.AuthService/EmailValid"
	AuthService_DownloadUpdate_FullMethodName     = "/aiserver.v1.AuthService/DownloadUpdate"
	AuthService_MarkPrivacy_FullMethodName        = "/aiserver.v1.AuthService/MarkPrivacy"
	AuthService_SwitchCmdKFraction_FullMethodName = "/aiserver.v1.AuthService/SwitchCmdKFraction"
	AuthService_GetCustomerId_FullMethodName      = "/aiserver.v1.AuthService/GetCustomerId"
	AuthService_SetPrivacyMode_FullMethodName     = "/aiserver.v1.AuthService/SetPrivacyMode"
	AuthService_GetSessionToken_FullMethodName    = "/aiserver.v1.AuthService/GetSessionToken"
	AuthService_CheckSessionToken_FullMethodName  = "/aiserver.v1.AuthService/CheckSessionToken"
	AuthService_ListActiveSessions_FullMethodName = "/aiserver.v1.AuthService/ListActiveSessions"
	AuthService_RevokeSession_FullMethodName      = "/aiserver.v1.AuthService/RevokeSession"
	AuthService_ListJwtPublicKeys_FullMethodName  = "/aiserver.v1.AuthService/ListJwtPublicKeys"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AuthService (var: Yze)
type AuthServiceClient interface {
	GetEmail(ctx context.Context, in *GetEmailRequest, opts ...grpc.CallOption) (*GetEmailResponse, error)
	GetUserMeta(ctx context.Context, in *GetUserMetaRequest, opts ...grpc.CallOption) (*GetUserMetaResponse, error)
	EmailValid(ctx context.Context, in *EmailValidRequest, opts ...grpc.CallOption) (*EmailValidResponse, error)
	DownloadUpdate(ctx context.Context, in *DownloadUpdateRequest, opts ...grpc.CallOption) (*DownloadUpdateResponse, error)
	MarkPrivacy(ctx context.Context, in *MarkPrivacyRequest, opts ...grpc.CallOption) (*MarkPrivacyResponse, error)
	SwitchCmdKFraction(ctx context.Context, in *SwitchCmdKFractionRequest, opts ...grpc.CallOption) (*SwitchCmdKFractionResponse, error)
	GetCustomerId(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerIdResponse, error)
	SetPrivacyMode(ctx context.Context, in *SetPrivacyModeRequest, opts ...grpc.CallOption) (*SetPrivacyModeResponse, error)
	GetSessionToken(ctx context.Context, in *GetSessionTokenRequest, opts ...grpc.CallOption) (*GetSessionTokenResponse, error)
	CheckSessionToken(ctx context.Context, in *CheckSessionTokenRequest, opts ...grpc.CallOption) (*CheckSessionTokenResponse, error)
	ListActiveSessions(ctx context.Context, in *ListActiveSessionsRequest, opts ...grpc.CallOption) (*ListActiveSessionsResponse, error)
	RevokeSession(ctx context.Context, in *RevokeSessionRequest, opts ...grpc.CallOption) (*RevokeSessionResponse, error)
	ListJwtPublicKeys(ctx context.Context, in *ListJwtPublicKeysRequest, opts ...grpc.CallOption) (*ListJwtPublicKeysResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) GetEmail(ctx context.Context, in *GetEmailRequest, opts ...grpc.CallOption) (*GetEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEmailResponse)
	err := c.cc.Invoke(ctx, AuthService_GetEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetUserMeta(ctx context.Context, in *GetUserMetaRequest, opts ...grpc.CallOption) (*GetUserMetaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserMetaResponse)
	err := c.cc.Invoke(ctx, AuthService_GetUserMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) EmailValid(ctx context.Context, in *EmailValidRequest, opts ...grpc.CallOption) (*EmailValidResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailValidResponse)
	err := c.cc.Invoke(ctx, AuthService_EmailValid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DownloadUpdate(ctx context.Context, in *DownloadUpdateRequest, opts ...grpc.CallOption) (*DownloadUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadUpdateResponse)
	err := c.cc.Invoke(ctx, AuthService_DownloadUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) MarkPrivacy(ctx context.Context, in *MarkPrivacyRequest, opts ...grpc.CallOption) (*MarkPrivacyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkPrivacyResponse)
	err := c.cc.Invoke(ctx, AuthService_MarkPrivacy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SwitchCmdKFraction(ctx context.Context, in *SwitchCmdKFractionRequest, opts ...grpc.CallOption) (*SwitchCmdKFractionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchCmdKFractionResponse)
	err := c.cc.Invoke(ctx, AuthService_SwitchCmdKFraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetCustomerId(ctx context.Context, in *CustomerIdRequest, opts ...grpc.CallOption) (*CustomerIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerIdResponse)
	err := c.cc.Invoke(ctx, AuthService_GetCustomerId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetPrivacyMode(ctx context.Context, in *SetPrivacyModeRequest, opts ...grpc.CallOption) (*SetPrivacyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPrivacyModeResponse)
	err := c.cc.Invoke(ctx, AuthService_SetPrivacyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSessionToken(ctx context.Context, in *GetSessionTokenRequest, opts ...grpc.CallOption) (*GetSessionTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_GetSessionToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CheckSessionToken(ctx context.Context, in *CheckSessionTokenRequest, opts ...grpc.CallOption) (*CheckSessionTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckSessionTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_CheckSessionToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListActiveSessions(ctx context.Context, in *ListActiveSessionsRequest, opts ...grpc.CallOption) (*ListActiveSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActiveSessionsResponse)
	err := c.cc.Invoke(ctx, AuthService_ListActiveSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RevokeSession(ctx context.Context, in *RevokeSessionRequest, opts ...grpc.CallOption) (*RevokeSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeSessionResponse)
	err := c.cc.Invoke(ctx, AuthService_RevokeSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListJwtPublicKeys(ctx context.Context, in *ListJwtPublicKeysRequest, opts ...grpc.CallOption) (*ListJwtPublicKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListJwtPublicKeysResponse)
	err := c.cc.Invoke(ctx, AuthService_ListJwtPublicKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AuthService (var: Yze)
type AuthServiceServer interface {
	GetEmail(context.Context, *GetEmailRequest) (*GetEmailResponse, error)
	GetUserMeta(context.Context, *GetUserMetaRequest) (*GetUserMetaResponse, error)
	EmailValid(context.Context, *EmailValidRequest) (*EmailValidResponse, error)
	DownloadUpdate(context.Context, *DownloadUpdateRequest) (*DownloadUpdateResponse, error)
	MarkPrivacy(context.Context, *MarkPrivacyRequest) (*MarkPrivacyResponse, error)
	SwitchCmdKFraction(context.Context, *SwitchCmdKFractionRequest) (*SwitchCmdKFractionResponse, error)
	GetCustomerId(context.Context, *CustomerIdRequest) (*CustomerIdResponse, error)
	SetPrivacyMode(context.Context, *SetPrivacyModeRequest) (*SetPrivacyModeResponse, error)
	GetSessionToken(context.Context, *GetSessionTokenRequest) (*GetSessionTokenResponse, error)
	CheckSessionToken(context.Context, *CheckSessionTokenRequest) (*CheckSessionTokenResponse, error)
	ListActiveSessions(context.Context, *ListActiveSessionsRequest) (*ListActiveSessionsResponse, error)
	RevokeSession(context.Context, *RevokeSessionRequest) (*RevokeSessionResponse, error)
	ListJwtPublicKeys(context.Context, *ListJwtPublicKeysRequest) (*ListJwtPublicKeysResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) GetEmail(context.Context, *GetEmailRequest) (*GetEmailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEmail not implemented")
}
func (UnimplementedAuthServiceServer) GetUserMeta(context.Context, *GetUserMetaRequest) (*GetUserMetaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserMeta not implemented")
}
func (UnimplementedAuthServiceServer) EmailValid(context.Context, *EmailValidRequest) (*EmailValidResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EmailValid not implemented")
}
func (UnimplementedAuthServiceServer) DownloadUpdate(context.Context, *DownloadUpdateRequest) (*DownloadUpdateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DownloadUpdate not implemented")
}
func (UnimplementedAuthServiceServer) MarkPrivacy(context.Context, *MarkPrivacyRequest) (*MarkPrivacyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkPrivacy not implemented")
}
func (UnimplementedAuthServiceServer) SwitchCmdKFraction(context.Context, *SwitchCmdKFractionRequest) (*SwitchCmdKFractionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwitchCmdKFraction not implemented")
}
func (UnimplementedAuthServiceServer) GetCustomerId(context.Context, *CustomerIdRequest) (*CustomerIdResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCustomerId not implemented")
}
func (UnimplementedAuthServiceServer) SetPrivacyMode(context.Context, *SetPrivacyModeRequest) (*SetPrivacyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetPrivacyMode not implemented")
}
func (UnimplementedAuthServiceServer) GetSessionToken(context.Context, *GetSessionTokenRequest) (*GetSessionTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSessionToken not implemented")
}
func (UnimplementedAuthServiceServer) CheckSessionToken(context.Context, *CheckSessionTokenRequest) (*CheckSessionTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckSessionToken not implemented")
}
func (UnimplementedAuthServiceServer) ListActiveSessions(context.Context, *ListActiveSessionsRequest) (*ListActiveSessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListActiveSessions not implemented")
}
func (UnimplementedAuthServiceServer) RevokeSession(context.Context, *RevokeSessionRequest) (*RevokeSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeSession not implemented")
}
func (UnimplementedAuthServiceServer) ListJwtPublicKeys(context.Context, *ListJwtPublicKeysRequest) (*ListJwtPublicKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListJwtPublicKeys not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call panics, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_GetEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetEmail(ctx, req.(*GetEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUserMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUserMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetUserMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUserMeta(ctx, req.(*GetUserMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_EmailValid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailValidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).EmailValid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_EmailValid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).EmailValid(ctx, req.(*EmailValidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DownloadUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DownloadUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_DownloadUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DownloadUpdate(ctx, req.(*DownloadUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_MarkPrivacy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkPrivacyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).MarkPrivacy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_MarkPrivacy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).MarkPrivacy(ctx, req.(*MarkPrivacyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SwitchCmdKFraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchCmdKFractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SwitchCmdKFraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_SwitchCmdKFraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SwitchCmdKFraction(ctx, req.(*SwitchCmdKFractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetCustomerId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CustomerIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetCustomerId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetCustomerId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetCustomerId(ctx, req.(*CustomerIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetPrivacyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPrivacyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetPrivacyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_SetPrivacyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetPrivacyMode(ctx, req.(*SetPrivacyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSessionToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSessionToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetSessionToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSessionToken(ctx, req.(*GetSessionTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CheckSessionToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSessionTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CheckSessionToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_CheckSessionToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CheckSessionToken(ctx, req.(*CheckSessionTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListActiveSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActiveSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListActiveSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ListActiveSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListActiveSessions(ctx, req.(*ListActiveSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RevokeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RevokeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RevokeSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RevokeSession(ctx, req.(*RevokeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListJwtPublicKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJwtPublicKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListJwtPublicKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ListJwtPublicKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListJwtPublicKeys(ctx, req.(*ListJwtPublicKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEmail",
			Handler:    _AuthService_GetEmail_Handler,
		},
		{
			MethodName: "GetUserMeta",
			Handler:    _AuthService_GetUserMeta_Handler,
		},
		{
			MethodName: "EmailValid",
			Handler:    _AuthService_EmailValid_Handler,
		},
		{
			MethodName: "DownloadUpdate",
			Handler:    _AuthService_DownloadUpdate_Handler,
		},
		{
			MethodName: "MarkPrivacy",
			Handler:    _AuthService_MarkPrivacy_Handler,
		},
		{
			MethodName: "SwitchCmdKFraction",
			Handler:    _AuthService_SwitchCmdKFraction_Handler,
		},
		{
			MethodName: "GetCustomerId",
			Handler:    _AuthService_GetCustomerId_Handler,
		},
		{
			MethodName: "SetPrivacyMode",
			Handler:    _AuthService_SetPrivacyMode_Handler,
		},
		{
			MethodName: "GetSessionToken",
			Handler:    _AuthService_GetSessionToken_Handler,
		},
		{
			MethodName: "CheckSessionToken",
			Handler:    _AuthService_CheckSessionToken_Handler,
		},
		{
			MethodName: "ListActiveSessions",
			Handler:    _AuthService_ListActiveSessions_Handler,
		},
		{
			MethodName: "RevokeSession",
			Handler:    _AuthService_RevokeSession_Handler,
		},
		{
			MethodName: "ListJwtPublicKeys",
			Handler:    _AuthService_ListJwtPublicKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	AutopilotService_StreamAutopilot_FullMethodName = "/aiserver.v1.AutopilotService/StreamAutopilot"
)

// AutopilotServiceClient is the client API for AutopilotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.AutopilotService (var: Xze)
type AutopilotServiceClient interface {
	StreamAutopilot(ctx context.Context, in *AutopilotRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AutopilotResponse], error)
}

type autopilotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAutopilotServiceClient(cc grpc.ClientConnInterface) AutopilotServiceClient {
	return &autopilotServiceClient{cc}
}

func (c *autopilotServiceClient) StreamAutopilot(ctx context.Context, in *AutopilotRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AutopilotResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AutopilotService_ServiceDesc.Streams[0], AutopilotService_StreamAutopilot_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AutopilotRequest, AutopilotResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AutopilotService_StreamAutopilotClient = grpc.ServerStreamingClient[AutopilotResponse]

// AutopilotServiceServer is the server API for AutopilotService service.
// All implementations must embed UnimplementedAutopilotServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.AutopilotService (var: Xze)
type AutopilotServiceServer interface {
	StreamAutopilot(*AutopilotRequest, grpc.ServerStreamingServer[AutopilotResponse]) error
	mustEmbedUnimplementedAutopilotServiceServer()
}

// UnimplementedAutopilotServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAutopilotServiceServer struct{}

func (UnimplementedAutopilotServiceServer) StreamAutopilot(*AutopilotRequest, grpc.ServerStreamingServer[AutopilotResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamAutopilot not implemented")
}
func (UnimplementedAutopilotServiceServer) mustEmbedUnimplementedAutopilotServiceServer() {}
func (UnimplementedAutopilotServiceServer) testEmbeddedByValue()                          {}

// UnsafeAutopilotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutopilotServiceServer will
// result in compilation errors.
type UnsafeAutopilotServiceServer interface {
	mustEmbedUnimplementedAutopilotServiceServer()
}

func RegisterAutopilotServiceServer(s grpc.ServiceRegistrar, srv AutopilotServiceServer) {
	// If the following call panics, it indicates UnimplementedAutopilotServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AutopilotService_ServiceDesc, srv)
}

func _AutopilotService_StreamAutopilot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AutopilotRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AutopilotServiceServer).StreamAutopilot(m, &grpc.GenericServerStream[AutopilotRequest, AutopilotResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AutopilotService_StreamAutopilotServer = grpc.ServerStreamingServer[AutopilotResponse]

// AutopilotService_ServiceDesc is the grpc.ServiceDesc for AutopilotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AutopilotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.AutopilotService",
	HandlerType: (*AutopilotServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAutopilot",
			Handler:       _AutopilotService_StreamAutopilot_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	BackgroundComposerService_ListBackgroundComposers_FullMethodName                      = "/aiserver.v1.BackgroundComposerService/ListBackgroundComposers"
	BackgroundComposerService_AttachBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/AttachBackgroundComposer"
	BackgroundComposerService_StreamInteractionUpdates_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/StreamInteractionUpdates"
	BackgroundComposerService_StreamInteractionUpdatesSSE_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/StreamInteractionUpdatesSSE"
	BackgroundComposerService_StreamConversation_FullMethodName                           = "/aiserver.v1.BackgroundComposerService/StreamConversation"
	BackgroundComposerService_GetLatestAgentConversationState_FullMethodName              = "/aiserver.v1.BackgroundComposerService/GetLatestAgentConversationState"
	BackgroundComposerService_GetBlobForAgentKV_FullMethodName                            = "/aiserver.v1.BackgroundComposerService/GetBlobForAgentKV"
	BackgroundComposerService_AttachBackgroundComposerLogs_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/AttachBackgroundComposerLogs"
	BackgroundComposerService_StartBackgroundComposerFromSnapshot_FullMethodName          = "/aiserver.v1.BackgroundComposerService/StartBackgroundComposerFromSnapshot"
	BackgroundComposerService_StartParallelAgentWorkflow_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/StartParallelAgentWorkflow"
	BackgroundComposerService_StreamParallelAgentWorkflowStatus_FullMethodName            = "/aiserver.v1.BackgroundComposerService/StreamParallelAgentWorkflowStatus"
	BackgroundComposerService_MakePRBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/MakePRBackgroundComposer"
	BackgroundComposerService_OpenPRBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/OpenPRBackgroundComposer"
	BackgroundComposerService_GetBackgroundComposerStatus_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerStatus"
	BackgroundComposerService_AddAsyncFollowupBackgroundComposer_FullMethodName           = "/aiserver.v1.BackgroundComposerService/AddAsyncFollowupBackgroundComposer"
	BackgroundComposerService_ListPendingFollowups_FullMethodName                         = "/aiserver.v1.BackgroundComposerService/ListPendingFollowups"
	BackgroundComposerService_UpdatePendingFollowup_FullMethodName                        = "/aiserver.v1.BackgroundComposerService/UpdatePendingFollowup"
	BackgroundComposerService_DeletePendingFollowup_FullMethodName                        = "/aiserver.v1.BackgroundComposerService/DeletePendingFollowup"
	BackgroundComposerService_ReorderPendingFollowup_FullMethodName                       = "/aiserver.v1.BackgroundComposerService/ReorderPendingFollowup"
	BackgroundComposerService_SubmitPendingFollowupNow_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/SubmitPendingFollowupNow"
	BackgroundComposerService_GetCursorServerUrl_FullMethodName                           = "/aiserver.v1.BackgroundComposerService/GetCursorServerUrl"
	BackgroundComposerService_PauseBackgroundComposer_FullMethodName                      = "/aiserver.v1.BackgroundComposerService/PauseBackgroundComposer"
	BackgroundComposerService_ResumeBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/ResumeBackgroundComposer"
	BackgroundComposerService_ArchiveBackgroundComposer_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/ArchiveBackgroundComposer"
	BackgroundComposerService_GetBackgroundComposerInfo_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerInfo"
	BackgroundComposerService_GetBackgroundComposerRepositoryInfo_FullMethodName          = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerRepositoryInfo"
	BackgroundComposerService_GetMachine_FullMethodName                                   = "/aiserver.v1.BackgroundComposerService/GetMachine"
	BackgroundComposerService_ListDetailedBackgroundComposers_FullMethodName              = "/aiserver.v1.BackgroundComposerService/ListDetailedBackgroundComposers"
	BackgroundComposerService_GetGithubAccessTokenForRepos_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/GetGithubAccessTokenForRepos"
	BackgroundComposerService_GetBackgroundComposerDiffDetails_FullMethodName             = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerDiffDetails"
	BackgroundComposerService_GetOptimizedDiffDetails_FullMethodName                      = "/aiserver.v1.BackgroundComposerService/GetOptimizedDiffDetails"
	BackgroundComposerService_GetBatchBackgroundComposerStats_FullMethodName              = "/aiserver.v1.BackgroundComposerService/GetBatchBackgroundComposerStats"
	BackgroundComposerService_GetBackgroundComposerChangesHash_FullMethodName             = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerChangesHash"
	BackgroundComposerService_GetBackgroundComposerPullRequest_FullMethodName             = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerPullRequest"
	BackgroundComposerService_RefreshGithubAccessTokenInBackgroundComposer_FullMethodName = "/aiserver.v1.BackgroundComposerService/RefreshGithubAccessTokenInBackgroundComposer"
	BackgroundComposerService_CreateBackgroundComposerPod_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/CreateBackgroundComposerPod"
	BackgroundComposerService_AttachBackgroundComposerPod_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/AttachBackgroundComposerPod"
	BackgroundComposerService_CreateBackgroundComposerPodSnapshot_FullMethodName          = "/aiserver.v1.BackgroundComposerService/CreateBackgroundComposerPodSnapshot"
	BackgroundComposerService_ChangeBackgroundComposerSnapshotVisibility_FullMethodName   = "/aiserver.v1.BackgroundComposerService/ChangeBackgroundComposerSnapshotVisibility"
	BackgroundComposerService_GetBackgroundComposerSnapshotInfo_FullMethodName            = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerSnapshotInfo"
	BackgroundComposerService_GetBackgroundComposerSnapshotState_FullMethodName           = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerSnapshotState"
	BackgroundComposerService_WatchBackgroundComposerSnapshotState_FullMethodName         = "/aiserver.v1.BackgroundComposerService/WatchBackgroundComposerSnapshotState"
	BackgroundComposerService_GetBackgroundComposerConversation_FullMethodName            = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerConversation"
	BackgroundComposerService_RenameBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/RenameBackgroundComposer"
	BackgroundComposerService_CommitBackgroundComposer_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/CommitBackgroundComposer"
	BackgroundComposerService_SetPersonalEnvironmentJson_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/SetPersonalEnvironmentJson"
	BackgroundComposerService_GetPersonalEnvironmentJson_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/GetPersonalEnvironmentJson"
	BackgroundComposerService_GetEnvironmentJsonCandidates_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/GetEnvironmentJsonCandidates"
	BackgroundComposerService_ListPersonalEnvironments_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/ListPersonalEnvironments"
	BackgroundComposerService_DeletePersonalEnvironmentJson_FullMethodName                = "/aiserver.v1.BackgroundComposerService/DeletePersonalEnvironmentJson"
	BackgroundComposerService_PublishEnvironment_FullMethodName                           = "/aiserver.v1.BackgroundComposerService/PublishEnvironment"
	BackgroundComposerService_PublishPersonalEnvironment_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/PublishPersonalEnvironment"
	BackgroundComposerService_ListTeamEnvironments_FullMethodName                         = "/aiserver.v1.BackgroundComposerService/ListTeamEnvironments"
	BackgroundComposerService_DeleteTeamEnvironment_FullMethodName                        = "/aiserver.v1.BackgroundComposerService/DeleteTeamEnvironment"
	BackgroundComposerService_SetTeamEnvironmentJson_FullMethodName                       = "/aiserver.v1.BackgroundComposerService/SetTeamEnvironmentJson"
	BackgroundComposerService_ListReposWithLocalEnvironment_FullMethodName                = "/aiserver.v1.BackgroundComposerService/ListReposWithLocalEnvironment"
	BackgroundComposerService_PrepareEnvironmentSetupPR_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/PrepareEnvironmentSetupPR"
	BackgroundComposerService_MarkBackgroundComposerRead_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/MarkBackgroundComposerRead"
	BackgroundComposerService_MarkBackgroundComposerUnread_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/MarkBackgroundComposerUnread"
	BackgroundComposerService_NotifyBackgroundComposerShown_FullMethodName                = "/aiserver.v1.BackgroundComposerService/NotifyBackgroundComposerShown"
	BackgroundComposerService_FetchBackgroundComposer_FullMethodName                      = "/aiserver.v1.BackgroundComposerService/FetchBackgroundComposer"
	BackgroundComposerService_GetTurnSummaryBackgroundComposer_FullMethodName             = "/aiserver.v1.BackgroundComposerService/GetTurnSummaryBackgroundComposer"
	BackgroundComposerService_GetBackgroundComposerName_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerName"
	BackgroundComposerService_GetBackgroundComposerPrompt_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerPrompt"
	BackgroundComposerService_ReadBinaryFile_FullMethodName                               = "/aiserver.v1.BackgroundComposerService/ReadBinaryFile"
	BackgroundComposerService_ListBackgroundComposerArtifacts_FullMethodName              = "/aiserver.v1.BackgroundComposerService/ListBackgroundComposerArtifacts"
	BackgroundComposerService_GetBackgroundComposerArtifact_FullMethodName                = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerArtifact"
	BackgroundComposerService_GetBackgroundComposerArtifactBytes_FullMethodName           = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerArtifactBytes"
	BackgroundComposerService_StreamBackgroundComposerArtifact_FullMethodName             = "/aiserver.v1.BackgroundComposerService/StreamBackgroundComposerArtifact"
	BackgroundComposerService_UpdateBackgroundComposerUserSettings_FullMethodName         = "/aiserver.v1.BackgroundComposerService/UpdateBackgroundComposerUserSettings"
	BackgroundComposerService_GetBackgroundComposerUserSettings_FullMethodName            = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerUserSettings"
	BackgroundComposerService_UpdateBackgroundComposerEnvironment_FullMethodName          = "/aiserver.v1.BackgroundComposerService/UpdateBackgroundComposerEnvironment"
	BackgroundComposerService_GetRepositoryBranches_FullMethodName                        = "/aiserver.v1.BackgroundComposerService/GetRepositoryBranches"
	BackgroundComposerService_GetPullRequestMergeStatus_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/GetPullRequestMergeStatus"
	BackgroundComposerService_GetDetailedPullRequestStatus_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/GetDetailedPullRequestStatus"
	BackgroundComposerService_CheckPullRequestMergeability_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/CheckPullRequestMergeability"
	BackgroundComposerService_GetPullRequestDiscussions_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/GetPullRequestDiscussions"
	BackgroundComposerService_ReplyToReviewThread_FullMethodName                          = "/aiserver.v1.BackgroundComposerService/ReplyToReviewThread"
	BackgroundComposerService_ResolveReviewThread_FullMethodName                          = "/aiserver.v1.BackgroundComposerService/ResolveReviewThread"
	BackgroundComposerService_AddPullRequestReviewComment_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/AddPullRequestReviewComment"
	BackgroundComposerService_MergePullRequest_FullMethodName                             = "/aiserver.v1.BackgroundComposerService/MergePullRequest"
	BackgroundComposerService_EnablePullRequestAutoMerge_FullMethodName                   = "/aiserver.v1.BackgroundComposerService/EnablePullRequestAutoMerge"
	BackgroundComposerService_ConvertPullRequestFromDraft_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/ConvertPullRequestFromDraft"
	BackgroundComposerService_UpdatePullRequestBranch_FullMethodName                      = "/aiserver.v1.BackgroundComposerService/UpdatePullRequestBranch"
	BackgroundComposerService_RegisterPushNotificationToken_FullMethodName                = "/aiserver.v1.BackgroundComposerService/RegisterPushNotificationToken"
	BackgroundComposerService_DeletePushNotificationToken_FullMethodName                  = "/aiserver.v1.BackgroundComposerService/DeletePushNotificationToken"
	BackgroundComposerService_VerifyBackgroundComposerAccess_FullMethodName               = "/aiserver.v1.BackgroundComposerService/VerifyBackgroundComposerAccess"
	BackgroundComposerService_StartSlackStreamingForFollowup_FullMethodName               = "/aiserver.v1.BackgroundComposerService/StartSlackStreamingForFollowup"
	BackgroundComposerService_StartGithubStreamingForFollowup_FullMethodName              = "/aiserver.v1.BackgroundComposerService/StartGithubStreamingForFollowup"
	BackgroundComposerService_StartLinearStreamingForFollowup_FullMethodName              = "/aiserver.v1.BackgroundComposerService/StartLinearStreamingForFollowup"
	BackgroundComposerService_GetGithubInstallations_FullMethodName                       = "/aiserver.v1.BackgroundComposerService/GetGithubInstallations"
	BackgroundComposerService_FetchAllInstallationRepos_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/FetchAllInstallationRepos"
	BackgroundComposerService_GetBackgroundComposerVmUsage_FullMethodName                 = "/aiserver.v1.BackgroundComposerService/GetBackgroundComposerVmUsage"
	BackgroundComposerService_ListGrindModeComposers_FullMethodName                       = "/aiserver.v1.BackgroundComposerService/ListGrindModeComposers"
	BackgroundComposerService_GetCloudAgentDebugDetails_FullMethodName                    = "/aiserver.v1.BackgroundComposerService/GetCloudAgentDebugDetails"
	BackgroundComposerService_CreateAgentShare_FullMethodName                             = "/aiserver.v1.BackgroundComposerService/CreateAgentShare"
	BackgroundComposerService_GetAgentSharePreview_FullMethodName                         = "/aiserver.v1.BackgroundComposerService/GetAgentSharePreview"
	BackgroundComposerService_ListPrivateWorkers_FullMethodName                           = "/aiserver.v1.BackgroundComposerService/ListPrivateWorkers"
	BackgroundComposerService_GetPrivateWorkersSummary_FullMethodName                     = "/aiserver.v1.BackgroundComposerService/GetPrivateWorkersSummary"
	BackgroundComposerService_GetPrivateWorker_FullMethodName                             = "/aiserver.v1.BackgroundComposerService/GetPrivateWorker"
)

// BackgroundComposerServiceClient is the client API for BackgroundComposerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.BackgroundComposerService (var: Qje)
type BackgroundComposerServiceClient interface {
	ListBackgroundComposers(ctx context.Context, in *ListBackgroundComposersRequest, opts ...grpc.CallOption) (*ListBackgroundComposersResponse, error)
	AttachBackgroundComposer(ctx context.Context, in *AttachBackgroundComposerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerResponse], error)
	StreamInteractionUpdates(ctx context.Context, in *StreamInteractionUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InteractionUpdate], error)
	StreamInteractionUpdatesSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InteractionUpdate], error)
	StreamConversation(ctx context.Context, in *StreamConversationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamConversationResponse], error)
	GetLatestAgentConversationState(ctx context.Context, in *GetLatestAgentConversationStateRequest, opts ...grpc.CallOption) (*GetLatestAgentConversationStateResponse, error)
	GetBlobForAgentKV(ctx context.Context, in *GetBlobForAgentKVRequest, opts ...grpc.CallOption) (*GetBlobForAgentKVResponse, error)
	AttachBackgroundComposerLogs(ctx context.Context, in *AttachBackgroundComposerLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerLogsResponse], error)
	StartBackgroundComposerFromSnapshot(ctx context.Context, in *StartBackgroundComposerFromSnapshotRequest, opts ...grpc.CallOption) (*StartBackgroundComposerFromSnapshotResponse, error)
	StartParallelAgentWorkflow(ctx context.Context, in *StartParallelAgentWorkflowRequest, opts ...grpc.CallOption) (*StartParallelAgentWorkflowResponse, error)
	StreamParallelAgentWorkflowStatus(ctx context.Context, in *StreamParallelAgentWorkflowStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ParallelAgentWorkflowStatusUpdate], error)
	MakePRBackgroundComposer(ctx context.Context, in *MakePRBackgroundComposerRequest, opts ...grpc.CallOption) (*MakePRBackgroundComposerResponse, error)
	OpenPRBackgroundComposer(ctx context.Context, in *OpenPRBackgroundComposerRequest, opts ...grpc.CallOption) (*OpenPRBackgroundComposerResponse, error)
	GetBackgroundComposerStatus(ctx context.Context, in *GetBackgroundComposerStatusRequest, opts ...grpc.CallOption) (*GetBackgroundComposerStatusResponse, error)
	AddAsyncFollowupBackgroundComposer(ctx context.Context, in *AddAsyncFollowupBackgroundComposerRequest, opts ...grpc.CallOption) (*AddAsyncFollowupBackgroundComposerResponse, error)
	ListPendingFollowups(ctx context.Context, in *ListPendingFollowupsRequest, opts ...grpc.CallOption) (*ListPendingFollowupsResponse, error)
	UpdatePendingFollowup(ctx context.Context, in *UpdatePendingFollowupRequest, opts ...grpc.CallOption) (*UpdatePendingFollowupResponse, error)
	DeletePendingFollowup(ctx context.Context, in *DeletePendingFollowupRequest, opts ...grpc.CallOption) (*DeletePendingFollowupResponse, error)
	ReorderPendingFollowup(ctx context.Context, in *ReorderPendingFollowupRequest, opts ...grpc.CallOption) (*ReorderPendingFollowupResponse, error)
	SubmitPendingFollowupNow(ctx context.Context, in *SubmitPendingFollowupNowRequest, opts ...grpc.CallOption) (*SubmitPendingFollowupNowResponse, error)
	GetCursorServerUrl(ctx context.Context, in *GetCursorServerUrlRequest, opts ...grpc.CallOption) (*GetCursorServerUrlResponse, error)
	PauseBackgroundComposer(ctx context.Context, in *PauseBackgroundComposerRequest, opts ...grpc.CallOption) (*PauseBackgroundComposerResponse, error)
	ResumeBackgroundComposer(ctx context.Context, in *ResumeBackgroundComposerRequest, opts ...grpc.CallOption) (*ResumeBackgroundComposerResponse, error)
	ArchiveBackgroundComposer(ctx context.Context, in *ArchiveBackgroundComposerRequest, opts ...grpc.CallOption) (*ArchiveBackgroundComposerResponse, error)
	GetBackgroundComposerInfo(ctx context.Context, in *GetBackgroundComposerInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerInfoResponse, error)
	GetBackgroundComposerRepositoryInfo(ctx context.Context, in *GetBackgroundComposerRepositoryInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerRepositoryInfoResponse, error)
	GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error)
	ListDetailedBackgroundComposers(ctx context.Context, in *ListDetailedBackgroundComposersRequest, opts ...grpc.CallOption) (*ListDetailedBackgroundComposersResponse, error)
	GetGithubAccessTokenForRepos(ctx context.Context, in *GetGithubAccessTokenForReposRequest, opts ...grpc.CallOption) (*GetGithubAccessTokenForReposResponse, error)
	GetBackgroundComposerDiffDetails(ctx context.Context, in *GetBackgroundComposerDiffDetailsRequest, opts ...grpc.CallOption) (*GetBackgroundComposerDiffDetailsResponse, error)
	GetOptimizedDiffDetails(ctx context.Context, in *GetOptimizedDiffDetailsRequest, opts ...grpc.CallOption) (*GetOptimizedDiffDetailsResponse, error)
	GetBatchBackgroundComposerStats(ctx context.Context, in *GetBatchBackgroundComposerStatsRequest, opts ...grpc.CallOption) (*GetBatchBackgroundComposerStatsResponse, error)
	GetBackgroundComposerChangesHash(ctx context.Context, in *GetBackgroundComposerChangesHashRequest, opts ...grpc.CallOption) (*GetBackgroundComposerChangesHashResponse, error)
	GetBackgroundComposerPullRequest(ctx context.Context, in *GetBackgroundComposerPullRequestRequest, opts ...grpc.CallOption) (*GetBackgroundComposerPullRequestResponse, error)
	RefreshGithubAccessTokenInBackgroundComposer(ctx context.Context, in *RefreshGithubAccessTokenInBackgroundComposerRequest, opts ...grpc.CallOption) (*RefreshGithubAccessTokenInBackgroundComposerResponse, error)
	CreateBackgroundComposerPod(ctx context.Context, in *CreateBackgroundComposerPodRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerPodResponse, error)
	AttachBackgroundComposerPod(ctx context.Context, in *AttachBackgroundComposerPodRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerPodResponse], error)
	CreateBackgroundComposerPodSnapshot(ctx context.Context, in *CreateBackgroundComposerPodSnapshotRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerPodSnapshotResponse, error)
	ChangeBackgroundComposerSnapshotVisibility(ctx context.Context, in *ChangeBackgroundComposerSnapshotVisibilityRequest, opts ...grpc.CallOption) (*ChangeBackgroundComposerSnapshotVisibilityResponse, error)
	GetBackgroundComposerSnapshotInfo(ctx context.Context, in *GetBackgroundComposerSnapshotInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerSnapshotInfoResponse, error)
	GetBackgroundComposerSnapshotState(ctx context.Context, in *GetBackgroundComposerSnapshotStateRequest, opts ...grpc.CallOption) (*GetBackgroundComposerSnapshotStateResponse, error)
	WatchBackgroundComposerSnapshotState(ctx context.Context, in *WatchBackgroundComposerSnapshotStateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchBackgroundComposerSnapshotStateResponse], error)
	GetBackgroundComposerConversation(ctx context.Context, in *GetBackgroundComposerConversationRequest, opts ...grpc.CallOption) (*GetBackgroundComposerConversationResponse, error)
	RenameBackgroundComposer(ctx context.Context, in *RenameBackgroundComposerRequest, opts ...grpc.CallOption) (*RenameBackgroundComposerResponse, error)
	CommitBackgroundComposer(ctx context.Context, in *CommitBackgroundComposerRequest, opts ...grpc.CallOption) (*CommitBackgroundComposerResponse, error)
	SetPersonalEnvironmentJson(ctx context.Context, in *SetPersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*SetPersonalEnvironmentJsonResponse, error)
	GetPersonalEnvironmentJson(ctx context.Context, in *GetPersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*GetPersonalEnvironmentJsonResponse, error)
	GetEnvironmentJsonCandidates(ctx context.Context, in *GetEnvironmentJsonCandidatesRequest, opts ...grpc.CallOption) (*GetEnvironmentJsonCandidatesResponse, error)
	ListPersonalEnvironments(ctx context.Context, in *ListPersonalEnvironmentsRequest, opts ...grpc.CallOption) (*ListPersonalEnvironmentsResponse, error)
	DeletePersonalEnvironmentJson(ctx context.Context, in *DeletePersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*DeletePersonalEnvironmentJsonResponse, error)
	PublishEnvironment(ctx context.Context, in *PublishEnvironmentRequest, opts ...grpc.CallOption) (*PublishEnvironmentResponse, error)
	PublishPersonalEnvironment(ctx context.Context, in *PublishPersonalEnvironmentRequest, opts ...grpc.CallOption) (*PublishPersonalEnvironmentResponse, error)
	ListTeamEnvironments(ctx context.Context, in *ListTeamEnvironmentsRequest, opts ...grpc.CallOption) (*ListTeamEnvironmentsResponse, error)
	DeleteTeamEnvironment(ctx context.Context, in *DeleteTeamEnvironmentRequest, opts ...grpc.CallOption) (*DeleteTeamEnvironmentResponse, error)
	SetTeamEnvironmentJson(ctx context.Context, in *SetTeamEnvironmentJsonRequest, opts ...grpc.CallOption) (*SetTeamEnvironmentJsonResponse, error)
	ListReposWithLocalEnvironment(ctx context.Context, in *ListReposWithLocalEnvironmentRequest, opts ...grpc.CallOption) (*ListReposWithLocalEnvironmentResponse, error)
	PrepareEnvironmentSetupPR(ctx context.Context, in *PrepareEnvironmentSetupPRRequest, opts ...grpc.CallOption) (*PrepareEnvironmentSetupPRResponse, error)
	MarkBackgroundComposerRead(ctx context.Context, in *MarkBackgroundComposerReadRequest, opts ...grpc.CallOption) (*MarkBackgroundComposerReadResponse, error)
	MarkBackgroundComposerUnread(ctx context.Context, in *MarkBackgroundComposerUnreadRequest, opts ...grpc.CallOption) (*MarkBackgroundComposerUnreadResponse, error)
	NotifyBackgroundComposerShown(ctx context.Context, in *NotifyBackgroundComposerShownRequest, opts ...grpc.CallOption) (*NotifyBackgroundComposerShownResponse, error)
	FetchBackgroundComposer(ctx context.Context, in *FetchBackgroundComposerRequest, opts ...grpc.CallOption) (*FetchBackgroundComposerResponse, error)
	GetTurnSummaryBackgroundComposer(ctx context.Context, in *GetTurnSummaryBackgroundComposerRequest, opts ...grpc.CallOption) (*GetTurnSummaryBackgroundComposerResponse, error)
	GetBackgroundComposerName(ctx context.Context, in *GetBackgroundComposerNameRequest, opts ...grpc.CallOption) (*GetBackgroundComposerNameResponse, error)
	GetBackgroundComposerPrompt(ctx context.Context, in *GetBackgroundComposerPromptRequest, opts ...grpc.CallOption) (*GetBackgroundComposerPromptResponse, error)
	ReadBinaryFile(ctx context.Context, in *ReadBinaryFileRequest, opts ...grpc.CallOption) (*ReadBinaryFileResponse, error)
	ListBackgroundComposerArtifacts(ctx context.Context, in *ListBackgroundComposerArtifactsRequest, opts ...grpc.CallOption) (*ListBackgroundComposerArtifactsResponse, error)
	GetBackgroundComposerArtifact(ctx context.Context, in *GetBackgroundComposerArtifactRequest, opts ...grpc.CallOption) (*GetBackgroundComposerArtifactResponse, error)
	GetBackgroundComposerArtifactBytes(ctx context.Context, in *GetBackgroundComposerArtifactBytesRequest, opts ...grpc.CallOption) (*GetBackgroundComposerArtifactBytesResponse, error)
	StreamBackgroundComposerArtifact(ctx context.Context, in *StreamBackgroundComposerArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBackgroundComposerArtifactResponse], error)
	UpdateBackgroundComposerUserSettings(ctx context.Context, in *UpdateBackgroundComposerUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerUserSettingsResponse, error)
	GetBackgroundComposerUserSettings(ctx context.Context, in *GetBackgroundComposerUserSettingsRequest, opts ...grpc.CallOption) (*GetBackgroundComposerUserSettingsResponse, error)
	UpdateBackgroundComposerEnvironment(ctx context.Context, in *UpdateBackgroundComposerEnvironmentRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerEnvironmentResponse, error)
	GetRepositoryBranches(ctx context.Context, in *GetRepositoryBranchesRequest, opts ...grpc.CallOption) (*GetRepositoryBranchesResponse, error)
	GetPullRequestMergeStatus(ctx context.Context, in *GetPullRequestMergeStatusRequest, opts ...grpc.CallOption) (*GetPullRequestMergeStatusResponse, error)
	GetDetailedPullRequestStatus(ctx context.Context, in *GetDetailedPullRequestStatusRequest, opts ...grpc.CallOption) (*GetDetailedPullRequestStatusResponse, error)
	CheckPullRequestMergeability(ctx context.Context, in *CheckPullRequestMergeabilityRequest, opts ...grpc.CallOption) (*CheckPullRequestMergeabilityResponse, error)
	GetPullRequestDiscussions(ctx context.Context, in *GetPullRequestDiscussionsRequest, opts ...grpc.CallOption) (*GetPullRequestDiscussionsResponse, error)
	ReplyToReviewThread(ctx context.Context, in *ReplyToReviewThreadRequest, opts ...grpc.CallOption) (*ReplyToReviewThreadResponse, error)
	ResolveReviewThread(ctx context.Context, in *ResolveReviewThreadRequest, opts ...grpc.CallOption) (*ResolveReviewThreadResponse, error)
	AddPullRequestReviewComment(ctx context.Context, in *AddPullRequestReviewCommentRequest, opts ...grpc.CallOption) (*AddPullRequestReviewCommentResponse, error)
	MergePullRequest(ctx context.Context, in *MergePullRequestRequest, opts ...grpc.CallOption) (*MergePullRequestResponse, error)
	EnablePullRequestAutoMerge(ctx context.Context, in *EnablePullRequestAutoMergeRequest, opts ...grpc.CallOption) (*EnablePullRequestAutoMergeResponse, error)
	ConvertPullRequestFromDraft(ctx context.Context, in *ConvertPullRequestFromDraftRequest, opts ...grpc.CallOption) (*ConvertPullRequestFromDraftResponse, error)
	UpdatePullRequestBranch(ctx context.Context, in *UpdatePullRequestBranchRequest, opts ...grpc.CallOption) (*UpdatePullRequestBranchResponse, error)
	RegisterPushNotificationToken(ctx context.Context, in *RegisterPushNotificationTokenRequest, opts ...grpc.CallOption) (*RegisterPushNotificationTokenResponse, error)
	DeletePushNotificationToken(ctx context.Context, in *DeletePushNotificationTokenRequest, opts ...grpc.CallOption) (*DeletePushNotificationTokenResponse, error)
	VerifyBackgroundComposerAccess(ctx context.Context, in *VerifyBackgroundComposerAccessRequest, opts ...grpc.CallOption) (*VerifyBackgroundComposerAccessResponse, error)
	StartSlackStreamingForFollowup(ctx context.Context, in *StartSlackStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartSlackStreamingForFollowupResponse, error)
	StartGithubStreamingForFollowup(ctx context.Context, in *StartGithubStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartGithubStreamingForFollowupResponse, error)
	StartLinearStreamingForFollowup(ctx context.Context, in *StartLinearStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartLinearStreamingForFollowupResponse, error)
	GetGithubInstallations(ctx context.Context, in *GetGithubInstallationsRequest, opts ...grpc.CallOption) (*GetGithubInstallationsResponse, error)
	FetchAllInstallationRepos(ctx context.Context, in *FetchAllInstallationReposRequest, opts ...grpc.CallOption) (*FetchAllInstallationReposResponse, error)
	GetBackgroundComposerVmUsage(ctx context.Context, in *GetBackgroundComposerVmUsageRequest, opts ...grpc.CallOption) (*GetBackgroundComposerVmUsageResponse, error)
	ListGrindModeComposers(ctx context.Context, in *ListGrindModeComposersRequest, opts ...grpc.CallOption) (*ListGrindModeComposersResponse, error)
	GetCloudAgentDebugDetails(ctx context.Context, in *GetCloudAgentDebugDetailsRequest, opts ...grpc.CallOption) (*GetCloudAgentDebugDetailsResponse, error)
	CreateAgentShare(ctx context.Context, in *CreateAgentShareRequest, opts ...grpc.CallOption) (*CreateAgentShareResponse, error)
	GetAgentSharePreview(ctx context.Context, in *GetAgentSharePreviewRequest, opts ...grpc.CallOption) (*GetAgentSharePreviewResponse, error)
	ListPrivateWorkers(ctx context.Context, in *ListPrivateWorkersRequest, opts ...grpc.CallOption) (*ListPrivateWorkersResponse, error)
	GetPrivateWorkersSummary(ctx context.Context, in *GetPrivateWorkersSummaryRequest, opts ...grpc.CallOption) (*GetPrivateWorkersSummaryResponse, error)
	GetPrivateWorker(ctx context.Context, in *GetPrivateWorkerRequest, opts ...grpc.CallOption) (*GetPrivateWorkerResponse, error)
}

type backgroundComposerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackgroundComposerServiceClient(cc grpc.ClientConnInterface) BackgroundComposerServiceClient {
	return &backgroundComposerServiceClient{cc}
}

func (c *backgroundComposerServiceClient) ListBackgroundComposers(ctx context.Context, in *ListBackgroundComposersRequest, opts ...grpc.CallOption) (*ListBackgroundComposersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackgroundComposersResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListBackgroundComposers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) AttachBackgroundComposer(ctx context.Context, in *AttachBackgroundComposerRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[0], BackgroundComposerService_AttachBackgroundComposer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AttachBackgroundComposerRequest, AttachBackgroundComposerResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerClient = grpc.ServerStreamingClient[AttachBackgroundComposerResponse]

func (c *backgroundComposerServiceClient) StreamInteractionUpdates(ctx context.Context, in *StreamInteractionUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InteractionUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[1], BackgroundComposerService_StreamInteractionUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamInteractionUpdatesRequest, InteractionUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamInteractionUpdatesClient = grpc.ServerStreamingClient[InteractionUpdate]

func (c *backgroundComposerServiceClient) StreamInteractionUpdatesSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InteractionUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[2], BackgroundComposerService_StreamInteractionUpdatesSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, InteractionUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamInteractionUpdatesSSEClient = grpc.ServerStreamingClient[InteractionUpdate]

func (c *backgroundComposerServiceClient) StreamConversation(ctx context.Context, in *StreamConversationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamConversationResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[3], BackgroundComposerService_StreamConversation_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamConversationRequest, StreamConversationResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamConversationClient = grpc.ServerStreamingClient[StreamConversationResponse]

func (c *backgroundComposerServiceClient) GetLatestAgentConversationState(ctx context.Context, in *GetLatestAgentConversationStateRequest, opts ...grpc.CallOption) (*GetLatestAgentConversationStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLatestAgentConversationStateResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetLatestAgentConversationState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBlobForAgentKV(ctx context.Context, in *GetBlobForAgentKVRequest, opts ...grpc.CallOption) (*GetBlobForAgentKVResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlobForAgentKVResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBlobForAgentKV_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) AttachBackgroundComposerLogs(ctx context.Context, in *AttachBackgroundComposerLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerLogsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[4], BackgroundComposerService_AttachBackgroundComposerLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AttachBackgroundComposerLogsRequest, AttachBackgroundComposerLogsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerLogsClient = grpc.ServerStreamingClient[AttachBackgroundComposerLogsResponse]

func (c *backgroundComposerServiceClient) StartBackgroundComposerFromSnapshot(ctx context.Context, in *StartBackgroundComposerFromSnapshotRequest, opts ...grpc.CallOption) (*StartBackgroundComposerFromSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartBackgroundComposerFromSnapshotResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_StartBackgroundComposerFromSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StartParallelAgentWorkflow(ctx context.Context, in *StartParallelAgentWorkflowRequest, opts ...grpc.CallOption) (*StartParallelAgentWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartParallelAgentWorkflowResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_StartParallelAgentWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StreamParallelAgentWorkflowStatus(ctx context.Context, in *StreamParallelAgentWorkflowStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ParallelAgentWorkflowStatusUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[5], BackgroundComposerService_StreamParallelAgentWorkflowStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamParallelAgentWorkflowStatusRequest, ParallelAgentWorkflowStatusUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamParallelAgentWorkflowStatusClient = grpc.ServerStreamingClient[ParallelAgentWorkflowStatusUpdate]

func (c *backgroundComposerServiceClient) MakePRBackgroundComposer(ctx context.Context, in *MakePRBackgroundComposerRequest, opts ...grpc.CallOption) (*MakePRBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MakePRBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_MakePRBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) OpenPRBackgroundComposer(ctx context.Context, in *OpenPRBackgroundComposerRequest, opts ...grpc.CallOption) (*OpenPRBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenPRBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_OpenPRBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerStatus(ctx context.Context, in *GetBackgroundComposerStatusRequest, opts ...grpc.CallOption) (*GetBackgroundComposerStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerStatusResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) AddAsyncFollowupBackgroundComposer(ctx context.Context, in *AddAsyncFollowupBackgroundComposerRequest, opts ...grpc.CallOption) (*AddAsyncFollowupBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddAsyncFollowupBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_AddAsyncFollowupBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListPendingFollowups(ctx context.Context, in *ListPendingFollowupsRequest, opts ...grpc.CallOption) (*ListPendingFollowupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPendingFollowupsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListPendingFollowups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) UpdatePendingFollowup(ctx context.Context, in *UpdatePendingFollowupRequest, opts ...grpc.CallOption) (*UpdatePendingFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePendingFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_UpdatePendingFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) DeletePendingFollowup(ctx context.Context, in *DeletePendingFollowupRequest, opts ...grpc.CallOption) (*DeletePendingFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePendingFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_DeletePendingFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ReorderPendingFollowup(ctx context.Context, in *ReorderPendingFollowupRequest, opts ...grpc.CallOption) (*ReorderPendingFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReorderPendingFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ReorderPendingFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) SubmitPendingFollowupNow(ctx context.Context, in *SubmitPendingFollowupNowRequest, opts ...grpc.CallOption) (*SubmitPendingFollowupNowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitPendingFollowupNowResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_SubmitPendingFollowupNow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetCursorServerUrl(ctx context.Context, in *GetCursorServerUrlRequest, opts ...grpc.CallOption) (*GetCursorServerUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCursorServerUrlResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetCursorServerUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) PauseBackgroundComposer(ctx context.Context, in *PauseBackgroundComposerRequest, opts ...grpc.CallOption) (*PauseBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_PauseBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ResumeBackgroundComposer(ctx context.Context, in *ResumeBackgroundComposerRequest, opts ...grpc.CallOption) (*ResumeBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResumeBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ResumeBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ArchiveBackgroundComposer(ctx context.Context, in *ArchiveBackgroundComposerRequest, opts ...grpc.CallOption) (*ArchiveBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArchiveBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ArchiveBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerInfo(ctx context.Context, in *GetBackgroundComposerInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerInfoResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerRepositoryInfo(ctx context.Context, in *GetBackgroundComposerRepositoryInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerRepositoryInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerRepositoryInfoResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerRepositoryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMachineResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListDetailedBackgroundComposers(ctx context.Context, in *ListDetailedBackgroundComposersRequest, opts ...grpc.CallOption) (*ListDetailedBackgroundComposersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDetailedBackgroundComposersResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListDetailedBackgroundComposers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetGithubAccessTokenForRepos(ctx context.Context, in *GetGithubAccessTokenForReposRequest, opts ...grpc.CallOption) (*GetGithubAccessTokenForReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGithubAccessTokenForReposResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetGithubAccessTokenForRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerDiffDetails(ctx context.Context, in *GetBackgroundComposerDiffDetailsRequest, opts ...grpc.CallOption) (*GetBackgroundComposerDiffDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerDiffDetailsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerDiffDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetOptimizedDiffDetails(ctx context.Context, in *GetOptimizedDiffDetailsRequest, opts ...grpc.CallOption) (*GetOptimizedDiffDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOptimizedDiffDetailsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetOptimizedDiffDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBatchBackgroundComposerStats(ctx context.Context, in *GetBatchBackgroundComposerStatsRequest, opts ...grpc.CallOption) (*GetBatchBackgroundComposerStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBatchBackgroundComposerStatsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBatchBackgroundComposerStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerChangesHash(ctx context.Context, in *GetBackgroundComposerChangesHashRequest, opts ...grpc.CallOption) (*GetBackgroundComposerChangesHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerChangesHashResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerChangesHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerPullRequest(ctx context.Context, in *GetBackgroundComposerPullRequestRequest, opts ...grpc.CallOption) (*GetBackgroundComposerPullRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerPullRequestResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerPullRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) RefreshGithubAccessTokenInBackgroundComposer(ctx context.Context, in *RefreshGithubAccessTokenInBackgroundComposerRequest, opts ...grpc.CallOption) (*RefreshGithubAccessTokenInBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshGithubAccessTokenInBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_RefreshGithubAccessTokenInBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) CreateBackgroundComposerPod(ctx context.Context, in *CreateBackgroundComposerPodRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerPodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBackgroundComposerPodResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_CreateBackgroundComposerPod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) AttachBackgroundComposerPod(ctx context.Context, in *AttachBackgroundComposerPodRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttachBackgroundComposerPodResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[6], BackgroundComposerService_AttachBackgroundComposerPod_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AttachBackgroundComposerPodRequest, AttachBackgroundComposerPodResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerPodClient = grpc.ServerStreamingClient[AttachBackgroundComposerPodResponse]

func (c *backgroundComposerServiceClient) CreateBackgroundComposerPodSnapshot(ctx context.Context, in *CreateBackgroundComposerPodSnapshotRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerPodSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBackgroundComposerPodSnapshotResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_CreateBackgroundComposerPodSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ChangeBackgroundComposerSnapshotVisibility(ctx context.Context, in *ChangeBackgroundComposerSnapshotVisibilityRequest, opts ...grpc.CallOption) (*ChangeBackgroundComposerSnapshotVisibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeBackgroundComposerSnapshotVisibilityResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ChangeBackgroundComposerSnapshotVisibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerSnapshotInfo(ctx context.Context, in *GetBackgroundComposerSnapshotInfoRequest, opts ...grpc.CallOption) (*GetBackgroundComposerSnapshotInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerSnapshotInfoResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerSnapshotInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerSnapshotState(ctx context.Context, in *GetBackgroundComposerSnapshotStateRequest, opts ...grpc.CallOption) (*GetBackgroundComposerSnapshotStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerSnapshotStateResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerSnapshotState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) WatchBackgroundComposerSnapshotState(ctx context.Context, in *WatchBackgroundComposerSnapshotStateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchBackgroundComposerSnapshotStateResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[7], BackgroundComposerService_WatchBackgroundComposerSnapshotState_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchBackgroundComposerSnapshotStateRequest, WatchBackgroundComposerSnapshotStateResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_WatchBackgroundComposerSnapshotStateClient = grpc.ServerStreamingClient[WatchBackgroundComposerSnapshotStateResponse]

func (c *backgroundComposerServiceClient) GetBackgroundComposerConversation(ctx context.Context, in *GetBackgroundComposerConversationRequest, opts ...grpc.CallOption) (*GetBackgroundComposerConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerConversationResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) RenameBackgroundComposer(ctx context.Context, in *RenameBackgroundComposerRequest, opts ...grpc.CallOption) (*RenameBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenameBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_RenameBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) CommitBackgroundComposer(ctx context.Context, in *CommitBackgroundComposerRequest, opts ...grpc.CallOption) (*CommitBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_CommitBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) SetPersonalEnvironmentJson(ctx context.Context, in *SetPersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*SetPersonalEnvironmentJsonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPersonalEnvironmentJsonResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_SetPersonalEnvironmentJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetPersonalEnvironmentJson(ctx context.Context, in *GetPersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*GetPersonalEnvironmentJsonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPersonalEnvironmentJsonResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetPersonalEnvironmentJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetEnvironmentJsonCandidates(ctx context.Context, in *GetEnvironmentJsonCandidatesRequest, opts ...grpc.CallOption) (*GetEnvironmentJsonCandidatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEnvironmentJsonCandidatesResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetEnvironmentJsonCandidates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListPersonalEnvironments(ctx context.Context, in *ListPersonalEnvironmentsRequest, opts ...grpc.CallOption) (*ListPersonalEnvironmentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPersonalEnvironmentsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListPersonalEnvironments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) DeletePersonalEnvironmentJson(ctx context.Context, in *DeletePersonalEnvironmentJsonRequest, opts ...grpc.CallOption) (*DeletePersonalEnvironmentJsonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePersonalEnvironmentJsonResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_DeletePersonalEnvironmentJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) PublishEnvironment(ctx context.Context, in *PublishEnvironmentRequest, opts ...grpc.CallOption) (*PublishEnvironmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishEnvironmentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_PublishEnvironment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) PublishPersonalEnvironment(ctx context.Context, in *PublishPersonalEnvironmentRequest, opts ...grpc.CallOption) (*PublishPersonalEnvironmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishPersonalEnvironmentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_PublishPersonalEnvironment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListTeamEnvironments(ctx context.Context, in *ListTeamEnvironmentsRequest, opts ...grpc.CallOption) (*ListTeamEnvironmentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamEnvironmentsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListTeamEnvironments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) DeleteTeamEnvironment(ctx context.Context, in *DeleteTeamEnvironmentRequest, opts ...grpc.CallOption) (*DeleteTeamEnvironmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamEnvironmentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_DeleteTeamEnvironment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) SetTeamEnvironmentJson(ctx context.Context, in *SetTeamEnvironmentJsonRequest, opts ...grpc.CallOption) (*SetTeamEnvironmentJsonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTeamEnvironmentJsonResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_SetTeamEnvironmentJson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListReposWithLocalEnvironment(ctx context.Context, in *ListReposWithLocalEnvironmentRequest, opts ...grpc.CallOption) (*ListReposWithLocalEnvironmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReposWithLocalEnvironmentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListReposWithLocalEnvironment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) PrepareEnvironmentSetupPR(ctx context.Context, in *PrepareEnvironmentSetupPRRequest, opts ...grpc.CallOption) (*PrepareEnvironmentSetupPRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareEnvironmentSetupPRResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_PrepareEnvironmentSetupPR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) MarkBackgroundComposerRead(ctx context.Context, in *MarkBackgroundComposerReadRequest, opts ...grpc.CallOption) (*MarkBackgroundComposerReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkBackgroundComposerReadResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_MarkBackgroundComposerRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) MarkBackgroundComposerUnread(ctx context.Context, in *MarkBackgroundComposerUnreadRequest, opts ...grpc.CallOption) (*MarkBackgroundComposerUnreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkBackgroundComposerUnreadResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_MarkBackgroundComposerUnread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) NotifyBackgroundComposerShown(ctx context.Context, in *NotifyBackgroundComposerShownRequest, opts ...grpc.CallOption) (*NotifyBackgroundComposerShownResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotifyBackgroundComposerShownResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_NotifyBackgroundComposerShown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) FetchBackgroundComposer(ctx context.Context, in *FetchBackgroundComposerRequest, opts ...grpc.CallOption) (*FetchBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_FetchBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetTurnSummaryBackgroundComposer(ctx context.Context, in *GetTurnSummaryBackgroundComposerRequest, opts ...grpc.CallOption) (*GetTurnSummaryBackgroundComposerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTurnSummaryBackgroundComposerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetTurnSummaryBackgroundComposer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerName(ctx context.Context, in *GetBackgroundComposerNameRequest, opts ...grpc.CallOption) (*GetBackgroundComposerNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerNameResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerPrompt(ctx context.Context, in *GetBackgroundComposerPromptRequest, opts ...grpc.CallOption) (*GetBackgroundComposerPromptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerPromptResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerPrompt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ReadBinaryFile(ctx context.Context, in *ReadBinaryFileRequest, opts ...grpc.CallOption) (*ReadBinaryFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadBinaryFileResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ReadBinaryFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListBackgroundComposerArtifacts(ctx context.Context, in *ListBackgroundComposerArtifactsRequest, opts ...grpc.CallOption) (*ListBackgroundComposerArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackgroundComposerArtifactsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListBackgroundComposerArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerArtifact(ctx context.Context, in *GetBackgroundComposerArtifactRequest, opts ...grpc.CallOption) (*GetBackgroundComposerArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerArtifactResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerArtifactBytes(ctx context.Context, in *GetBackgroundComposerArtifactBytesRequest, opts ...grpc.CallOption) (*GetBackgroundComposerArtifactBytesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerArtifactBytesResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerArtifactBytes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StreamBackgroundComposerArtifact(ctx context.Context, in *StreamBackgroundComposerArtifactRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBackgroundComposerArtifactResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BackgroundComposerService_ServiceDesc.Streams[8], BackgroundComposerService_StreamBackgroundComposerArtifact_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamBackgroundComposerArtifactRequest, StreamBackgroundComposerArtifactResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamBackgroundComposerArtifactClient = grpc.ServerStreamingClient[StreamBackgroundComposerArtifactResponse]

func (c *backgroundComposerServiceClient) UpdateBackgroundComposerUserSettings(ctx context.Context, in *UpdateBackgroundComposerUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBackgroundComposerUserSettingsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_UpdateBackgroundComposerUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerUserSettings(ctx context.Context, in *GetBackgroundComposerUserSettingsRequest, opts ...grpc.CallOption) (*GetBackgroundComposerUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerUserSettingsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) UpdateBackgroundComposerEnvironment(ctx context.Context, in *UpdateBackgroundComposerEnvironmentRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerEnvironmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBackgroundComposerEnvironmentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_UpdateBackgroundComposerEnvironment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetRepositoryBranches(ctx context.Context, in *GetRepositoryBranchesRequest, opts ...grpc.CallOption) (*GetRepositoryBranchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRepositoryBranchesResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetRepositoryBranches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetPullRequestMergeStatus(ctx context.Context, in *GetPullRequestMergeStatusRequest, opts ...grpc.CallOption) (*GetPullRequestMergeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPullRequestMergeStatusResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetPullRequestMergeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetDetailedPullRequestStatus(ctx context.Context, in *GetDetailedPullRequestStatusRequest, opts ...grpc.CallOption) (*GetDetailedPullRequestStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDetailedPullRequestStatusResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetDetailedPullRequestStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) CheckPullRequestMergeability(ctx context.Context, in *CheckPullRequestMergeabilityRequest, opts ...grpc.CallOption) (*CheckPullRequestMergeabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckPullRequestMergeabilityResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_CheckPullRequestMergeability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetPullRequestDiscussions(ctx context.Context, in *GetPullRequestDiscussionsRequest, opts ...grpc.CallOption) (*GetPullRequestDiscussionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPullRequestDiscussionsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetPullRequestDiscussions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ReplyToReviewThread(ctx context.Context, in *ReplyToReviewThreadRequest, opts ...grpc.CallOption) (*ReplyToReviewThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplyToReviewThreadResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ReplyToReviewThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ResolveReviewThread(ctx context.Context, in *ResolveReviewThreadRequest, opts ...grpc.CallOption) (*ResolveReviewThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveReviewThreadResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ResolveReviewThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) AddPullRequestReviewComment(ctx context.Context, in *AddPullRequestReviewCommentRequest, opts ...grpc.CallOption) (*AddPullRequestReviewCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddPullRequestReviewCommentResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_AddPullRequestReviewComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) MergePullRequest(ctx context.Context, in *MergePullRequestRequest, opts ...grpc.CallOption) (*MergePullRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MergePullRequestResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_MergePullRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) EnablePullRequestAutoMerge(ctx context.Context, in *EnablePullRequestAutoMergeRequest, opts ...grpc.CallOption) (*EnablePullRequestAutoMergeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnablePullRequestAutoMergeResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_EnablePullRequestAutoMerge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ConvertPullRequestFromDraft(ctx context.Context, in *ConvertPullRequestFromDraftRequest, opts ...grpc.CallOption) (*ConvertPullRequestFromDraftResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertPullRequestFromDraftResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ConvertPullRequestFromDraft_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) UpdatePullRequestBranch(ctx context.Context, in *UpdatePullRequestBranchRequest, opts ...grpc.CallOption) (*UpdatePullRequestBranchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePullRequestBranchResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_UpdatePullRequestBranch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) RegisterPushNotificationToken(ctx context.Context, in *RegisterPushNotificationTokenRequest, opts ...grpc.CallOption) (*RegisterPushNotificationTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterPushNotificationTokenResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_RegisterPushNotificationToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) DeletePushNotificationToken(ctx context.Context, in *DeletePushNotificationTokenRequest, opts ...grpc.CallOption) (*DeletePushNotificationTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePushNotificationTokenResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_DeletePushNotificationToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) VerifyBackgroundComposerAccess(ctx context.Context, in *VerifyBackgroundComposerAccessRequest, opts ...grpc.CallOption) (*VerifyBackgroundComposerAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyBackgroundComposerAccessResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_VerifyBackgroundComposerAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StartSlackStreamingForFollowup(ctx context.Context, in *StartSlackStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartSlackStreamingForFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartSlackStreamingForFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_StartSlackStreamingForFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StartGithubStreamingForFollowup(ctx context.Context, in *StartGithubStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartGithubStreamingForFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartGithubStreamingForFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_StartGithubStreamingForFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) StartLinearStreamingForFollowup(ctx context.Context, in *StartLinearStreamingForFollowupRequest, opts ...grpc.CallOption) (*StartLinearStreamingForFollowupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartLinearStreamingForFollowupResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_StartLinearStreamingForFollowup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetGithubInstallations(ctx context.Context, in *GetGithubInstallationsRequest, opts ...grpc.CallOption) (*GetGithubInstallationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGithubInstallationsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetGithubInstallations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) FetchAllInstallationRepos(ctx context.Context, in *FetchAllInstallationReposRequest, opts ...grpc.CallOption) (*FetchAllInstallationReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchAllInstallationReposResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_FetchAllInstallationRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetBackgroundComposerVmUsage(ctx context.Context, in *GetBackgroundComposerVmUsageRequest, opts ...grpc.CallOption) (*GetBackgroundComposerVmUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackgroundComposerVmUsageResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetBackgroundComposerVmUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListGrindModeComposers(ctx context.Context, in *ListGrindModeComposersRequest, opts ...grpc.CallOption) (*ListGrindModeComposersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGrindModeComposersResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListGrindModeComposers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetCloudAgentDebugDetails(ctx context.Context, in *GetCloudAgentDebugDetailsRequest, opts ...grpc.CallOption) (*GetCloudAgentDebugDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCloudAgentDebugDetailsResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetCloudAgentDebugDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) CreateAgentShare(ctx context.Context, in *CreateAgentShareRequest, opts ...grpc.CallOption) (*CreateAgentShareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAgentShareResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_CreateAgentShare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetAgentSharePreview(ctx context.Context, in *GetAgentSharePreviewRequest, opts ...grpc.CallOption) (*GetAgentSharePreviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentSharePreviewResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetAgentSharePreview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) ListPrivateWorkers(ctx context.Context, in *ListPrivateWorkersRequest, opts ...grpc.CallOption) (*ListPrivateWorkersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPrivateWorkersResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_ListPrivateWorkers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetPrivateWorkersSummary(ctx context.Context, in *GetPrivateWorkersSummaryRequest, opts ...grpc.CallOption) (*GetPrivateWorkersSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivateWorkersSummaryResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetPrivateWorkersSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundComposerServiceClient) GetPrivateWorker(ctx context.Context, in *GetPrivateWorkerRequest, opts ...grpc.CallOption) (*GetPrivateWorkerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivateWorkerResponse)
	err := c.cc.Invoke(ctx, BackgroundComposerService_GetPrivateWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackgroundComposerServiceServer is the server API for BackgroundComposerService service.
// All implementations must embed UnimplementedBackgroundComposerServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.BackgroundComposerService (var: Qje)
type BackgroundComposerServiceServer interface {
	ListBackgroundComposers(context.Context, *ListBackgroundComposersRequest) (*ListBackgroundComposersResponse, error)
	AttachBackgroundComposer(*AttachBackgroundComposerRequest, grpc.ServerStreamingServer[AttachBackgroundComposerResponse]) error
	StreamInteractionUpdates(*StreamInteractionUpdatesRequest, grpc.ServerStreamingServer[InteractionUpdate]) error
	StreamInteractionUpdatesSSE(*BidiRequestId, grpc.ServerStreamingServer[InteractionUpdate]) error
	StreamConversation(*StreamConversationRequest, grpc.ServerStreamingServer[StreamConversationResponse]) error
	GetLatestAgentConversationState(context.Context, *GetLatestAgentConversationStateRequest) (*GetLatestAgentConversationStateResponse, error)
	GetBlobForAgentKV(context.Context, *GetBlobForAgentKVRequest) (*GetBlobForAgentKVResponse, error)
	AttachBackgroundComposerLogs(*AttachBackgroundComposerLogsRequest, grpc.ServerStreamingServer[AttachBackgroundComposerLogsResponse]) error
	StartBackgroundComposerFromSnapshot(context.Context, *StartBackgroundComposerFromSnapshotRequest) (*StartBackgroundComposerFromSnapshotResponse, error)
	StartParallelAgentWorkflow(context.Context, *StartParallelAgentWorkflowRequest) (*StartParallelAgentWorkflowResponse, error)
	StreamParallelAgentWorkflowStatus(*StreamParallelAgentWorkflowStatusRequest, grpc.ServerStreamingServer[ParallelAgentWorkflowStatusUpdate]) error
	MakePRBackgroundComposer(context.Context, *MakePRBackgroundComposerRequest) (*MakePRBackgroundComposerResponse, error)
	OpenPRBackgroundComposer(context.Context, *OpenPRBackgroundComposerRequest) (*OpenPRBackgroundComposerResponse, error)
	GetBackgroundComposerStatus(context.Context, *GetBackgroundComposerStatusRequest) (*GetBackgroundComposerStatusResponse, error)
	AddAsyncFollowupBackgroundComposer(context.Context, *AddAsyncFollowupBackgroundComposerRequest) (*AddAsyncFollowupBackgroundComposerResponse, error)
	ListPendingFollowups(context.Context, *ListPendingFollowupsRequest) (*ListPendingFollowupsResponse, error)
	UpdatePendingFollowup(context.Context, *UpdatePendingFollowupRequest) (*UpdatePendingFollowupResponse, error)
	DeletePendingFollowup(context.Context, *DeletePendingFollowupRequest) (*DeletePendingFollowupResponse, error)
	ReorderPendingFollowup(context.Context, *ReorderPendingFollowupRequest) (*ReorderPendingFollowupResponse, error)
	SubmitPendingFollowupNow(context.Context, *SubmitPendingFollowupNowRequest) (*SubmitPendingFollowupNowResponse, error)
	GetCursorServerUrl(context.Context, *GetCursorServerUrlRequest) (*GetCursorServerUrlResponse, error)
	PauseBackgroundComposer(context.Context, *PauseBackgroundComposerRequest) (*PauseBackgroundComposerResponse, error)
	ResumeBackgroundComposer(context.Context, *ResumeBackgroundComposerRequest) (*ResumeBackgroundComposerResponse, error)
	ArchiveBackgroundComposer(context.Context, *ArchiveBackgroundComposerRequest) (*ArchiveBackgroundComposerResponse, error)
	GetBackgroundComposerInfo(context.Context, *GetBackgroundComposerInfoRequest) (*GetBackgroundComposerInfoResponse, error)
	GetBackgroundComposerRepositoryInfo(context.Context, *GetBackgroundComposerRepositoryInfoRequest) (*GetBackgroundComposerRepositoryInfoResponse, error)
	GetMachine(context.Context, *GetMachineRequest) (*GetMachineResponse, error)
	ListDetailedBackgroundComposers(context.Context, *ListDetailedBackgroundComposersRequest) (*ListDetailedBackgroundComposersResponse, error)
	GetGithubAccessTokenForRepos(context.Context, *GetGithubAccessTokenForReposRequest) (*GetGithubAccessTokenForReposResponse, error)
	GetBackgroundComposerDiffDetails(context.Context, *GetBackgroundComposerDiffDetailsRequest) (*GetBackgroundComposerDiffDetailsResponse, error)
	GetOptimizedDiffDetails(context.Context, *GetOptimizedDiffDetailsRequest) (*GetOptimizedDiffDetailsResponse, error)
	GetBatchBackgroundComposerStats(context.Context, *GetBatchBackgroundComposerStatsRequest) (*GetBatchBackgroundComposerStatsResponse, error)
	GetBackgroundComposerChangesHash(context.Context, *GetBackgroundComposerChangesHashRequest) (*GetBackgroundComposerChangesHashResponse, error)
	GetBackgroundComposerPullRequest(context.Context, *GetBackgroundComposerPullRequestRequest) (*GetBackgroundComposerPullRequestResponse, error)
	RefreshGithubAccessTokenInBackgroundComposer(context.Context, *RefreshGithubAccessTokenInBackgroundComposerRequest) (*RefreshGithubAccessTokenInBackgroundComposerResponse, error)
	CreateBackgroundComposerPod(context.Context, *CreateBackgroundComposerPodRequest) (*CreateBackgroundComposerPodResponse, error)
	AttachBackgroundComposerPod(*AttachBackgroundComposerPodRequest, grpc.ServerStreamingServer[AttachBackgroundComposerPodResponse]) error
	CreateBackgroundComposerPodSnapshot(context.Context, *CreateBackgroundComposerPodSnapshotRequest) (*CreateBackgroundComposerPodSnapshotResponse, error)
	ChangeBackgroundComposerSnapshotVisibility(context.Context, *ChangeBackgroundComposerSnapshotVisibilityRequest) (*ChangeBackgroundComposerSnapshotVisibilityResponse, error)
	GetBackgroundComposerSnapshotInfo(context.Context, *GetBackgroundComposerSnapshotInfoRequest) (*GetBackgroundComposerSnapshotInfoResponse, error)
	GetBackgroundComposerSnapshotState(context.Context, *GetBackgroundComposerSnapshotStateRequest) (*GetBackgroundComposerSnapshotStateResponse, error)
	WatchBackgroundComposerSnapshotState(*WatchBackgroundComposerSnapshotStateRequest, grpc.ServerStreamingServer[WatchBackgroundComposerSnapshotStateResponse]) error
	GetBackgroundComposerConversation(context.Context, *GetBackgroundComposerConversationRequest) (*GetBackgroundComposerConversationResponse, error)
	RenameBackgroundComposer(context.Context, *RenameBackgroundComposerRequest) (*RenameBackgroundComposerResponse, error)
	CommitBackgroundComposer(context.Context, *CommitBackgroundComposerRequest) (*CommitBackgroundComposerResponse, error)
	SetPersonalEnvironmentJson(context.Context, *SetPersonalEnvironmentJsonRequest) (*SetPersonalEnvironmentJsonResponse, error)
	GetPersonalEnvironmentJson(context.Context, *GetPersonalEnvironmentJsonRequest) (*GetPersonalEnvironmentJsonResponse, error)
	GetEnvironmentJsonCandidates(context.Context, *GetEnvironmentJsonCandidatesRequest) (*GetEnvironmentJsonCandidatesResponse, error)
	ListPersonalEnvironments(context.Context, *ListPersonalEnvironmentsRequest) (*ListPersonalEnvironmentsResponse, error)
	DeletePersonalEnvironmentJson(context.Context, *DeletePersonalEnvironmentJsonRequest) (*DeletePersonalEnvironmentJsonResponse, error)
	PublishEnvironment(context.Context, *PublishEnvironmentRequest) (*PublishEnvironmentResponse, error)
	PublishPersonalEnvironment(context.Context, *PublishPersonalEnvironmentRequest) (*PublishPersonalEnvironmentResponse, error)
	ListTeamEnvironments(context.Context, *ListTeamEnvironmentsRequest) (*ListTeamEnvironmentsResponse, error)
	DeleteTeamEnvironment(context.Context, *DeleteTeamEnvironmentRequest) (*DeleteTeamEnvironmentResponse, error)
	SetTeamEnvironmentJson(context.Context, *SetTeamEnvironmentJsonRequest) (*SetTeamEnvironmentJsonResponse, error)
	ListReposWithLocalEnvironment(context.Context, *ListReposWithLocalEnvironmentRequest) (*ListReposWithLocalEnvironmentResponse, error)
	PrepareEnvironmentSetupPR(context.Context, *PrepareEnvironmentSetupPRRequest) (*PrepareEnvironmentSetupPRResponse, error)
	MarkBackgroundComposerRead(context.Context, *MarkBackgroundComposerReadRequest) (*MarkBackgroundComposerReadResponse, error)
	MarkBackgroundComposerUnread(context.Context, *MarkBackgroundComposerUnreadRequest) (*MarkBackgroundComposerUnreadResponse, error)
	NotifyBackgroundComposerShown(context.Context, *NotifyBackgroundComposerShownRequest) (*NotifyBackgroundComposerShownResponse, error)
	FetchBackgroundComposer(context.Context, *FetchBackgroundComposerRequest) (*FetchBackgroundComposerResponse, error)
	GetTurnSummaryBackgroundComposer(context.Context, *GetTurnSummaryBackgroundComposerRequest) (*GetTurnSummaryBackgroundComposerResponse, error)
	GetBackgroundComposerName(context.Context, *GetBackgroundComposerNameRequest) (*GetBackgroundComposerNameResponse, error)
	GetBackgroundComposerPrompt(context.Context, *GetBackgroundComposerPromptRequest) (*GetBackgroundComposerPromptResponse, error)
	ReadBinaryFile(context.Context, *ReadBinaryFileRequest) (*ReadBinaryFileResponse, error)
	ListBackgroundComposerArtifacts(context.Context, *ListBackgroundComposerArtifactsRequest) (*ListBackgroundComposerArtifactsResponse, error)
	GetBackgroundComposerArtifact(context.Context, *GetBackgroundComposerArtifactRequest) (*GetBackgroundComposerArtifactResponse, error)
	GetBackgroundComposerArtifactBytes(context.Context, *GetBackgroundComposerArtifactBytesRequest) (*GetBackgroundComposerArtifactBytesResponse, error)
	StreamBackgroundComposerArtifact(*StreamBackgroundComposerArtifactRequest, grpc.ServerStreamingServer[StreamBackgroundComposerArtifactResponse]) error
	UpdateBackgroundComposerUserSettings(context.Context, *UpdateBackgroundComposerUserSettingsRequest) (*UpdateBackgroundComposerUserSettingsResponse, error)
	GetBackgroundComposerUserSettings(context.Context, *GetBackgroundComposerUserSettingsRequest) (*GetBackgroundComposerUserSettingsResponse, error)
	UpdateBackgroundComposerEnvironment(context.Context, *UpdateBackgroundComposerEnvironmentRequest) (*UpdateBackgroundComposerEnvironmentResponse, error)
	GetRepositoryBranches(context.Context, *GetRepositoryBranchesRequest) (*GetRepositoryBranchesResponse, error)
	GetPullRequestMergeStatus(context.Context, *GetPullRequestMergeStatusRequest) (*GetPullRequestMergeStatusResponse, error)
	GetDetailedPullRequestStatus(context.Context, *GetDetailedPullRequestStatusRequest) (*GetDetailedPullRequestStatusResponse, error)
	CheckPullRequestMergeability(context.Context, *CheckPullRequestMergeabilityRequest) (*CheckPullRequestMergeabilityResponse, error)
	GetPullRequestDiscussions(context.Context, *GetPullRequestDiscussionsRequest) (*GetPullRequestDiscussionsResponse, error)
	ReplyToReviewThread(context.Context, *ReplyToReviewThreadRequest) (*ReplyToReviewThreadResponse, error)
	ResolveReviewThread(context.Context, *ResolveReviewThreadRequest) (*ResolveReviewThreadResponse, error)
	AddPullRequestReviewComment(context.Context, *AddPullRequestReviewCommentRequest) (*AddPullRequestReviewCommentResponse, error)
	MergePullRequest(context.Context, *MergePullRequestRequest) (*MergePullRequestResponse, error)
	EnablePullRequestAutoMerge(context.Context, *EnablePullRequestAutoMergeRequest) (*EnablePullRequestAutoMergeResponse, error)
	ConvertPullRequestFromDraft(context.Context, *ConvertPullRequestFromDraftRequest) (*ConvertPullRequestFromDraftResponse, error)
	UpdatePullRequestBranch(context.Context, *UpdatePullRequestBranchRequest) (*UpdatePullRequestBranchResponse, error)
	RegisterPushNotificationToken(context.Context, *RegisterPushNotificationTokenRequest) (*RegisterPushNotificationTokenResponse, error)
	DeletePushNotificationToken(context.Context, *DeletePushNotificationTokenRequest) (*DeletePushNotificationTokenResponse, error)
	VerifyBackgroundComposerAccess(context.Context, *VerifyBackgroundComposerAccessRequest) (*VerifyBackgroundComposerAccessResponse, error)
	StartSlackStreamingForFollowup(context.Context, *StartSlackStreamingForFollowupRequest) (*StartSlackStreamingForFollowupResponse, error)
	StartGithubStreamingForFollowup(context.Context, *StartGithubStreamingForFollowupRequest) (*StartGithubStreamingForFollowupResponse, error)
	StartLinearStreamingForFollowup(context.Context, *StartLinearStreamingForFollowupRequest) (*StartLinearStreamingForFollowupResponse, error)
	GetGithubInstallations(context.Context, *GetGithubInstallationsRequest) (*GetGithubInstallationsResponse, error)
	FetchAllInstallationRepos(context.Context, *FetchAllInstallationReposRequest) (*FetchAllInstallationReposResponse, error)
	GetBackgroundComposerVmUsage(context.Context, *GetBackgroundComposerVmUsageRequest) (*GetBackgroundComposerVmUsageResponse, error)
	ListGrindModeComposers(context.Context, *ListGrindModeComposersRequest) (*ListGrindModeComposersResponse, error)
	GetCloudAgentDebugDetails(context.Context, *GetCloudAgentDebugDetailsRequest) (*GetCloudAgentDebugDetailsResponse, error)
	CreateAgentShare(context.Context, *CreateAgentShareRequest) (*CreateAgentShareResponse, error)
	GetAgentSharePreview(context.Context, *GetAgentSharePreviewRequest) (*GetAgentSharePreviewResponse, error)
	ListPrivateWorkers(context.Context, *ListPrivateWorkersRequest) (*ListPrivateWorkersResponse, error)
	GetPrivateWorkersSummary(context.Context, *GetPrivateWorkersSummaryRequest) (*GetPrivateWorkersSummaryResponse, error)
	GetPrivateWorker(context.Context, *GetPrivateWorkerRequest) (*GetPrivateWorkerResponse, error)
	mustEmbedUnimplementedBackgroundComposerServiceServer()
}

// UnimplementedBackgroundComposerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBackgroundComposerServiceServer struct{}

func (UnimplementedBackgroundComposerServiceServer) ListBackgroundComposers(context.Context, *ListBackgroundComposersRequest) (*ListBackgroundComposersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBackgroundComposers not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) AttachBackgroundComposer(*AttachBackgroundComposerRequest, grpc.ServerStreamingServer[AttachBackgroundComposerResponse]) error {
	return status.Error(codes.Unimplemented, "method AttachBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StreamInteractionUpdates(*StreamInteractionUpdatesRequest, grpc.ServerStreamingServer[InteractionUpdate]) error {
	return status.Error(codes.Unimplemented, "method StreamInteractionUpdates not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StreamInteractionUpdatesSSE(*BidiRequestId, grpc.ServerStreamingServer[InteractionUpdate]) error {
	return status.Error(codes.Unimplemented, "method StreamInteractionUpdatesSSE not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StreamConversation(*StreamConversationRequest, grpc.ServerStreamingServer[StreamConversationResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamConversation not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetLatestAgentConversationState(context.Context, *GetLatestAgentConversationStateRequest) (*GetLatestAgentConversationStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestAgentConversationState not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBlobForAgentKV(context.Context, *GetBlobForAgentKVRequest) (*GetBlobForAgentKVResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBlobForAgentKV not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) AttachBackgroundComposerLogs(*AttachBackgroundComposerLogsRequest, grpc.ServerStreamingServer[AttachBackgroundComposerLogsResponse]) error {
	return status.Error(codes.Unimplemented, "method AttachBackgroundComposerLogs not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StartBackgroundComposerFromSnapshot(context.Context, *StartBackgroundComposerFromSnapshotRequest) (*StartBackgroundComposerFromSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartBackgroundComposerFromSnapshot not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StartParallelAgentWorkflow(context.Context, *StartParallelAgentWorkflowRequest) (*StartParallelAgentWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartParallelAgentWorkflow not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StreamParallelAgentWorkflowStatus(*StreamParallelAgentWorkflowStatusRequest, grpc.ServerStreamingServer[ParallelAgentWorkflowStatusUpdate]) error {
	return status.Error(codes.Unimplemented, "method StreamParallelAgentWorkflowStatus not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) MakePRBackgroundComposer(context.Context, *MakePRBackgroundComposerRequest) (*MakePRBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MakePRBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) OpenPRBackgroundComposer(context.Context, *OpenPRBackgroundComposerRequest) (*OpenPRBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OpenPRBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerStatus(context.Context, *GetBackgroundComposerStatusRequest) (*GetBackgroundComposerStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerStatus not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) AddAsyncFollowupBackgroundComposer(context.Context, *AddAsyncFollowupBackgroundComposerRequest) (*AddAsyncFollowupBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddAsyncFollowupBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListPendingFollowups(context.Context, *ListPendingFollowupsRequest) (*ListPendingFollowupsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPendingFollowups not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) UpdatePendingFollowup(context.Context, *UpdatePendingFollowupRequest) (*UpdatePendingFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePendingFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) DeletePendingFollowup(context.Context, *DeletePendingFollowupRequest) (*DeletePendingFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePendingFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ReorderPendingFollowup(context.Context, *ReorderPendingFollowupRequest) (*ReorderPendingFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReorderPendingFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) SubmitPendingFollowupNow(context.Context, *SubmitPendingFollowupNowRequest) (*SubmitPendingFollowupNowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitPendingFollowupNow not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetCursorServerUrl(context.Context, *GetCursorServerUrlRequest) (*GetCursorServerUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCursorServerUrl not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) PauseBackgroundComposer(context.Context, *PauseBackgroundComposerRequest) (*PauseBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ResumeBackgroundComposer(context.Context, *ResumeBackgroundComposerRequest) (*ResumeBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ArchiveBackgroundComposer(context.Context, *ArchiveBackgroundComposerRequest) (*ArchiveBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ArchiveBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerInfo(context.Context, *GetBackgroundComposerInfoRequest) (*GetBackgroundComposerInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerInfo not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerRepositoryInfo(context.Context, *GetBackgroundComposerRepositoryInfoRequest) (*GetBackgroundComposerRepositoryInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerRepositoryInfo not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetMachine(context.Context, *GetMachineRequest) (*GetMachineResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMachine not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListDetailedBackgroundComposers(context.Context, *ListDetailedBackgroundComposersRequest) (*ListDetailedBackgroundComposersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDetailedBackgroundComposers not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetGithubAccessTokenForRepos(context.Context, *GetGithubAccessTokenForReposRequest) (*GetGithubAccessTokenForReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGithubAccessTokenForRepos not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerDiffDetails(context.Context, *GetBackgroundComposerDiffDetailsRequest) (*GetBackgroundComposerDiffDetailsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerDiffDetails not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetOptimizedDiffDetails(context.Context, *GetOptimizedDiffDetailsRequest) (*GetOptimizedDiffDetailsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOptimizedDiffDetails not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBatchBackgroundComposerStats(context.Context, *GetBatchBackgroundComposerStatsRequest) (*GetBatchBackgroundComposerStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBatchBackgroundComposerStats not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerChangesHash(context.Context, *GetBackgroundComposerChangesHashRequest) (*GetBackgroundComposerChangesHashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerChangesHash not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerPullRequest(context.Context, *GetBackgroundComposerPullRequestRequest) (*GetBackgroundComposerPullRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerPullRequest not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) RefreshGithubAccessTokenInBackgroundComposer(context.Context, *RefreshGithubAccessTokenInBackgroundComposerRequest) (*RefreshGithubAccessTokenInBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshGithubAccessTokenInBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) CreateBackgroundComposerPod(context.Context, *CreateBackgroundComposerPodRequest) (*CreateBackgroundComposerPodResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBackgroundComposerPod not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) AttachBackgroundComposerPod(*AttachBackgroundComposerPodRequest, grpc.ServerStreamingServer[AttachBackgroundComposerPodResponse]) error {
	return status.Error(codes.Unimplemented, "method AttachBackgroundComposerPod not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) CreateBackgroundComposerPodSnapshot(context.Context, *CreateBackgroundComposerPodSnapshotRequest) (*CreateBackgroundComposerPodSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBackgroundComposerPodSnapshot not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ChangeBackgroundComposerSnapshotVisibility(context.Context, *ChangeBackgroundComposerSnapshotVisibilityRequest) (*ChangeBackgroundComposerSnapshotVisibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeBackgroundComposerSnapshotVisibility not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerSnapshotInfo(context.Context, *GetBackgroundComposerSnapshotInfoRequest) (*GetBackgroundComposerSnapshotInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerSnapshotInfo not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerSnapshotState(context.Context, *GetBackgroundComposerSnapshotStateRequest) (*GetBackgroundComposerSnapshotStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerSnapshotState not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) WatchBackgroundComposerSnapshotState(*WatchBackgroundComposerSnapshotStateRequest, grpc.ServerStreamingServer[WatchBackgroundComposerSnapshotStateResponse]) error {
	return status.Error(codes.Unimplemented, "method WatchBackgroundComposerSnapshotState not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerConversation(context.Context, *GetBackgroundComposerConversationRequest) (*GetBackgroundComposerConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerConversation not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) RenameBackgroundComposer(context.Context, *RenameBackgroundComposerRequest) (*RenameBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenameBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) CommitBackgroundComposer(context.Context, *CommitBackgroundComposerRequest) (*CommitBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CommitBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) SetPersonalEnvironmentJson(context.Context, *SetPersonalEnvironmentJsonRequest) (*SetPersonalEnvironmentJsonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetPersonalEnvironmentJson not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetPersonalEnvironmentJson(context.Context, *GetPersonalEnvironmentJsonRequest) (*GetPersonalEnvironmentJsonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPersonalEnvironmentJson not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetEnvironmentJsonCandidates(context.Context, *GetEnvironmentJsonCandidatesRequest) (*GetEnvironmentJsonCandidatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEnvironmentJsonCandidates not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListPersonalEnvironments(context.Context, *ListPersonalEnvironmentsRequest) (*ListPersonalEnvironmentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPersonalEnvironments not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) DeletePersonalEnvironmentJson(context.Context, *DeletePersonalEnvironmentJsonRequest) (*DeletePersonalEnvironmentJsonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePersonalEnvironmentJson not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) PublishEnvironment(context.Context, *PublishEnvironmentRequest) (*PublishEnvironmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PublishEnvironment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) PublishPersonalEnvironment(context.Context, *PublishPersonalEnvironmentRequest) (*PublishPersonalEnvironmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PublishPersonalEnvironment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListTeamEnvironments(context.Context, *ListTeamEnvironmentsRequest) (*ListTeamEnvironmentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTeamEnvironments not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) DeleteTeamEnvironment(context.Context, *DeleteTeamEnvironmentRequest) (*DeleteTeamEnvironmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamEnvironment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) SetTeamEnvironmentJson(context.Context, *SetTeamEnvironmentJsonRequest) (*SetTeamEnvironmentJsonResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetTeamEnvironmentJson not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListReposWithLocalEnvironment(context.Context, *ListReposWithLocalEnvironmentRequest) (*ListReposWithLocalEnvironmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListReposWithLocalEnvironment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) PrepareEnvironmentSetupPR(context.Context, *PrepareEnvironmentSetupPRRequest) (*PrepareEnvironmentSetupPRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PrepareEnvironmentSetupPR not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) MarkBackgroundComposerRead(context.Context, *MarkBackgroundComposerReadRequest) (*MarkBackgroundComposerReadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkBackgroundComposerRead not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) MarkBackgroundComposerUnread(context.Context, *MarkBackgroundComposerUnreadRequest) (*MarkBackgroundComposerUnreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkBackgroundComposerUnread not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) NotifyBackgroundComposerShown(context.Context, *NotifyBackgroundComposerShownRequest) (*NotifyBackgroundComposerShownResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NotifyBackgroundComposerShown not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) FetchBackgroundComposer(context.Context, *FetchBackgroundComposerRequest) (*FetchBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetTurnSummaryBackgroundComposer(context.Context, *GetTurnSummaryBackgroundComposerRequest) (*GetTurnSummaryBackgroundComposerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTurnSummaryBackgroundComposer not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerName(context.Context, *GetBackgroundComposerNameRequest) (*GetBackgroundComposerNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerName not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerPrompt(context.Context, *GetBackgroundComposerPromptRequest) (*GetBackgroundComposerPromptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerPrompt not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ReadBinaryFile(context.Context, *ReadBinaryFileRequest) (*ReadBinaryFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadBinaryFile not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListBackgroundComposerArtifacts(context.Context, *ListBackgroundComposerArtifactsRequest) (*ListBackgroundComposerArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBackgroundComposerArtifacts not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerArtifact(context.Context, *GetBackgroundComposerArtifactRequest) (*GetBackgroundComposerArtifactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerArtifact not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerArtifactBytes(context.Context, *GetBackgroundComposerArtifactBytesRequest) (*GetBackgroundComposerArtifactBytesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerArtifactBytes not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StreamBackgroundComposerArtifact(*StreamBackgroundComposerArtifactRequest, grpc.ServerStreamingServer[StreamBackgroundComposerArtifactResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBackgroundComposerArtifact not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) UpdateBackgroundComposerUserSettings(context.Context, *UpdateBackgroundComposerUserSettingsRequest) (*UpdateBackgroundComposerUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBackgroundComposerUserSettings not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerUserSettings(context.Context, *GetBackgroundComposerUserSettingsRequest) (*GetBackgroundComposerUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerUserSettings not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) UpdateBackgroundComposerEnvironment(context.Context, *UpdateBackgroundComposerEnvironmentRequest) (*UpdateBackgroundComposerEnvironmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBackgroundComposerEnvironment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetRepositoryBranches(context.Context, *GetRepositoryBranchesRequest) (*GetRepositoryBranchesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRepositoryBranches not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetPullRequestMergeStatus(context.Context, *GetPullRequestMergeStatusRequest) (*GetPullRequestMergeStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPullRequestMergeStatus not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetDetailedPullRequestStatus(context.Context, *GetDetailedPullRequestStatusRequest) (*GetDetailedPullRequestStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDetailedPullRequestStatus not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) CheckPullRequestMergeability(context.Context, *CheckPullRequestMergeabilityRequest) (*CheckPullRequestMergeabilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckPullRequestMergeability not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetPullRequestDiscussions(context.Context, *GetPullRequestDiscussionsRequest) (*GetPullRequestDiscussionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPullRequestDiscussions not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ReplyToReviewThread(context.Context, *ReplyToReviewThreadRequest) (*ReplyToReviewThreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplyToReviewThread not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ResolveReviewThread(context.Context, *ResolveReviewThreadRequest) (*ResolveReviewThreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveReviewThread not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) AddPullRequestReviewComment(context.Context, *AddPullRequestReviewCommentRequest) (*AddPullRequestReviewCommentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddPullRequestReviewComment not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) MergePullRequest(context.Context, *MergePullRequestRequest) (*MergePullRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MergePullRequest not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) EnablePullRequestAutoMerge(context.Context, *EnablePullRequestAutoMergeRequest) (*EnablePullRequestAutoMergeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnablePullRequestAutoMerge not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ConvertPullRequestFromDraft(context.Context, *ConvertPullRequestFromDraftRequest) (*ConvertPullRequestFromDraftResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConvertPullRequestFromDraft not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) UpdatePullRequestBranch(context.Context, *UpdatePullRequestBranchRequest) (*UpdatePullRequestBranchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePullRequestBranch not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) RegisterPushNotificationToken(context.Context, *RegisterPushNotificationTokenRequest) (*RegisterPushNotificationTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterPushNotificationToken not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) DeletePushNotificationToken(context.Context, *DeletePushNotificationTokenRequest) (*DeletePushNotificationTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeletePushNotificationToken not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) VerifyBackgroundComposerAccess(context.Context, *VerifyBackgroundComposerAccessRequest) (*VerifyBackgroundComposerAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyBackgroundComposerAccess not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StartSlackStreamingForFollowup(context.Context, *StartSlackStreamingForFollowupRequest) (*StartSlackStreamingForFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartSlackStreamingForFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StartGithubStreamingForFollowup(context.Context, *StartGithubStreamingForFollowupRequest) (*StartGithubStreamingForFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartGithubStreamingForFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) StartLinearStreamingForFollowup(context.Context, *StartLinearStreamingForFollowupRequest) (*StartLinearStreamingForFollowupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartLinearStreamingForFollowup not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetGithubInstallations(context.Context, *GetGithubInstallationsRequest) (*GetGithubInstallationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGithubInstallations not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) FetchAllInstallationRepos(context.Context, *FetchAllInstallationReposRequest) (*FetchAllInstallationReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchAllInstallationRepos not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetBackgroundComposerVmUsage(context.Context, *GetBackgroundComposerVmUsageRequest) (*GetBackgroundComposerVmUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackgroundComposerVmUsage not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListGrindModeComposers(context.Context, *ListGrindModeComposersRequest) (*ListGrindModeComposersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGrindModeComposers not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetCloudAgentDebugDetails(context.Context, *GetCloudAgentDebugDetailsRequest) (*GetCloudAgentDebugDetailsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCloudAgentDebugDetails not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) CreateAgentShare(context.Context, *CreateAgentShareRequest) (*CreateAgentShareResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAgentShare not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetAgentSharePreview(context.Context, *GetAgentSharePreviewRequest) (*GetAgentSharePreviewResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentSharePreview not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) ListPrivateWorkers(context.Context, *ListPrivateWorkersRequest) (*ListPrivateWorkersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPrivateWorkers not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetPrivateWorkersSummary(context.Context, *GetPrivateWorkersSummaryRequest) (*GetPrivateWorkersSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrivateWorkersSummary not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) GetPrivateWorker(context.Context, *GetPrivateWorkerRequest) (*GetPrivateWorkerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrivateWorker not implemented")
}
func (UnimplementedBackgroundComposerServiceServer) mustEmbedUnimplementedBackgroundComposerServiceServer() {
}
func (UnimplementedBackgroundComposerServiceServer) testEmbeddedByValue() {}

// UnsafeBackgroundComposerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackgroundComposerServiceServer will
// result in compilation errors.
type UnsafeBackgroundComposerServiceServer interface {
	mustEmbedUnimplementedBackgroundComposerServiceServer()
}

func RegisterBackgroundComposerServiceServer(s grpc.ServiceRegistrar, srv BackgroundComposerServiceServer) {
	// If the following call panics, it indicates UnimplementedBackgroundComposerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BackgroundComposerService_ServiceDesc, srv)
}

func _BackgroundComposerService_ListBackgroundComposers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackgroundComposersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListBackgroundComposers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListBackgroundComposers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListBackgroundComposers(ctx, req.(*ListBackgroundComposersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_AttachBackgroundComposer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachBackgroundComposerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).AttachBackgroundComposer(m, &grpc.GenericServerStream[AttachBackgroundComposerRequest, AttachBackgroundComposerResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerServer = grpc.ServerStreamingServer[AttachBackgroundComposerResponse]

func _BackgroundComposerService_StreamInteractionUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamInteractionUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).StreamInteractionUpdates(m, &grpc.GenericServerStream[StreamInteractionUpdatesRequest, InteractionUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamInteractionUpdatesServer = grpc.ServerStreamingServer[InteractionUpdate]

func _BackgroundComposerService_StreamInteractionUpdatesSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).StreamInteractionUpdatesSSE(m, &grpc.GenericServerStream[BidiRequestId, InteractionUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamInteractionUpdatesSSEServer = grpc.ServerStreamingServer[InteractionUpdate]

func _BackgroundComposerService_StreamConversation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamConversationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).StreamConversation(m, &grpc.GenericServerStream[StreamConversationRequest, StreamConversationResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamConversationServer = grpc.ServerStreamingServer[StreamConversationResponse]

func _BackgroundComposerService_GetLatestAgentConversationState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestAgentConversationStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetLatestAgentConversationState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetLatestAgentConversationState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetLatestAgentConversationState(ctx, req.(*GetLatestAgentConversationStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBlobForAgentKV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlobForAgentKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBlobForAgentKV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBlobForAgentKV_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBlobForAgentKV(ctx, req.(*GetBlobForAgentKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_AttachBackgroundComposerLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachBackgroundComposerLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).AttachBackgroundComposerLogs(m, &grpc.GenericServerStream[AttachBackgroundComposerLogsRequest, AttachBackgroundComposerLogsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerLogsServer = grpc.ServerStreamingServer[AttachBackgroundComposerLogsResponse]

func _BackgroundComposerService_StartBackgroundComposerFromSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBackgroundComposerFromSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).StartBackgroundComposerFromSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_StartBackgroundComposerFromSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).StartBackgroundComposerFromSnapshot(ctx, req.(*StartBackgroundComposerFromSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StartParallelAgentWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartParallelAgentWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).StartParallelAgentWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_StartParallelAgentWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).StartParallelAgentWorkflow(ctx, req.(*StartParallelAgentWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StreamParallelAgentWorkflowStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamParallelAgentWorkflowStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).StreamParallelAgentWorkflowStatus(m, &grpc.GenericServerStream[StreamParallelAgentWorkflowStatusRequest, ParallelAgentWorkflowStatusUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamParallelAgentWorkflowStatusServer = grpc.ServerStreamingServer[ParallelAgentWorkflowStatusUpdate]

func _BackgroundComposerService_MakePRBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MakePRBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).MakePRBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_MakePRBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).MakePRBackgroundComposer(ctx, req.(*MakePRBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_OpenPRBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenPRBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).OpenPRBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_OpenPRBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).OpenPRBackgroundComposer(ctx, req.(*OpenPRBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerStatus(ctx, req.(*GetBackgroundComposerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_AddAsyncFollowupBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAsyncFollowupBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).AddAsyncFollowupBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_AddAsyncFollowupBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).AddAsyncFollowupBackgroundComposer(ctx, req.(*AddAsyncFollowupBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListPendingFollowups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPendingFollowupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListPendingFollowups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListPendingFollowups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListPendingFollowups(ctx, req.(*ListPendingFollowupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_UpdatePendingFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePendingFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).UpdatePendingFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_UpdatePendingFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).UpdatePendingFollowup(ctx, req.(*UpdatePendingFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_DeletePendingFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePendingFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).DeletePendingFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_DeletePendingFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).DeletePendingFollowup(ctx, req.(*DeletePendingFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ReorderPendingFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReorderPendingFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ReorderPendingFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ReorderPendingFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ReorderPendingFollowup(ctx, req.(*ReorderPendingFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_SubmitPendingFollowupNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitPendingFollowupNowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).SubmitPendingFollowupNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_SubmitPendingFollowupNow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).SubmitPendingFollowupNow(ctx, req.(*SubmitPendingFollowupNowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetCursorServerUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCursorServerUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetCursorServerUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetCursorServerUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetCursorServerUrl(ctx, req.(*GetCursorServerUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_PauseBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).PauseBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_PauseBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).PauseBackgroundComposer(ctx, req.(*PauseBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ResumeBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ResumeBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ResumeBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ResumeBackgroundComposer(ctx, req.(*ResumeBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ArchiveBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ArchiveBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ArchiveBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ArchiveBackgroundComposer(ctx, req.(*ArchiveBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerInfo(ctx, req.(*GetBackgroundComposerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerRepositoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerRepositoryInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerRepositoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerRepositoryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerRepositoryInfo(ctx, req.(*GetBackgroundComposerRepositoryInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetMachine(ctx, req.(*GetMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListDetailedBackgroundComposers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDetailedBackgroundComposersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListDetailedBackgroundComposers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListDetailedBackgroundComposers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListDetailedBackgroundComposers(ctx, req.(*ListDetailedBackgroundComposersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetGithubAccessTokenForRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGithubAccessTokenForReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetGithubAccessTokenForRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetGithubAccessTokenForRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetGithubAccessTokenForRepos(ctx, req.(*GetGithubAccessTokenForReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerDiffDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerDiffDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerDiffDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerDiffDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerDiffDetails(ctx, req.(*GetBackgroundComposerDiffDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetOptimizedDiffDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOptimizedDiffDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetOptimizedDiffDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetOptimizedDiffDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetOptimizedDiffDetails(ctx, req.(*GetOptimizedDiffDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBatchBackgroundComposerStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchBackgroundComposerStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBatchBackgroundComposerStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBatchBackgroundComposerStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBatchBackgroundComposerStats(ctx, req.(*GetBatchBackgroundComposerStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerChangesHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerChangesHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerChangesHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerChangesHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerChangesHash(ctx, req.(*GetBackgroundComposerChangesHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerPullRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerPullRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerPullRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerPullRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerPullRequest(ctx, req.(*GetBackgroundComposerPullRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_RefreshGithubAccessTokenInBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshGithubAccessTokenInBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).RefreshGithubAccessTokenInBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_RefreshGithubAccessTokenInBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).RefreshGithubAccessTokenInBackgroundComposer(ctx, req.(*RefreshGithubAccessTokenInBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_CreateBackgroundComposerPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBackgroundComposerPodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).CreateBackgroundComposerPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_CreateBackgroundComposerPod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).CreateBackgroundComposerPod(ctx, req.(*CreateBackgroundComposerPodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_AttachBackgroundComposerPod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AttachBackgroundComposerPodRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).AttachBackgroundComposerPod(m, &grpc.GenericServerStream[AttachBackgroundComposerPodRequest, AttachBackgroundComposerPodResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_AttachBackgroundComposerPodServer = grpc.ServerStreamingServer[AttachBackgroundComposerPodResponse]

func _BackgroundComposerService_CreateBackgroundComposerPodSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBackgroundComposerPodSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).CreateBackgroundComposerPodSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_CreateBackgroundComposerPodSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).CreateBackgroundComposerPodSnapshot(ctx, req.(*CreateBackgroundComposerPodSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ChangeBackgroundComposerSnapshotVisibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeBackgroundComposerSnapshotVisibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ChangeBackgroundComposerSnapshotVisibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ChangeBackgroundComposerSnapshotVisibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ChangeBackgroundComposerSnapshotVisibility(ctx, req.(*ChangeBackgroundComposerSnapshotVisibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerSnapshotInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerSnapshotInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerSnapshotInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerSnapshotInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerSnapshotInfo(ctx, req.(*GetBackgroundComposerSnapshotInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerSnapshotState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerSnapshotStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerSnapshotState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerSnapshotState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerSnapshotState(ctx, req.(*GetBackgroundComposerSnapshotStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_WatchBackgroundComposerSnapshotState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchBackgroundComposerSnapshotStateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).WatchBackgroundComposerSnapshotState(m, &grpc.GenericServerStream[WatchBackgroundComposerSnapshotStateRequest, WatchBackgroundComposerSnapshotStateResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_WatchBackgroundComposerSnapshotStateServer = grpc.ServerStreamingServer[WatchBackgroundComposerSnapshotStateResponse]

func _BackgroundComposerService_GetBackgroundComposerConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerConversation(ctx, req.(*GetBackgroundComposerConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_RenameBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).RenameBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_RenameBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).RenameBackgroundComposer(ctx, req.(*RenameBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_CommitBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).CommitBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_CommitBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).CommitBackgroundComposer(ctx, req.(*CommitBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_SetPersonalEnvironmentJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPersonalEnvironmentJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).SetPersonalEnvironmentJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_SetPersonalEnvironmentJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).SetPersonalEnvironmentJson(ctx, req.(*SetPersonalEnvironmentJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetPersonalEnvironmentJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPersonalEnvironmentJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetPersonalEnvironmentJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetPersonalEnvironmentJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetPersonalEnvironmentJson(ctx, req.(*GetPersonalEnvironmentJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetEnvironmentJsonCandidates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEnvironmentJsonCandidatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetEnvironmentJsonCandidates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetEnvironmentJsonCandidates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetEnvironmentJsonCandidates(ctx, req.(*GetEnvironmentJsonCandidatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListPersonalEnvironments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPersonalEnvironmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListPersonalEnvironments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListPersonalEnvironments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListPersonalEnvironments(ctx, req.(*ListPersonalEnvironmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_DeletePersonalEnvironmentJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePersonalEnvironmentJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).DeletePersonalEnvironmentJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_DeletePersonalEnvironmentJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).DeletePersonalEnvironmentJson(ctx, req.(*DeletePersonalEnvironmentJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_PublishEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishEnvironmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).PublishEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_PublishEnvironment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).PublishEnvironment(ctx, req.(*PublishEnvironmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_PublishPersonalEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishPersonalEnvironmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).PublishPersonalEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_PublishPersonalEnvironment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).PublishPersonalEnvironment(ctx, req.(*PublishPersonalEnvironmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListTeamEnvironments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamEnvironmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListTeamEnvironments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListTeamEnvironments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListTeamEnvironments(ctx, req.(*ListTeamEnvironmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_DeleteTeamEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamEnvironmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).DeleteTeamEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_DeleteTeamEnvironment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).DeleteTeamEnvironment(ctx, req.(*DeleteTeamEnvironmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_SetTeamEnvironmentJson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTeamEnvironmentJsonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).SetTeamEnvironmentJson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_SetTeamEnvironmentJson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).SetTeamEnvironmentJson(ctx, req.(*SetTeamEnvironmentJsonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListReposWithLocalEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReposWithLocalEnvironmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListReposWithLocalEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListReposWithLocalEnvironment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListReposWithLocalEnvironment(ctx, req.(*ListReposWithLocalEnvironmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_PrepareEnvironmentSetupPR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareEnvironmentSetupPRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).PrepareEnvironmentSetupPR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_PrepareEnvironmentSetupPR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).PrepareEnvironmentSetupPR(ctx, req.(*PrepareEnvironmentSetupPRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_MarkBackgroundComposerRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkBackgroundComposerReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).MarkBackgroundComposerRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_MarkBackgroundComposerRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).MarkBackgroundComposerRead(ctx, req.(*MarkBackgroundComposerReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_MarkBackgroundComposerUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkBackgroundComposerUnreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).MarkBackgroundComposerUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_MarkBackgroundComposerUnread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).MarkBackgroundComposerUnread(ctx, req.(*MarkBackgroundComposerUnreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_NotifyBackgroundComposerShown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyBackgroundComposerShownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).NotifyBackgroundComposerShown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_NotifyBackgroundComposerShown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).NotifyBackgroundComposerShown(ctx, req.(*NotifyBackgroundComposerShownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_FetchBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).FetchBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_FetchBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).FetchBackgroundComposer(ctx, req.(*FetchBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetTurnSummaryBackgroundComposer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTurnSummaryBackgroundComposerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetTurnSummaryBackgroundComposer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetTurnSummaryBackgroundComposer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetTurnSummaryBackgroundComposer(ctx, req.(*GetTurnSummaryBackgroundComposerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerName(ctx, req.(*GetBackgroundComposerNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerPrompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerPromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerPrompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerPrompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerPrompt(ctx, req.(*GetBackgroundComposerPromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ReadBinaryFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadBinaryFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ReadBinaryFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ReadBinaryFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ReadBinaryFile(ctx, req.(*ReadBinaryFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListBackgroundComposerArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackgroundComposerArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListBackgroundComposerArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListBackgroundComposerArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListBackgroundComposerArtifacts(ctx, req.(*ListBackgroundComposerArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerArtifact(ctx, req.(*GetBackgroundComposerArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerArtifactBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerArtifactBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerArtifactBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerArtifactBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerArtifactBytes(ctx, req.(*GetBackgroundComposerArtifactBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StreamBackgroundComposerArtifact_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamBackgroundComposerArtifactRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackgroundComposerServiceServer).StreamBackgroundComposerArtifact(m, &grpc.GenericServerStream[StreamBackgroundComposerArtifactRequest, StreamBackgroundComposerArtifactResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BackgroundComposerService_StreamBackgroundComposerArtifactServer = grpc.ServerStreamingServer[StreamBackgroundComposerArtifactResponse]

func _BackgroundComposerService_UpdateBackgroundComposerUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBackgroundComposerUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).UpdateBackgroundComposerUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_UpdateBackgroundComposerUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).UpdateBackgroundComposerUserSettings(ctx, req.(*UpdateBackgroundComposerUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerUserSettings(ctx, req.(*GetBackgroundComposerUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_UpdateBackgroundComposerEnvironment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBackgroundComposerEnvironmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).UpdateBackgroundComposerEnvironment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_UpdateBackgroundComposerEnvironment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).UpdateBackgroundComposerEnvironment(ctx, req.(*UpdateBackgroundComposerEnvironmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetRepositoryBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepositoryBranchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetRepositoryBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetRepositoryBranches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetRepositoryBranches(ctx, req.(*GetRepositoryBranchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetPullRequestMergeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPullRequestMergeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetPullRequestMergeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetPullRequestMergeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetPullRequestMergeStatus(ctx, req.(*GetPullRequestMergeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetDetailedPullRequestStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDetailedPullRequestStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetDetailedPullRequestStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetDetailedPullRequestStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetDetailedPullRequestStatus(ctx, req.(*GetDetailedPullRequestStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_CheckPullRequestMergeability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckPullRequestMergeabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).CheckPullRequestMergeability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_CheckPullRequestMergeability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).CheckPullRequestMergeability(ctx, req.(*CheckPullRequestMergeabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetPullRequestDiscussions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPullRequestDiscussionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetPullRequestDiscussions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetPullRequestDiscussions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetPullRequestDiscussions(ctx, req.(*GetPullRequestDiscussionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ReplyToReviewThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyToReviewThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ReplyToReviewThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ReplyToReviewThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ReplyToReviewThread(ctx, req.(*ReplyToReviewThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ResolveReviewThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveReviewThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ResolveReviewThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ResolveReviewThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ResolveReviewThread(ctx, req.(*ResolveReviewThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_AddPullRequestReviewComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPullRequestReviewCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).AddPullRequestReviewComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_AddPullRequestReviewComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).AddPullRequestReviewComment(ctx, req.(*AddPullRequestReviewCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_MergePullRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergePullRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).MergePullRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_MergePullRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).MergePullRequest(ctx, req.(*MergePullRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_EnablePullRequestAutoMerge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnablePullRequestAutoMergeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).EnablePullRequestAutoMerge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_EnablePullRequestAutoMerge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).EnablePullRequestAutoMerge(ctx, req.(*EnablePullRequestAutoMergeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ConvertPullRequestFromDraft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertPullRequestFromDraftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ConvertPullRequestFromDraft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ConvertPullRequestFromDraft_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ConvertPullRequestFromDraft(ctx, req.(*ConvertPullRequestFromDraftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_UpdatePullRequestBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePullRequestBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).UpdatePullRequestBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_UpdatePullRequestBranch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).UpdatePullRequestBranch(ctx, req.(*UpdatePullRequestBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_RegisterPushNotificationToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPushNotificationTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).RegisterPushNotificationToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_RegisterPushNotificationToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).RegisterPushNotificationToken(ctx, req.(*RegisterPushNotificationTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_DeletePushNotificationToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePushNotificationTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).DeletePushNotificationToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_DeletePushNotificationToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).DeletePushNotificationToken(ctx, req.(*DeletePushNotificationTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_VerifyBackgroundComposerAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyBackgroundComposerAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).VerifyBackgroundComposerAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_VerifyBackgroundComposerAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).VerifyBackgroundComposerAccess(ctx, req.(*VerifyBackgroundComposerAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StartSlackStreamingForFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSlackStreamingForFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).StartSlackStreamingForFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_StartSlackStreamingForFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).StartSlackStreamingForFollowup(ctx, req.(*StartSlackStreamingForFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StartGithubStreamingForFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartGithubStreamingForFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).StartGithubStreamingForFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_StartGithubStreamingForFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).StartGithubStreamingForFollowup(ctx, req.(*StartGithubStreamingForFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_StartLinearStreamingForFollowup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartLinearStreamingForFollowupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).StartLinearStreamingForFollowup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_StartLinearStreamingForFollowup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).StartLinearStreamingForFollowup(ctx, req.(*StartLinearStreamingForFollowupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetGithubInstallations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGithubInstallationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetGithubInstallations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetGithubInstallations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetGithubInstallations(ctx, req.(*GetGithubInstallationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_FetchAllInstallationRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAllInstallationReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).FetchAllInstallationRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_FetchAllInstallationRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).FetchAllInstallationRepos(ctx, req.(*FetchAllInstallationReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetBackgroundComposerVmUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundComposerVmUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerVmUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetBackgroundComposerVmUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetBackgroundComposerVmUsage(ctx, req.(*GetBackgroundComposerVmUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListGrindModeComposers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGrindModeComposersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListGrindModeComposers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListGrindModeComposers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListGrindModeComposers(ctx, req.(*ListGrindModeComposersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetCloudAgentDebugDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCloudAgentDebugDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetCloudAgentDebugDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetCloudAgentDebugDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetCloudAgentDebugDetails(ctx, req.(*GetCloudAgentDebugDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_CreateAgentShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).CreateAgentShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_CreateAgentShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).CreateAgentShare(ctx, req.(*CreateAgentShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetAgentSharePreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentSharePreviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetAgentSharePreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetAgentSharePreview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetAgentSharePreview(ctx, req.(*GetAgentSharePreviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_ListPrivateWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrivateWorkersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).ListPrivateWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_ListPrivateWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).ListPrivateWorkers(ctx, req.(*ListPrivateWorkersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetPrivateWorkersSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateWorkersSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetPrivateWorkersSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetPrivateWorkersSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetPrivateWorkersSummary(ctx, req.(*GetPrivateWorkersSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundComposerService_GetPrivateWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundComposerServiceServer).GetPrivateWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundComposerService_GetPrivateWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundComposerServiceServer).GetPrivateWorker(ctx, req.(*GetPrivateWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackgroundComposerService_ServiceDesc is the grpc.ServiceDesc for BackgroundComposerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackgroundComposerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.BackgroundComposerService",
	HandlerType: (*BackgroundComposerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBackgroundComposers",
			Handler:    _BackgroundComposerService_ListBackgroundComposers_Handler,
		},
		{
			MethodName: "GetLatestAgentConversationState",
			Handler:    _BackgroundComposerService_GetLatestAgentConversationState_Handler,
		},
		{
			MethodName: "GetBlobForAgentKV",
			Handler:    _BackgroundComposerService_GetBlobForAgentKV_Handler,
		},
		{
			MethodName: "StartBackgroundComposerFromSnapshot",
			Handler:    _BackgroundComposerService_StartBackgroundComposerFromSnapshot_Handler,
		},
		{
			MethodName: "StartParallelAgentWorkflow",
			Handler:    _BackgroundComposerService_StartParallelAgentWorkflow_Handler,
		},
		{
			MethodName: "MakePRBackgroundComposer",
			Handler:    _BackgroundComposerService_MakePRBackgroundComposer_Handler,
		},
		{
			MethodName: "OpenPRBackgroundComposer",
			Handler:    _BackgroundComposerService_OpenPRBackgroundComposer_Handler,
		},
		{
			MethodName: "GetBackgroundComposerStatus",
			Handler:    _BackgroundComposerService_GetBackgroundComposerStatus_Handler,
		},
		{
			MethodName: "AddAsyncFollowupBackgroundComposer",
			Handler:    _BackgroundComposerService_AddAsyncFollowupBackgroundComposer_Handler,
		},
		{
			MethodName: "ListPendingFollowups",
			Handler:    _BackgroundComposerService_ListPendingFollowups_Handler,
		},
		{
			MethodName: "UpdatePendingFollowup",
			Handler:    _BackgroundComposerService_UpdatePendingFollowup_Handler,
		},
		{
			MethodName: "DeletePendingFollowup",
			Handler:    _BackgroundComposerService_DeletePendingFollowup_Handler,
		},
		{
			MethodName: "ReorderPendingFollowup",
			Handler:    _BackgroundComposerService_ReorderPendingFollowup_Handler,
		},
		{
			MethodName: "SubmitPendingFollowupNow",
			Handler:    _BackgroundComposerService_SubmitPendingFollowupNow_Handler,
		},
		{
			MethodName: "GetCursorServerUrl",
			Handler:    _BackgroundComposerService_GetCursorServerUrl_Handler,
		},
		{
			MethodName: "PauseBackgroundComposer",
			Handler:    _BackgroundComposerService_PauseBackgroundComposer_Handler,
		},
		{
			MethodName: "ResumeBackgroundComposer",
			Handler:    _BackgroundComposerService_ResumeBackgroundComposer_Handler,
		},
		{
			MethodName: "ArchiveBackgroundComposer",
			Handler:    _BackgroundComposerService_ArchiveBackgroundComposer_Handler,
		},
		{
			MethodName: "GetBackgroundComposerInfo",
			Handler:    _BackgroundComposerService_GetBackgroundComposerInfo_Handler,
		},
		{
			MethodName: "GetBackgroundComposerRepositoryInfo",
			Handler:    _BackgroundComposerService_GetBackgroundComposerRepositoryInfo_Handler,
		},
		{
			MethodName: "GetMachine",
			Handler:    _BackgroundComposerService_GetMachine_Handler,
		},
		{
			MethodName: "ListDetailedBackgroundComposers",
			Handler:    _BackgroundComposerService_ListDetailedBackgroundComposers_Handler,
		},
		{
			MethodName: "GetGithubAccessTokenForRepos",
			Handler:    _BackgroundComposerService_GetGithubAccessTokenForRepos_Handler,
		},
		{
			MethodName: "GetBackgroundComposerDiffDetails",
			Handler:    _BackgroundComposerService_GetBackgroundComposerDiffDetails_Handler,
		},
		{
			MethodName: "GetOptimizedDiffDetails",
			Handler:    _BackgroundComposerService_GetOptimizedDiffDetails_Handler,
		},
		{
			MethodName: "GetBatchBackgroundComposerStats",
			Handler:    _BackgroundComposerService_GetBatchBackgroundComposerStats_Handler,
		},
		{
			MethodName: "GetBackgroundComposerChangesHash",
			Handler:    _BackgroundComposerService_GetBackgroundComposerChangesHash_Handler,
		},
		{
			MethodName: "GetBackgroundComposerPullRequest",
			Handler:    _BackgroundComposerService_GetBackgroundComposerPullRequest_Handler,
		},
		{
			MethodName: "RefreshGithubAccessTokenInBackgroundComposer",
			Handler:    _BackgroundComposerService_RefreshGithubAccessTokenInBackgroundComposer_Handler,
		},
		{
			MethodName: "CreateBackgroundComposerPod",
			Handler:    _BackgroundComposerService_CreateBackgroundComposerPod_Handler,
		},
		{
			MethodName: "CreateBackgroundComposerPodSnapshot",
			Handler:    _BackgroundComposerService_CreateBackgroundComposerPodSnapshot_Handler,
		},
		{
			MethodName: "ChangeBackgroundComposerSnapshotVisibility",
			Handler:    _BackgroundComposerService_ChangeBackgroundComposerSnapshotVisibility_Handler,
		},
		{
			MethodName: "GetBackgroundComposerSnapshotInfo",
			Handler:    _BackgroundComposerService_GetBackgroundComposerSnapshotInfo_Handler,
		},
		{
			MethodName: "GetBackgroundComposerSnapshotState",
			Handler:    _BackgroundComposerService_GetBackgroundComposerSnapshotState_Handler,
		},
		{
			MethodName: "GetBackgroundComposerConversation",
			Handler:    _BackgroundComposerService_GetBackgroundComposerConversation_Handler,
		},
		{
			MethodName: "RenameBackgroundComposer",
			Handler:    _BackgroundComposerService_RenameBackgroundComposer_Handler,
		},
		{
			MethodName: "CommitBackgroundComposer",
			Handler:    _BackgroundComposerService_CommitBackgroundComposer_Handler,
		},
		{
			MethodName: "SetPersonalEnvironmentJson",
			Handler:    _BackgroundComposerService_SetPersonalEnvironmentJson_Handler,
		},
		{
			MethodName: "GetPersonalEnvironmentJson",
			Handler:    _BackgroundComposerService_GetPersonalEnvironmentJson_Handler,
		},
		{
			MethodName: "GetEnvironmentJsonCandidates",
			Handler:    _BackgroundComposerService_GetEnvironmentJsonCandidates_Handler,
		},
		{
			MethodName: "ListPersonalEnvironments",
			Handler:    _BackgroundComposerService_ListPersonalEnvironments_Handler,
		},
		{
			MethodName: "DeletePersonalEnvironmentJson",
			Handler:    _BackgroundComposerService_DeletePersonalEnvironmentJson_Handler,
		},
		{
			MethodName: "PublishEnvironment",
			Handler:    _BackgroundComposerService_PublishEnvironment_Handler,
		},
		{
			MethodName: "PublishPersonalEnvironment",
			Handler:    _BackgroundComposerService_PublishPersonalEnvironment_Handler,
		},
		{
			MethodName: "ListTeamEnvironments",
			Handler:    _BackgroundComposerService_ListTeamEnvironments_Handler,
		},
		{
			MethodName: "DeleteTeamEnvironment",
			Handler:    _BackgroundComposerService_DeleteTeamEnvironment_Handler,
		},
		{
			MethodName: "SetTeamEnvironmentJson",
			Handler:    _BackgroundComposerService_SetTeamEnvironmentJson_Handler,
		},
		{
			MethodName: "ListReposWithLocalEnvironment",
			Handler:    _BackgroundComposerService_ListReposWithLocalEnvironment_Handler,
		},
		{
			MethodName: "PrepareEnvironmentSetupPR",
			Handler:    _BackgroundComposerService_PrepareEnvironmentSetupPR_Handler,
		},
		{
			MethodName: "MarkBackgroundComposerRead",
			Handler:    _BackgroundComposerService_MarkBackgroundComposerRead_Handler,
		},
		{
			MethodName: "MarkBackgroundComposerUnread",
			Handler:    _BackgroundComposerService_MarkBackgroundComposerUnread_Handler,
		},
		{
			MethodName: "NotifyBackgroundComposerShown",
			Handler:    _BackgroundComposerService_NotifyBackgroundComposerShown_Handler,
		},
		{
			MethodName: "FetchBackgroundComposer",
			Handler:    _BackgroundComposerService_FetchBackgroundComposer_Handler,
		},
		{
			MethodName: "GetTurnSummaryBackgroundComposer",
			Handler:    _BackgroundComposerService_GetTurnSummaryBackgroundComposer_Handler,
		},
		{
			MethodName: "GetBackgroundComposerName",
			Handler:    _BackgroundComposerService_GetBackgroundComposerName_Handler,
		},
		{
			MethodName: "GetBackgroundComposerPrompt",
			Handler:    _BackgroundComposerService_GetBackgroundComposerPrompt_Handler,
		},
		{
			MethodName: "ReadBinaryFile",
			Handler:    _BackgroundComposerService_ReadBinaryFile_Handler,
		},
		{
			MethodName: "ListBackgroundComposerArtifacts",
			Handler:    _BackgroundComposerService_ListBackgroundComposerArtifacts_Handler,
		},
		{
			MethodName: "GetBackgroundComposerArtifact",
			Handler:    _BackgroundComposerService_GetBackgroundComposerArtifact_Handler,
		},
		{
			MethodName: "GetBackgroundComposerArtifactBytes",
			Handler:    _BackgroundComposerService_GetBackgroundComposerArtifactBytes_Handler,
		},
		{
			MethodName: "UpdateBackgroundComposerUserSettings",
			Handler:    _BackgroundComposerService_UpdateBackgroundComposerUserSettings_Handler,
		},
		{
			MethodName: "GetBackgroundComposerUserSettings",
			Handler:    _BackgroundComposerService_GetBackgroundComposerUserSettings_Handler,
		},
		{
			MethodName: "UpdateBackgroundComposerEnvironment",
			Handler:    _BackgroundComposerService_UpdateBackgroundComposerEnvironment_Handler,
		},
		{
			MethodName: "GetRepositoryBranches",
			Handler:    _BackgroundComposerService_GetRepositoryBranches_Handler,
		},
		{
			MethodName: "GetPullRequestMergeStatus",
			Handler:    _BackgroundComposerService_GetPullRequestMergeStatus_Handler,
		},
		{
			MethodName: "GetDetailedPullRequestStatus",
			Handler:    _BackgroundComposerService_GetDetailedPullRequestStatus_Handler,
		},
		{
			MethodName: "CheckPullRequestMergeability",
			Handler:    _BackgroundComposerService_CheckPullRequestMergeability_Handler,
		},
		{
			MethodName: "GetPullRequestDiscussions",
			Handler:    _BackgroundComposerService_GetPullRequestDiscussions_Handler,
		},
		{
			MethodName: "ReplyToReviewThread",
			Handler:    _BackgroundComposerService_ReplyToReviewThread_Handler,
		},
		{
			MethodName: "ResolveReviewThread",
			Handler:    _BackgroundComposerService_ResolveReviewThread_Handler,
		},
		{
			MethodName: "AddPullRequestReviewComment",
			Handler:    _BackgroundComposerService_AddPullRequestReviewComment_Handler,
		},
		{
			MethodName: "MergePullRequest",
			Handler:    _BackgroundComposerService_MergePullRequest_Handler,
		},
		{
			MethodName: "EnablePullRequestAutoMerge",
			Handler:    _BackgroundComposerService_EnablePullRequestAutoMerge_Handler,
		},
		{
			MethodName: "ConvertPullRequestFromDraft",
			Handler:    _BackgroundComposerService_ConvertPullRequestFromDraft_Handler,
		},
		{
			MethodName: "UpdatePullRequestBranch",
			Handler:    _BackgroundComposerService_UpdatePullRequestBranch_Handler,
		},
		{
			MethodName: "RegisterPushNotificationToken",
			Handler:    _BackgroundComposerService_RegisterPushNotificationToken_Handler,
		},
		{
			MethodName: "DeletePushNotificationToken",
			Handler:    _BackgroundComposerService_DeletePushNotificationToken_Handler,
		},
		{
			MethodName: "VerifyBackgroundComposerAccess",
			Handler:    _BackgroundComposerService_VerifyBackgroundComposerAccess_Handler,
		},
		{
			MethodName: "StartSlackStreamingForFollowup",
			Handler:    _BackgroundComposerService_StartSlackStreamingForFollowup_Handler,
		},
		{
			MethodName: "StartGithubStreamingForFollowup",
			Handler:    _BackgroundComposerService_StartGithubStreamingForFollowup_Handler,
		},
		{
			MethodName: "StartLinearStreamingForFollowup",
			Handler:    _BackgroundComposerService_StartLinearStreamingForFollowup_Handler,
		},
		{
			MethodName: "GetGithubInstallations",
			Handler:    _BackgroundComposerService_GetGithubInstallations_Handler,
		},
		{
			MethodName: "FetchAllInstallationRepos",
			Handler:    _BackgroundComposerService_FetchAllInstallationRepos_Handler,
		},
		{
			MethodName: "GetBackgroundComposerVmUsage",
			Handler:    _BackgroundComposerService_GetBackgroundComposerVmUsage_Handler,
		},
		{
			MethodName: "ListGrindModeComposers",
			Handler:    _BackgroundComposerService_ListGrindModeComposers_Handler,
		},
		{
			MethodName: "GetCloudAgentDebugDetails",
			Handler:    _BackgroundComposerService_GetCloudAgentDebugDetails_Handler,
		},
		{
			MethodName: "CreateAgentShare",
			Handler:    _BackgroundComposerService_CreateAgentShare_Handler,
		},
		{
			MethodName: "GetAgentSharePreview",
			Handler:    _BackgroundComposerService_GetAgentSharePreview_Handler,
		},
		{
			MethodName: "ListPrivateWorkers",
			Handler:    _BackgroundComposerService_ListPrivateWorkers_Handler,
		},
		{
			MethodName: "GetPrivateWorkersSummary",
			Handler:    _BackgroundComposerService_GetPrivateWorkersSummary_Handler,
		},
		{
			MethodName: "GetPrivateWorker",
			Handler:    _BackgroundComposerService_GetPrivateWorker_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AttachBackgroundComposer",
			Handler:       _BackgroundComposerService_AttachBackgroundComposer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamInteractionUpdates",
			Handler:       _BackgroundComposerService_StreamInteractionUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamInteractionUpdatesSSE",
			Handler:       _BackgroundComposerService_StreamInteractionUpdatesSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamConversation",
			Handler:       _BackgroundComposerService_StreamConversation_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AttachBackgroundComposerLogs",
			Handler:       _BackgroundComposerService_AttachBackgroundComposerLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamParallelAgentWorkflowStatus",
			Handler:       _BackgroundComposerService_StreamParallelAgentWorkflowStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AttachBackgroundComposerPod",
			Handler:       _BackgroundComposerService_AttachBackgroundComposerPod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchBackgroundComposerSnapshotState",
			Handler:       _BackgroundComposerService_WatchBackgroundComposerSnapshotState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBackgroundComposerArtifact",
			Handler:       _BackgroundComposerService_StreamBackgroundComposerArtifact_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	BidiService_BidiAppend_FullMethodName = "/aiserver.v1.BidiService/BidiAppend"
)

// BidiServiceClient is the client API for BidiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.BidiService (var: gVe)
type BidiServiceClient interface {
	BidiAppend(ctx context.Context, in *BidiAppendRequest, opts ...grpc.CallOption) (*BidiAppendResponse, error)
}

type bidiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBidiServiceClient(cc grpc.ClientConnInterface) BidiServiceClient {
	return &bidiServiceClient{cc}
}

func (c *bidiServiceClient) BidiAppend(ctx context.Context, in *BidiAppendRequest, opts ...grpc.CallOption) (*BidiAppendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BidiAppendResponse)
	err := c.cc.Invoke(ctx, BidiService_BidiAppend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BidiServiceServer is the server API for BidiService service.
// All implementations must embed UnimplementedBidiServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.BidiService (var: gVe)
type BidiServiceServer interface {
	BidiAppend(context.Context, *BidiAppendRequest) (*BidiAppendResponse, error)
	mustEmbedUnimplementedBidiServiceServer()
}

// UnimplementedBidiServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBidiServiceServer struct{}

func (UnimplementedBidiServiceServer) BidiAppend(context.Context, *BidiAppendRequest) (*BidiAppendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BidiAppend not implemented")
}
func (UnimplementedBidiServiceServer) mustEmbedUnimplementedBidiServiceServer() {}
func (UnimplementedBidiServiceServer) testEmbeddedByValue()                     {}

// UnsafeBidiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BidiServiceServer will
// result in compilation errors.
type UnsafeBidiServiceServer interface {
	mustEmbedUnimplementedBidiServiceServer()
}

func RegisterBidiServiceServer(s grpc.ServiceRegistrar, srv BidiServiceServer) {
	// If the following call panics, it indicates UnimplementedBidiServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BidiService_ServiceDesc, srv)
}

func _BidiService_BidiAppend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidiAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidiServiceServer).BidiAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BidiService_BidiAppend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidiServiceServer).BidiAppend(ctx, req.(*BidiAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BidiService_ServiceDesc is the grpc.ServiceDesc for BidiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BidiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.BidiService",
	HandlerType: (*BidiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BidiAppend",
			Handler:    _BidiService_BidiAppend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	BugbotAdminService_GetTeamTrialEnd_FullMethodName    = "/aiserver.v1.BugbotAdminService/GetTeamTrialEnd"
	BugbotAdminService_SetTeamTrialEnd_FullMethodName    = "/aiserver.v1.BugbotAdminService/SetTeamTrialEnd"
	BugbotAdminService_GetProUserTrialEnd_FullMethodName = "/aiserver.v1.BugbotAdminService/GetProUserTrialEnd"
	BugbotAdminService_SetProUserTrialEnd_FullMethodName = "/aiserver.v1.BugbotAdminService/SetProUserTrialEnd"
	BugbotAdminService_GetRepoNodeId_FullMethodName      = "/aiserver.v1.BugbotAdminService/GetRepoNodeId"
)

// BugbotAdminServiceClient is the client API for BugbotAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.BugbotAdminService (var: Zje)
type BugbotAdminServiceClient interface {
	GetTeamTrialEnd(ctx context.Context, in *GetTeamTrialEndRequest, opts ...grpc.CallOption) (*GetTeamTrialEndResponse, error)
	SetTeamTrialEnd(ctx context.Context, in *SetTeamTrialEndRequest, opts ...grpc.CallOption) (*SetTeamTrialEndResponse, error)
	GetProUserTrialEnd(ctx context.Context, in *GetProUserTrialEndRequest, opts ...grpc.CallOption) (*GetProUserTrialEndResponse, error)
	SetProUserTrialEnd(ctx context.Context, in *SetProUserTrialEndRequest, opts ...grpc.CallOption) (*SetProUserTrialEndResponse, error)
	GetRepoNodeId(ctx context.Context, in *GetRepoNodeIdRequest, opts ...grpc.CallOption) (*GetRepoNodeIdResponse, error)
}

type bugbotAdminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBugbotAdminServiceClient(cc grpc.ClientConnInterface) BugbotAdminServiceClient {
	return &bugbotAdminServiceClient{cc}
}

func (c *bugbotAdminServiceClient) GetTeamTrialEnd(ctx context.Context, in *GetTeamTrialEndRequest, opts ...grpc.CallOption) (*GetTeamTrialEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamTrialEndResponse)
	err := c.cc.Invoke(ctx, BugbotAdminService_GetTeamTrialEnd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bugbotAdminServiceClient) SetTeamTrialEnd(ctx context.Context, in *SetTeamTrialEndRequest, opts ...grpc.CallOption) (*SetTeamTrialEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTeamTrialEndResponse)
	err := c.cc.Invoke(ctx, BugbotAdminService_SetTeamTrialEnd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bugbotAdminServiceClient) GetProUserTrialEnd(ctx context.Context, in *GetProUserTrialEndRequest, opts ...grpc.CallOption) (*GetProUserTrialEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProUserTrialEndResponse)
	err := c.cc.Invoke(ctx, BugbotAdminService_GetProUserTrialEnd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bugbotAdminServiceClient) SetProUserTrialEnd(ctx context.Context, in *SetProUserTrialEndRequest, opts ...grpc.CallOption) (*SetProUserTrialEndResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetProUserTrialEndResponse)
	err := c.cc.Invoke(ctx, BugbotAdminService_SetProUserTrialEnd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bugbotAdminServiceClient) GetRepoNodeId(ctx context.Context, in *GetRepoNodeIdRequest, opts ...grpc.CallOption) (*GetRepoNodeIdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRepoNodeIdResponse)
	err := c.cc.Invoke(ctx, BugbotAdminService_GetRepoNodeId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BugbotAdminServiceServer is the server API for BugbotAdminService service.
// All implementations must embed UnimplementedBugbotAdminServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.BugbotAdminService (var: Zje)
type BugbotAdminServiceServer interface {
	GetTeamTrialEnd(context.Context, *GetTeamTrialEndRequest) (*GetTeamTrialEndResponse, error)
	SetTeamTrialEnd(context.Context, *SetTeamTrialEndRequest) (*SetTeamTrialEndResponse, error)
	GetProUserTrialEnd(context.Context, *GetProUserTrialEndRequest) (*GetProUserTrialEndResponse, error)
	SetProUserTrialEnd(context.Context, *SetProUserTrialEndRequest) (*SetProUserTrialEndResponse, error)
	GetRepoNodeId(context.Context, *GetRepoNodeIdRequest) (*GetRepoNodeIdResponse, error)
	mustEmbedUnimplementedBugbotAdminServiceServer()
}

// UnimplementedBugbotAdminServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBugbotAdminServiceServer struct{}

func (UnimplementedBugbotAdminServiceServer) GetTeamTrialEnd(context.Context, *GetTeamTrialEndRequest) (*GetTeamTrialEndResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamTrialEnd not implemented")
}
func (UnimplementedBugbotAdminServiceServer) SetTeamTrialEnd(context.Context, *SetTeamTrialEndRequest) (*SetTeamTrialEndResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetTeamTrialEnd not implemented")
}
func (UnimplementedBugbotAdminServiceServer) GetProUserTrialEnd(context.Context, *GetProUserTrialEndRequest) (*GetProUserTrialEndResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProUserTrialEnd not implemented")
}
func (UnimplementedBugbotAdminServiceServer) SetProUserTrialEnd(context.Context, *SetProUserTrialEndRequest) (*SetProUserTrialEndResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetProUserTrialEnd not implemented")
}
func (UnimplementedBugbotAdminServiceServer) GetRepoNodeId(context.Context, *GetRepoNodeIdRequest) (*GetRepoNodeIdResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRepoNodeId not implemented")
}
func (UnimplementedBugbotAdminServiceServer) mustEmbedUnimplementedBugbotAdminServiceServer() {}
func (UnimplementedBugbotAdminServiceServer) testEmbeddedByValue()                            {}

// UnsafeBugbotAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BugbotAdminServiceServer will
// result in compilation errors.
type UnsafeBugbotAdminServiceServer interface {
	mustEmbedUnimplementedBugbotAdminServiceServer()
}

func RegisterBugbotAdminServiceServer(s grpc.ServiceRegistrar, srv BugbotAdminServiceServer) {
	// If the following call panics, it indicates UnimplementedBugbotAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BugbotAdminService_ServiceDesc, srv)
}

func _BugbotAdminService_GetTeamTrialEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamTrialEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotAdminServiceServer).GetTeamTrialEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotAdminService_GetTeamTrialEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotAdminServiceServer).GetTeamTrialEnd(ctx, req.(*GetTeamTrialEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BugbotAdminService_SetTeamTrialEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTeamTrialEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotAdminServiceServer).SetTeamTrialEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotAdminService_SetTeamTrialEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotAdminServiceServer).SetTeamTrialEnd(ctx, req.(*SetTeamTrialEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BugbotAdminService_GetProUserTrialEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProUserTrialEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotAdminServiceServer).GetProUserTrialEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotAdminService_GetProUserTrialEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotAdminServiceServer).GetProUserTrialEnd(ctx, req.(*GetProUserTrialEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BugbotAdminService_SetProUserTrialEnd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProUserTrialEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotAdminServiceServer).SetProUserTrialEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotAdminService_SetProUserTrialEnd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotAdminServiceServer).SetProUserTrialEnd(ctx, req.(*SetProUserTrialEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BugbotAdminService_GetRepoNodeId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepoNodeIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotAdminServiceServer).GetRepoNodeId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotAdminService_GetRepoNodeId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotAdminServiceServer).GetRepoNodeId(ctx, req.(*GetRepoNodeIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BugbotAdminService_ServiceDesc is the grpc.ServiceDesc for BugbotAdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BugbotAdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.BugbotAdminService",
	HandlerType: (*BugbotAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTeamTrialEnd",
			Handler:    _BugbotAdminService_GetTeamTrialEnd_Handler,
		},
		{
			MethodName: "SetTeamTrialEnd",
			Handler:    _BugbotAdminService_SetTeamTrialEnd_Handler,
		},
		{
			MethodName: "GetProUserTrialEnd",
			Handler:    _BugbotAdminService_GetProUserTrialEnd_Handler,
		},
		{
			MethodName: "SetProUserTrialEnd",
			Handler:    _BugbotAdminService_SetProUserTrialEnd_Handler,
		},
		{
			MethodName: "GetRepoNodeId",
			Handler:    _BugbotAdminService_GetRepoNodeId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	BugbotService_LogDeeplinkEvent_FullMethodName    = "/aiserver.v1.BugbotService/LogDeeplinkEvent"
	BugbotService_GetEncryptedBugData_FullMethodName = "/aiserver.v1.BugbotService/GetEncryptedBugData"
)

// BugbotServiceClient is the client API for BugbotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.BugbotService (var: vVe)
type BugbotServiceClient interface {
	LogDeeplinkEvent(ctx context.Context, in *LogDeeplinkEventRequest, opts ...grpc.CallOption) (*LogDeeplinkEventResponse, error)
	GetEncryptedBugData(ctx context.Context, in *GetEncryptedBugDataRequest, opts ...grpc.CallOption) (*GetEncryptedBugDataResponse, error)
}

type bugbotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBugbotServiceClient(cc grpc.ClientConnInterface) BugbotServiceClient {
	return &bugbotServiceClient{cc}
}

func (c *bugbotServiceClient) LogDeeplinkEvent(ctx context.Context, in *LogDeeplinkEventRequest, opts ...grpc.CallOption) (*LogDeeplinkEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogDeeplinkEventResponse)
	err := c.cc.Invoke(ctx, BugbotService_LogDeeplinkEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bugbotServiceClient) GetEncryptedBugData(ctx context.Context, in *GetEncryptedBugDataRequest, opts ...grpc.CallOption) (*GetEncryptedBugDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEncryptedBugDataResponse)
	err := c.cc.Invoke(ctx, BugbotService_GetEncryptedBugData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BugbotServiceServer is the server API for BugbotService service.
// All implementations must embed UnimplementedBugbotServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.BugbotService (var: vVe)
type BugbotServiceServer interface {
	LogDeeplinkEvent(context.Context, *LogDeeplinkEventRequest) (*LogDeeplinkEventResponse, error)
	GetEncryptedBugData(context.Context, *GetEncryptedBugDataRequest) (*GetEncryptedBugDataResponse, error)
	mustEmbedUnimplementedBugbotServiceServer()
}

// UnimplementedBugbotServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBugbotServiceServer struct{}

func (UnimplementedBugbotServiceServer) LogDeeplinkEvent(context.Context, *LogDeeplinkEventRequest) (*LogDeeplinkEventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogDeeplinkEvent not implemented")
}
func (UnimplementedBugbotServiceServer) GetEncryptedBugData(context.Context, *GetEncryptedBugDataRequest) (*GetEncryptedBugDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEncryptedBugData not implemented")
}
func (UnimplementedBugbotServiceServer) mustEmbedUnimplementedBugbotServiceServer() {}
func (UnimplementedBugbotServiceServer) testEmbeddedByValue()                       {}

// UnsafeBugbotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BugbotServiceServer will
// result in compilation errors.
type UnsafeBugbotServiceServer interface {
	mustEmbedUnimplementedBugbotServiceServer()
}

func RegisterBugbotServiceServer(s grpc.ServiceRegistrar, srv BugbotServiceServer) {
	// If the following call panics, it indicates UnimplementedBugbotServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BugbotService_ServiceDesc, srv)
}

func _BugbotService_LogDeeplinkEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogDeeplinkEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotServiceServer).LogDeeplinkEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotService_LogDeeplinkEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotServiceServer).LogDeeplinkEvent(ctx, req.(*LogDeeplinkEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BugbotService_GetEncryptedBugData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEncryptedBugDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BugbotServiceServer).GetEncryptedBugData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BugbotService_GetEncryptedBugData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BugbotServiceServer).GetEncryptedBugData(ctx, req.(*GetEncryptedBugDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BugbotService_ServiceDesc is the grpc.ServiceDesc for BugbotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BugbotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.BugbotService",
	HandlerType: (*BugbotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogDeeplinkEvent",
			Handler:    _BugbotService_LogDeeplinkEvent_Handler,
		},
		{
			MethodName: "GetEncryptedBugData",
			Handler:    _BugbotService_GetEncryptedBugData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ChatRequestEventService_SubmitChatRequestEvents_FullMethodName = "/aiserver.v1.ChatRequestEventService/SubmitChatRequestEvents"
)

// ChatRequestEventServiceClient is the client API for ChatRequestEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ChatRequestEventService (var: uze)
type ChatRequestEventServiceClient interface {
	SubmitChatRequestEvents(ctx context.Context, in *SubmitChatRequestEventsRequest, opts ...grpc.CallOption) (*SubmitChatRequestEventsResponse, error)
}

type chatRequestEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatRequestEventServiceClient(cc grpc.ClientConnInterface) ChatRequestEventServiceClient {
	return &chatRequestEventServiceClient{cc}
}

func (c *chatRequestEventServiceClient) SubmitChatRequestEvents(ctx context.Context, in *SubmitChatRequestEventsRequest, opts ...grpc.CallOption) (*SubmitChatRequestEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitChatRequestEventsResponse)
	err := c.cc.Invoke(ctx, ChatRequestEventService_SubmitChatRequestEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatRequestEventServiceServer is the server API for ChatRequestEventService service.
// All implementations must embed UnimplementedChatRequestEventServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ChatRequestEventService (var: uze)
type ChatRequestEventServiceServer interface {
	SubmitChatRequestEvents(context.Context, *SubmitChatRequestEventsRequest) (*SubmitChatRequestEventsResponse, error)
	mustEmbedUnimplementedChatRequestEventServiceServer()
}

// UnimplementedChatRequestEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatRequestEventServiceServer struct{}

func (UnimplementedChatRequestEventServiceServer) SubmitChatRequestEvents(context.Context, *SubmitChatRequestEventsRequest) (*SubmitChatRequestEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitChatRequestEvents not implemented")
}
func (UnimplementedChatRequestEventServiceServer) mustEmbedUnimplementedChatRequestEventServiceServer() {
}
func (UnimplementedChatRequestEventServiceServer) testEmbeddedByValue() {}

// UnsafeChatRequestEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatRequestEventServiceServer will
// result in compilation errors.
type UnsafeChatRequestEventServiceServer interface {
	mustEmbedUnimplementedChatRequestEventServiceServer()
}

func RegisterChatRequestEventServiceServer(s grpc.ServiceRegistrar, srv ChatRequestEventServiceServer) {
	// If the following call panics, it indicates UnimplementedChatRequestEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatRequestEventService_ServiceDesc, srv)
}

func _ChatRequestEventService_SubmitChatRequestEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitChatRequestEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatRequestEventServiceServer).SubmitChatRequestEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatRequestEventService_SubmitChatRequestEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatRequestEventServiceServer).SubmitChatRequestEvents(ctx, req.(*SubmitChatRequestEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatRequestEventService_ServiceDesc is the grpc.ServiceDesc for ChatRequestEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatRequestEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ChatRequestEventService",
	HandlerType: (*ChatRequestEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitChatRequestEvents",
			Handler:    _ChatRequestEventService_SubmitChatRequestEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ChatRequestEventV2Service_SubmitChatRequestEventsV2_FullMethodName = "/aiserver.v1.ChatRequestEventV2Service/SubmitChatRequestEventsV2"
)

// ChatRequestEventV2ServiceClient is the client API for ChatRequestEventV2Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ChatRequestEventV2Service (var: jYe)
type ChatRequestEventV2ServiceClient interface {
	SubmitChatRequestEventsV2(ctx context.Context, in *SubmitChatRequestEventsV2Request, opts ...grpc.CallOption) (*SubmitChatRequestEventsV2Response, error)
}

type chatRequestEventV2ServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatRequestEventV2ServiceClient(cc grpc.ClientConnInterface) ChatRequestEventV2ServiceClient {
	return &chatRequestEventV2ServiceClient{cc}
}

func (c *chatRequestEventV2ServiceClient) SubmitChatRequestEventsV2(ctx context.Context, in *SubmitChatRequestEventsV2Request, opts ...grpc.CallOption) (*SubmitChatRequestEventsV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitChatRequestEventsV2Response)
	err := c.cc.Invoke(ctx, ChatRequestEventV2Service_SubmitChatRequestEventsV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatRequestEventV2ServiceServer is the server API for ChatRequestEventV2Service service.
// All implementations must embed UnimplementedChatRequestEventV2ServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ChatRequestEventV2Service (var: jYe)
type ChatRequestEventV2ServiceServer interface {
	SubmitChatRequestEventsV2(context.Context, *SubmitChatRequestEventsV2Request) (*SubmitChatRequestEventsV2Response, error)
	mustEmbedUnimplementedChatRequestEventV2ServiceServer()
}

// UnimplementedChatRequestEventV2ServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatRequestEventV2ServiceServer struct{}

func (UnimplementedChatRequestEventV2ServiceServer) SubmitChatRequestEventsV2(context.Context, *SubmitChatRequestEventsV2Request) (*SubmitChatRequestEventsV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitChatRequestEventsV2 not implemented")
}
func (UnimplementedChatRequestEventV2ServiceServer) mustEmbedUnimplementedChatRequestEventV2ServiceServer() {
}
func (UnimplementedChatRequestEventV2ServiceServer) testEmbeddedByValue() {}

// UnsafeChatRequestEventV2ServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatRequestEventV2ServiceServer will
// result in compilation errors.
type UnsafeChatRequestEventV2ServiceServer interface {
	mustEmbedUnimplementedChatRequestEventV2ServiceServer()
}

func RegisterChatRequestEventV2ServiceServer(s grpc.ServiceRegistrar, srv ChatRequestEventV2ServiceServer) {
	// If the following call panics, it indicates UnimplementedChatRequestEventV2ServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatRequestEventV2Service_ServiceDesc, srv)
}

func _ChatRequestEventV2Service_SubmitChatRequestEventsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitChatRequestEventsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatRequestEventV2ServiceServer).SubmitChatRequestEventsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatRequestEventV2Service_SubmitChatRequestEventsV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatRequestEventV2ServiceServer).SubmitChatRequestEventsV2(ctx, req.(*SubmitChatRequestEventsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatRequestEventV2Service_ServiceDesc is the grpc.ServiceDesc for ChatRequestEventV2Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatRequestEventV2Service_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ChatRequestEventV2Service",
	HandlerType: (*ChatRequestEventV2ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitChatRequestEventsV2",
			Handler:    _ChatRequestEventV2Service_SubmitChatRequestEventsV2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ChatService_StreamUnifiedChat_FullMethodName                        = "/aiserver.v1.ChatService/StreamUnifiedChat"
	ChatService_StreamUnifiedChatWithTools_FullMethodName               = "/aiserver.v1.ChatService/StreamUnifiedChatWithTools"
	ChatService_StreamUnifiedChatWithToolsSSE_FullMethodName            = "/aiserver.v1.ChatService/StreamUnifiedChatWithToolsSSE"
	ChatService_StreamUnifiedChatWithToolsPoll_FullMethodName           = "/aiserver.v1.ChatService/StreamUnifiedChatWithToolsPoll"
	ChatService_StreamUnifiedChatWithToolsIdempotent_FullMethodName     = "/aiserver.v1.ChatService/StreamUnifiedChatWithToolsIdempotent"
	ChatService_StreamUnifiedChatWithToolsIdempotentSSE_FullMethodName  = "/aiserver.v1.ChatService/StreamUnifiedChatWithToolsIdempotentSSE"
	ChatService_StreamUnifiedChatWithToolsIdempotentPoll_FullMethodName = "/aiserver.v1.ChatService/StreamUnifiedChatWithToolsIdempotentPoll"
	ChatService_GetConversationSummary_FullMethodName                   = "/aiserver.v1.ChatService/GetConversationSummary"
	ChatService_StreamSpeculativeSummaries_FullMethodName               = "/aiserver.v1.ChatService/StreamSpeculativeSummaries"
	ChatService_WarmStreamUnifiedChatWithTools_FullMethodName           = "/aiserver.v1.ChatService/WarmStreamUnifiedChatWithTools"
	ChatService_GetPromptDryRun_FullMethodName                          = "/aiserver.v1.ChatService/GetPromptDryRun"
	ChatService_StreamFullFileCmdK_FullMethodName                       = "/aiserver.v1.ChatService/StreamFullFileCmdK"
	ChatService_WarmFullFileCmdK_FullMethodName                         = "/aiserver.v1.ChatService/WarmFullFileCmdK"
	ChatService_ConvertOALToNAL_FullMethodName                          = "/aiserver.v1.ChatService/ConvertOALToNAL"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ChatService (var: MVe)
type ChatServiceClient interface {
	StreamUnifiedChat(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponse], error)
	StreamUnifiedChatWithTools(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools], error)
	StreamUnifiedChatWithToolsSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error)
	StreamUnifiedChatWithToolsPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	StreamUnifiedChatWithToolsIdempotent(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent], error)
	StreamUnifiedChatWithToolsIdempotentSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithToolsIdempotent], error)
	StreamUnifiedChatWithToolsIdempotentPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
	GetConversationSummary(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*ConversationSummary, error)
	StreamSpeculativeSummaries(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConversationSummary], error)
	WarmStreamUnifiedChatWithTools(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*WarmStreamUnifiedChatWithToolsResponse, error)
	GetPromptDryRun(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*GetPromptDryRunResponse, error)
	StreamFullFileCmdK(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error)
	WarmFullFileCmdK(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*WarmStreamUnifiedChatWithToolsResponse, error)
	ConvertOALToNAL(ctx context.Context, in *ConvertOALToNALRequest, opts ...grpc.CallOption) (*ConvertOALToNALResponse, error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) StreamUnifiedChat(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_StreamUnifiedChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUnifiedChatRequest, StreamUnifiedChatResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatClient = grpc.ServerStreamingClient[StreamUnifiedChatResponse]

func (c *chatServiceClient) StreamUnifiedChatWithTools(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[1], ChatService_StreamUnifiedChatWithTools_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsClient = grpc.BidiStreamingClient[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]

func (c *chatServiceClient) StreamUnifiedChatWithToolsSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[2], ChatService_StreamUnifiedChatWithToolsSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, StreamUnifiedChatResponseWithTools]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsSSEClient = grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools]

func (c *chatServiceClient) StreamUnifiedChatWithToolsPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[3], ChatService_StreamUnifiedChatWithToolsPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *chatServiceClient) StreamUnifiedChatWithToolsIdempotent(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[4], ChatService_StreamUnifiedChatWithToolsIdempotent_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentClient = grpc.BidiStreamingClient[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]

func (c *chatServiceClient) StreamUnifiedChatWithToolsIdempotentSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithToolsIdempotent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[5], ChatService_StreamUnifiedChatWithToolsIdempotentSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, StreamUnifiedChatResponseWithToolsIdempotent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentSSEClient = grpc.ServerStreamingClient[StreamUnifiedChatResponseWithToolsIdempotent]

func (c *chatServiceClient) StreamUnifiedChatWithToolsIdempotentPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[6], ChatService_StreamUnifiedChatWithToolsIdempotentPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentPollClient = grpc.ServerStreamingClient[BidiPollResponse]

func (c *chatServiceClient) GetConversationSummary(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*ConversationSummary, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationSummary)
	err := c.cc.Invoke(ctx, ChatService_GetConversationSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) StreamSpeculativeSummaries(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ConversationSummary], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[7], ChatService_StreamSpeculativeSummaries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUnifiedChatRequest, ConversationSummary]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamSpeculativeSummariesClient = grpc.ServerStreamingClient[ConversationSummary]

func (c *chatServiceClient) WarmStreamUnifiedChatWithTools(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*WarmStreamUnifiedChatWithToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmStreamUnifiedChatWithToolsResponse)
	err := c.cc.Invoke(ctx, ChatService_WarmStreamUnifiedChatWithTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetPromptDryRun(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*GetPromptDryRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPromptDryRunResponse)
	err := c.cc.Invoke(ctx, ChatService_GetPromptDryRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) StreamFullFileCmdK(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[8], ChatService_StreamFullFileCmdK_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamUnifiedChatRequest, StreamUnifiedChatResponseWithTools]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamFullFileCmdKClient = grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools]

func (c *chatServiceClient) WarmFullFileCmdK(ctx context.Context, in *StreamUnifiedChatRequest, opts ...grpc.CallOption) (*WarmStreamUnifiedChatWithToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmStreamUnifiedChatWithToolsResponse)
	err := c.cc.Invoke(ctx, ChatService_WarmFullFileCmdK_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ConvertOALToNAL(ctx context.Context, in *ConvertOALToNALRequest, opts ...grpc.CallOption) (*ConvertOALToNALResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertOALToNALResponse)
	err := c.cc.Invoke(ctx, ChatService_ConvertOALToNAL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ChatService (var: MVe)
type ChatServiceServer interface {
	StreamUnifiedChat(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponse]) error
	StreamUnifiedChatWithTools(grpc.BidiStreamingServer[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]) error
	StreamUnifiedChatWithToolsSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error
	StreamUnifiedChatWithToolsPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	StreamUnifiedChatWithToolsIdempotent(grpc.BidiStreamingServer[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]) error
	StreamUnifiedChatWithToolsIdempotentSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithToolsIdempotent]) error
	StreamUnifiedChatWithToolsIdempotentPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	GetConversationSummary(context.Context, *StreamUnifiedChatRequest) (*ConversationSummary, error)
	StreamSpeculativeSummaries(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[ConversationSummary]) error
	WarmStreamUnifiedChatWithTools(context.Context, *StreamUnifiedChatRequest) (*WarmStreamUnifiedChatWithToolsResponse, error)
	GetPromptDryRun(context.Context, *StreamUnifiedChatRequest) (*GetPromptDryRunResponse, error)
	StreamFullFileCmdK(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error
	WarmFullFileCmdK(context.Context, *StreamUnifiedChatRequest) (*WarmStreamUnifiedChatWithToolsResponse, error)
	ConvertOALToNAL(context.Context, *ConvertOALToNALRequest) (*ConvertOALToNALResponse, error)
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) StreamUnifiedChat(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChat not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithTools(grpc.BidiStreamingServer[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithTools not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithToolsSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithToolsSSE not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithToolsPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithToolsPoll not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithToolsIdempotent(grpc.BidiStreamingServer[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithToolsIdempotent not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithToolsIdempotentSSE(*BidiRequestId, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithToolsIdempotent]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithToolsIdempotentSSE not implemented")
}
func (UnimplementedChatServiceServer) StreamUnifiedChatWithToolsIdempotentPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamUnifiedChatWithToolsIdempotentPoll not implemented")
}
func (UnimplementedChatServiceServer) GetConversationSummary(context.Context, *StreamUnifiedChatRequest) (*ConversationSummary, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConversationSummary not implemented")
}
func (UnimplementedChatServiceServer) StreamSpeculativeSummaries(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[ConversationSummary]) error {
	return status.Error(codes.Unimplemented, "method StreamSpeculativeSummaries not implemented")
}
func (UnimplementedChatServiceServer) WarmStreamUnifiedChatWithTools(context.Context, *StreamUnifiedChatRequest) (*WarmStreamUnifiedChatWithToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmStreamUnifiedChatWithTools not implemented")
}
func (UnimplementedChatServiceServer) GetPromptDryRun(context.Context, *StreamUnifiedChatRequest) (*GetPromptDryRunResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPromptDryRun not implemented")
}
func (UnimplementedChatServiceServer) StreamFullFileCmdK(*StreamUnifiedChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error {
	return status.Error(codes.Unimplemented, "method StreamFullFileCmdK not implemented")
}
func (UnimplementedChatServiceServer) WarmFullFileCmdK(context.Context, *StreamUnifiedChatRequest) (*WarmStreamUnifiedChatWithToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmFullFileCmdK not implemented")
}
func (UnimplementedChatServiceServer) ConvertOALToNAL(context.Context, *ConvertOALToNALRequest) (*ConvertOALToNALResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConvertOALToNAL not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call panics, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_StreamUnifiedChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamUnifiedChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamUnifiedChat(m, &grpc.GenericServerStream[StreamUnifiedChatRequest, StreamUnifiedChatResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatServer = grpc.ServerStreamingServer[StreamUnifiedChatResponse]

func _ChatService_StreamUnifiedChatWithTools_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServiceServer).StreamUnifiedChatWithTools(&grpc.GenericServerStream[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsServer = grpc.BidiStreamingServer[StreamUnifiedChatRequestWithTools, StreamUnifiedChatResponseWithTools]

func _ChatService_StreamUnifiedChatWithToolsSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamUnifiedChatWithToolsSSE(m, &grpc.GenericServerStream[BidiRequestId, StreamUnifiedChatResponseWithTools]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsSSEServer = grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]

func _ChatService_StreamUnifiedChatWithToolsPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamUnifiedChatWithToolsPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _ChatService_StreamUnifiedChatWithToolsIdempotent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ChatServiceServer).StreamUnifiedChatWithToolsIdempotent(&grpc.GenericServerStream[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentServer = grpc.BidiStreamingServer[StreamUnifiedChatRequestWithToolsIdempotent, StreamUnifiedChatResponseWithToolsIdempotent]

func _ChatService_StreamUnifiedChatWithToolsIdempotentSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamUnifiedChatWithToolsIdempotentSSE(m, &grpc.GenericServerStream[BidiRequestId, StreamUnifiedChatResponseWithToolsIdempotent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentSSEServer = grpc.ServerStreamingServer[StreamUnifiedChatResponseWithToolsIdempotent]

func _ChatService_StreamUnifiedChatWithToolsIdempotentPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamUnifiedChatWithToolsIdempotentPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamUnifiedChatWithToolsIdempotentPollServer = grpc.ServerStreamingServer[BidiPollResponse]

func _ChatService_GetConversationSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamUnifiedChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetConversationSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetConversationSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetConversationSummary(ctx, req.(*StreamUnifiedChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_StreamSpeculativeSummaries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamUnifiedChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamSpeculativeSummaries(m, &grpc.GenericServerStream[StreamUnifiedChatRequest, ConversationSummary]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamSpeculativeSummariesServer = grpc.ServerStreamingServer[ConversationSummary]

func _ChatService_WarmStreamUnifiedChatWithTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamUnifiedChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).WarmStreamUnifiedChatWithTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_WarmStreamUnifiedChatWithTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).WarmStreamUnifiedChatWithTools(ctx, req.(*StreamUnifiedChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetPromptDryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamUnifiedChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetPromptDryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetPromptDryRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetPromptDryRun(ctx, req.(*StreamUnifiedChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_StreamFullFileCmdK_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamUnifiedChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamFullFileCmdK(m, &grpc.GenericServerStream[StreamUnifiedChatRequest, StreamUnifiedChatResponseWithTools]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamFullFileCmdKServer = grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]

func _ChatService_WarmFullFileCmdK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamUnifiedChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).WarmFullFileCmdK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_WarmFullFileCmdK_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).WarmFullFileCmdK(ctx, req.(*StreamUnifiedChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ConvertOALToNAL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertOALToNALRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ConvertOALToNAL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ConvertOALToNAL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ConvertOALToNAL(ctx, req.(*ConvertOALToNALRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConversationSummary",
			Handler:    _ChatService_GetConversationSummary_Handler,
		},
		{
			MethodName: "WarmStreamUnifiedChatWithTools",
			Handler:    _ChatService_WarmStreamUnifiedChatWithTools_Handler,
		},
		{
			MethodName: "GetPromptDryRun",
			Handler:    _ChatService_GetPromptDryRun_Handler,
		},
		{
			MethodName: "WarmFullFileCmdK",
			Handler:    _ChatService_WarmFullFileCmdK_Handler,
		},
		{
			MethodName: "ConvertOALToNAL",
			Handler:    _ChatService_ConvertOALToNAL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUnifiedChat",
			Handler:       _ChatService_StreamUnifiedChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithTools",
			Handler:       _ChatService_StreamUnifiedChatWithTools_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithToolsSSE",
			Handler:       _ChatService_StreamUnifiedChatWithToolsSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithToolsPoll",
			Handler:       _ChatService_StreamUnifiedChatWithToolsPoll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithToolsIdempotent",
			Handler:       _ChatService_StreamUnifiedChatWithToolsIdempotent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithToolsIdempotentSSE",
			Handler:       _ChatService_StreamUnifiedChatWithToolsIdempotentSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUnifiedChatWithToolsIdempotentPoll",
			Handler:       _ChatService_StreamUnifiedChatWithToolsIdempotentPoll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSpeculativeSummaries",
			Handler:       _ChatService_StreamSpeculativeSummaries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamFullFileCmdK",
			Handler:       _ChatService_StreamFullFileCmdK_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	CiMetricsService_RecordPerformanceData_FullMethodName    = "/aiserver.v1.CiMetricsService/RecordPerformanceData"
	CiMetricsService_UpsertInvocation_FullMethodName         = "/aiserver.v1.CiMetricsService/UpsertInvocation"
	CiMetricsService_RecordPerformanceChunk_FullMethodName   = "/aiserver.v1.CiMetricsService/RecordPerformanceChunk"
	CiMetricsService_RecordInvocationWithData_FullMethodName = "/aiserver.v1.CiMetricsService/RecordInvocationWithData"
	CiMetricsService_UpdateInvocationStatus_FullMethodName   = "/aiserver.v1.CiMetricsService/UpdateInvocationStatus"
)

// CiMetricsServiceClient is the client API for CiMetricsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.CiMetricsService (var: oYe)
type CiMetricsServiceClient interface {
	RecordPerformanceData(ctx context.Context, in *RecordPerformanceDataRequest, opts ...grpc.CallOption) (*RecordPerformanceDataResponse, error)
	UpsertInvocation(ctx context.Context, in *UpsertInvocationRequest, opts ...grpc.CallOption) (*UpsertInvocationResponse, error)
	RecordPerformanceChunk(ctx context.Context, in *RecordPerformanceChunkRequest, opts ...grpc.CallOption) (*RecordPerformanceChunkResponse, error)
	RecordInvocationWithData(ctx context.Context, in *RecordInvocationWithDataRequest, opts ...grpc.CallOption) (*RecordInvocationWithDataResponse, error)
	UpdateInvocationStatus(ctx context.Context, in *UpdateInvocationStatusRequest, opts ...grpc.CallOption) (*UpdateInvocationStatusResponse, error)
}

type ciMetricsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCiMetricsServiceClient(cc grpc.ClientConnInterface) CiMetricsServiceClient {
	return &ciMetricsServiceClient{cc}
}

func (c *ciMetricsServiceClient) RecordPerformanceData(ctx context.Context, in *RecordPerformanceDataRequest, opts ...grpc.CallOption) (*RecordPerformanceDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordPerformanceDataResponse)
	err := c.cc.Invoke(ctx, CiMetricsService_RecordPerformanceData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ciMetricsServiceClient) UpsertInvocation(ctx context.Context, in *UpsertInvocationRequest, opts ...grpc.CallOption) (*UpsertInvocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertInvocationResponse)
	err := c.cc.Invoke(ctx, CiMetricsService_UpsertInvocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ciMetricsServiceClient) RecordPerformanceChunk(ctx context.Context, in *RecordPerformanceChunkRequest, opts ...grpc.CallOption) (*RecordPerformanceChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordPerformanceChunkResponse)
	err := c.cc.Invoke(ctx, CiMetricsService_RecordPerformanceChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ciMetricsServiceClient) RecordInvocationWithData(ctx context.Context, in *RecordInvocationWithDataRequest, opts ...grpc.CallOption) (*RecordInvocationWithDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordInvocationWithDataResponse)
	err := c.cc.Invoke(ctx, CiMetricsService_RecordInvocationWithData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ciMetricsServiceClient) UpdateInvocationStatus(ctx context.Context, in *UpdateInvocationStatusRequest, opts ...grpc.CallOption) (*UpdateInvocationStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateInvocationStatusResponse)
	err := c.cc.Invoke(ctx, CiMetricsService_UpdateInvocationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CiMetricsServiceServer is the server API for CiMetricsService service.
// All implementations must embed UnimplementedCiMetricsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.CiMetricsService (var: oYe)
type CiMetricsServiceServer interface {
	RecordPerformanceData(context.Context, *RecordPerformanceDataRequest) (*RecordPerformanceDataResponse, error)
	UpsertInvocation(context.Context, *UpsertInvocationRequest) (*UpsertInvocationResponse, error)
	RecordPerformanceChunk(context.Context, *RecordPerformanceChunkRequest) (*RecordPerformanceChunkResponse, error)
	RecordInvocationWithData(context.Context, *RecordInvocationWithDataRequest) (*RecordInvocationWithDataResponse, error)
	UpdateInvocationStatus(context.Context, *UpdateInvocationStatusRequest) (*UpdateInvocationStatusResponse, error)
	mustEmbedUnimplementedCiMetricsServiceServer()
}

// UnimplementedCiMetricsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCiMetricsServiceServer struct{}

func (UnimplementedCiMetricsServiceServer) RecordPerformanceData(context.Context, *RecordPerformanceDataRequest) (*RecordPerformanceDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordPerformanceData not implemented")
}
func (UnimplementedCiMetricsServiceServer) UpsertInvocation(context.Context, *UpsertInvocationRequest) (*UpsertInvocationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertInvocation not implemented")
}
func (UnimplementedCiMetricsServiceServer) RecordPerformanceChunk(context.Context, *RecordPerformanceChunkRequest) (*RecordPerformanceChunkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordPerformanceChunk not implemented")
}
func (UnimplementedCiMetricsServiceServer) RecordInvocationWithData(context.Context, *RecordInvocationWithDataRequest) (*RecordInvocationWithDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordInvocationWithData not implemented")
}
func (UnimplementedCiMetricsServiceServer) UpdateInvocationStatus(context.Context, *UpdateInvocationStatusRequest) (*UpdateInvocationStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateInvocationStatus not implemented")
}
func (UnimplementedCiMetricsServiceServer) mustEmbedUnimplementedCiMetricsServiceServer() {}
func (UnimplementedCiMetricsServiceServer) testEmbeddedByValue()                          {}

// UnsafeCiMetricsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CiMetricsServiceServer will
// result in compilation errors.
type UnsafeCiMetricsServiceServer interface {
	mustEmbedUnimplementedCiMetricsServiceServer()
}

func RegisterCiMetricsServiceServer(s grpc.ServiceRegistrar, srv CiMetricsServiceServer) {
	// If the following call panics, it indicates UnimplementedCiMetricsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CiMetricsService_ServiceDesc, srv)
}

func _CiMetricsService_RecordPerformanceData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordPerformanceDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CiMetricsServiceServer).RecordPerformanceData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CiMetricsService_RecordPerformanceData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CiMetricsServiceServer).RecordPerformanceData(ctx, req.(*RecordPerformanceDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CiMetricsService_UpsertInvocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertInvocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CiMetricsServiceServer).UpsertInvocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CiMetricsService_UpsertInvocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CiMetricsServiceServer).UpsertInvocation(ctx, req.(*UpsertInvocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CiMetricsService_RecordPerformanceChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordPerformanceChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CiMetricsServiceServer).RecordPerformanceChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CiMetricsService_RecordPerformanceChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CiMetricsServiceServer).RecordPerformanceChunk(ctx, req.(*RecordPerformanceChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CiMetricsService_RecordInvocationWithData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordInvocationWithDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CiMetricsServiceServer).RecordInvocationWithData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CiMetricsService_RecordInvocationWithData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CiMetricsServiceServer).RecordInvocationWithData(ctx, req.(*RecordInvocationWithDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CiMetricsService_UpdateInvocationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInvocationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CiMetricsServiceServer).UpdateInvocationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CiMetricsService_UpdateInvocationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CiMetricsServiceServer).UpdateInvocationStatus(ctx, req.(*UpdateInvocationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CiMetricsService_ServiceDesc is the grpc.ServiceDesc for CiMetricsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CiMetricsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.CiMetricsService",
	HandlerType: (*CiMetricsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecordPerformanceData",
			Handler:    _CiMetricsService_RecordPerformanceData_Handler,
		},
		{
			MethodName: "UpsertInvocation",
			Handler:    _CiMetricsService_UpsertInvocation_Handler,
		},
		{
			MethodName: "RecordPerformanceChunk",
			Handler:    _CiMetricsService_RecordPerformanceChunk_Handler,
		},
		{
			MethodName: "RecordInvocationWithData",
			Handler:    _CiMetricsService_RecordInvocationWithData_Handler,
		},
		{
			MethodName: "UpdateInvocationStatus",
			Handler:    _CiMetricsService_UpdateInvocationStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ClientLoggerService_GetDebuggingDataUploadUrl_FullMethodName = "/aiserver.v1.ClientLoggerService/GetDebuggingDataUploadUrl"
	ClientLoggerService_LogWhenTabTurnsOff_FullMethodName        = "/aiserver.v1.ClientLoggerService/LogWhenTabTurnsOff"
)

// ClientLoggerServiceClient is the client API for ClientLoggerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ClientLoggerService (var: cYe)
type ClientLoggerServiceClient interface {
	GetDebuggingDataUploadUrl(ctx context.Context, in *GetDebuggingDataUploadUrlRequest, opts ...grpc.CallOption) (*GetDebuggingDataUploadUrlResponse, error)
	LogWhenTabTurnsOff(ctx context.Context, in *LogWhenTabTurnsOffRequest, opts ...grpc.CallOption) (*LogWhenTabTurnsOffResponse, error)
}

type clientLoggerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClientLoggerServiceClient(cc grpc.ClientConnInterface) ClientLoggerServiceClient {
	return &clientLoggerServiceClient{cc}
}

func (c *clientLoggerServiceClient) GetDebuggingDataUploadUrl(ctx context.Context, in *GetDebuggingDataUploadUrlRequest, opts ...grpc.CallOption) (*GetDebuggingDataUploadUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDebuggingDataUploadUrlResponse)
	err := c.cc.Invoke(ctx, ClientLoggerService_GetDebuggingDataUploadUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientLoggerServiceClient) LogWhenTabTurnsOff(ctx context.Context, in *LogWhenTabTurnsOffRequest, opts ...grpc.CallOption) (*LogWhenTabTurnsOffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogWhenTabTurnsOffResponse)
	err := c.cc.Invoke(ctx, ClientLoggerService_LogWhenTabTurnsOff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientLoggerServiceServer is the server API for ClientLoggerService service.
// All implementations must embed UnimplementedClientLoggerServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ClientLoggerService (var: cYe)
type ClientLoggerServiceServer interface {
	GetDebuggingDataUploadUrl(context.Context, *GetDebuggingDataUploadUrlRequest) (*GetDebuggingDataUploadUrlResponse, error)
	LogWhenTabTurnsOff(context.Context, *LogWhenTabTurnsOffRequest) (*LogWhenTabTurnsOffResponse, error)
	mustEmbedUnimplementedClientLoggerServiceServer()
}

// UnimplementedClientLoggerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClientLoggerServiceServer struct{}

func (UnimplementedClientLoggerServiceServer) GetDebuggingDataUploadUrl(context.Context, *GetDebuggingDataUploadUrlRequest) (*GetDebuggingDataUploadUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDebuggingDataUploadUrl not implemented")
}
func (UnimplementedClientLoggerServiceServer) LogWhenTabTurnsOff(context.Context, *LogWhenTabTurnsOffRequest) (*LogWhenTabTurnsOffResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogWhenTabTurnsOff not implemented")
}
func (UnimplementedClientLoggerServiceServer) mustEmbedUnimplementedClientLoggerServiceServer() {}
func (UnimplementedClientLoggerServiceServer) testEmbeddedByValue()                             {}

// UnsafeClientLoggerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClientLoggerServiceServer will
// result in compilation errors.
type UnsafeClientLoggerServiceServer interface {
	mustEmbedUnimplementedClientLoggerServiceServer()
}

func RegisterClientLoggerServiceServer(s grpc.ServiceRegistrar, srv ClientLoggerServiceServer) {
	// If the following call panics, it indicates UnimplementedClientLoggerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClientLoggerService_ServiceDesc, srv)
}

func _ClientLoggerService_GetDebuggingDataUploadUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDebuggingDataUploadUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientLoggerServiceServer).GetDebuggingDataUploadUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClientLoggerService_GetDebuggingDataUploadUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientLoggerServiceServer).GetDebuggingDataUploadUrl(ctx, req.(*GetDebuggingDataUploadUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientLoggerService_LogWhenTabTurnsOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogWhenTabTurnsOffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientLoggerServiceServer).LogWhenTabTurnsOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClientLoggerService_LogWhenTabTurnsOff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientLoggerServiceServer).LogWhenTabTurnsOff(ctx, req.(*LogWhenTabTurnsOffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClientLoggerService_ServiceDesc is the grpc.ServiceDesc for ClientLoggerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClientLoggerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ClientLoggerService",
	HandlerType: (*ClientLoggerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDebuggingDataUploadUrl",
			Handler:    _ClientLoggerService_GetDebuggingDataUploadUrl_Handler,
		},
		{
			MethodName: "LogWhenTabTurnsOff",
			Handler:    _ClientLoggerService_LogWhenTabTurnsOff_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	CmdKService_StreamCmdK_FullMethodName                = "/aiserver.v1.CmdKService/StreamCmdK"
	CmdKService_StreamHypermode_FullMethodName           = "/aiserver.v1.CmdKService/StreamHypermode"
	CmdKService_RerankCmdKContext_FullMethodName         = "/aiserver.v1.CmdKService/RerankCmdKContext"
	CmdKService_StreamTerminalCmdK_FullMethodName        = "/aiserver.v1.CmdKService/StreamTerminalCmdK"
	CmdKService_RerankTerminalCmdKContext_FullMethodName = "/aiserver.v1.CmdKService/RerankTerminalCmdKContext"
	CmdKService_GetRelevantChunks_FullMethodName         = "/aiserver.v1.CmdKService/GetRelevantChunks"
)

// CmdKServiceClient is the client API for CmdKService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.CmdKService (var: eze)
type CmdKServiceClient interface {
	StreamCmdK(ctx context.Context, in *StreamCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped], error)
	StreamHypermode(ctx context.Context, in *StreamHypermodeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped], error)
	RerankCmdKContext(ctx context.Context, in *RerankCmdKContextRequest, opts ...grpc.CallOption) (*RerankCmdKContextResponse, error)
	StreamTerminalCmdK(ctx context.Context, in *StreamTerminalCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTerminalCmdKResponseContextWrapped], error)
	RerankTerminalCmdKContext(ctx context.Context, in *RerankTerminalCmdKContextRequest, opts ...grpc.CallOption) (*RerankTerminalCmdKContextResponse, error)
	GetRelevantChunks(ctx context.Context, in *GetRelevantChunksRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamGetRelevantChunksResponseContextWrapped], error)
}

type cmdKServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCmdKServiceClient(cc grpc.ClientConnInterface) CmdKServiceClient {
	return &cmdKServiceClient{cc}
}

func (c *cmdKServiceClient) StreamCmdK(ctx context.Context, in *StreamCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CmdKService_ServiceDesc.Streams[0], CmdKService_StreamCmdK_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamCmdKRequest, StreamCmdKResponseContextWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamCmdKClient = grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped]

func (c *cmdKServiceClient) StreamHypermode(ctx context.Context, in *StreamHypermodeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CmdKService_ServiceDesc.Streams[1], CmdKService_StreamHypermode_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamHypermodeRequest, StreamCmdKResponseContextWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamHypermodeClient = grpc.ServerStreamingClient[StreamCmdKResponseContextWrapped]

func (c *cmdKServiceClient) RerankCmdKContext(ctx context.Context, in *RerankCmdKContextRequest, opts ...grpc.CallOption) (*RerankCmdKContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankCmdKContextResponse)
	err := c.cc.Invoke(ctx, CmdKService_RerankCmdKContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdKServiceClient) StreamTerminalCmdK(ctx context.Context, in *StreamTerminalCmdKRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTerminalCmdKResponseContextWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CmdKService_ServiceDesc.Streams[2], CmdKService_StreamTerminalCmdK_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamTerminalCmdKRequest, StreamTerminalCmdKResponseContextWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamTerminalCmdKClient = grpc.ServerStreamingClient[StreamTerminalCmdKResponseContextWrapped]

func (c *cmdKServiceClient) RerankTerminalCmdKContext(ctx context.Context, in *RerankTerminalCmdKContextRequest, opts ...grpc.CallOption) (*RerankTerminalCmdKContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RerankTerminalCmdKContextResponse)
	err := c.cc.Invoke(ctx, CmdKService_RerankTerminalCmdKContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdKServiceClient) GetRelevantChunks(ctx context.Context, in *GetRelevantChunksRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamGetRelevantChunksResponseContextWrapped], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CmdKService_ServiceDesc.Streams[3], CmdKService_GetRelevantChunks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetRelevantChunksRequest, StreamGetRelevantChunksResponseContextWrapped]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_GetRelevantChunksClient = grpc.ServerStreamingClient[StreamGetRelevantChunksResponseContextWrapped]

// CmdKServiceServer is the server API for CmdKService service.
// All implementations must embed UnimplementedCmdKServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.CmdKService (var: eze)
type CmdKServiceServer interface {
	StreamCmdK(*StreamCmdKRequest, grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]) error
	StreamHypermode(*StreamHypermodeRequest, grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]) error
	RerankCmdKContext(context.Context, *RerankCmdKContextRequest) (*RerankCmdKContextResponse, error)
	StreamTerminalCmdK(*StreamTerminalCmdKRequest, grpc.ServerStreamingServer[StreamTerminalCmdKResponseContextWrapped]) error
	RerankTerminalCmdKContext(context.Context, *RerankTerminalCmdKContextRequest) (*RerankTerminalCmdKContextResponse, error)
	GetRelevantChunks(*GetRelevantChunksRequest, grpc.ServerStreamingServer[StreamGetRelevantChunksResponseContextWrapped]) error
	mustEmbedUnimplementedCmdKServiceServer()
}

// UnimplementedCmdKServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCmdKServiceServer struct{}

func (UnimplementedCmdKServiceServer) StreamCmdK(*StreamCmdKRequest, grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]) error {
	return status.Error(codes.Unimplemented, "method StreamCmdK not implemented")
}
func (UnimplementedCmdKServiceServer) StreamHypermode(*StreamHypermodeRequest, grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]) error {
	return status.Error(codes.Unimplemented, "method StreamHypermode not implemented")
}
func (UnimplementedCmdKServiceServer) RerankCmdKContext(context.Context, *RerankCmdKContextRequest) (*RerankCmdKContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RerankCmdKContext not implemented")
}
func (UnimplementedCmdKServiceServer) StreamTerminalCmdK(*StreamTerminalCmdKRequest, grpc.ServerStreamingServer[StreamTerminalCmdKResponseContextWrapped]) error {
	return status.Error(codes.Unimplemented, "method StreamTerminalCmdK not implemented")
}
func (UnimplementedCmdKServiceServer) RerankTerminalCmdKContext(context.Context, *RerankTerminalCmdKContextRequest) (*RerankTerminalCmdKContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RerankTerminalCmdKContext not implemented")
}
func (UnimplementedCmdKServiceServer) GetRelevantChunks(*GetRelevantChunksRequest, grpc.ServerStreamingServer[StreamGetRelevantChunksResponseContextWrapped]) error {
	return status.Error(codes.Unimplemented, "method GetRelevantChunks not implemented")
}
func (UnimplementedCmdKServiceServer) mustEmbedUnimplementedCmdKServiceServer() {}
func (UnimplementedCmdKServiceServer) testEmbeddedByValue()                     {}

// UnsafeCmdKServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmdKServiceServer will
// result in compilation errors.
type UnsafeCmdKServiceServer interface {
	mustEmbedUnimplementedCmdKServiceServer()
}

func RegisterCmdKServiceServer(s grpc.ServiceRegistrar, srv CmdKServiceServer) {
	// If the following call panics, it indicates UnimplementedCmdKServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CmdKService_ServiceDesc, srv)
}

func _CmdKService_StreamCmdK_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamCmdKRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdKServiceServer).StreamCmdK(m, &grpc.GenericServerStream[StreamCmdKRequest, StreamCmdKResponseContextWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamCmdKServer = grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]

func _CmdKService_StreamHypermode_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamHypermodeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdKServiceServer).StreamHypermode(m, &grpc.GenericServerStream[StreamHypermodeRequest, StreamCmdKResponseContextWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamHypermodeServer = grpc.ServerStreamingServer[StreamCmdKResponseContextWrapped]

func _CmdKService_RerankCmdKContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankCmdKContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdKServiceServer).RerankCmdKContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CmdKService_RerankCmdKContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdKServiceServer).RerankCmdKContext(ctx, req.(*RerankCmdKContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdKService_StreamTerminalCmdK_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamTerminalCmdKRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdKServiceServer).StreamTerminalCmdK(m, &grpc.GenericServerStream[StreamTerminalCmdKRequest, StreamTerminalCmdKResponseContextWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_StreamTerminalCmdKServer = grpc.ServerStreamingServer[StreamTerminalCmdKResponseContextWrapped]

func _CmdKService_RerankTerminalCmdKContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerankTerminalCmdKContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdKServiceServer).RerankTerminalCmdKContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CmdKService_RerankTerminalCmdKContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdKServiceServer).RerankTerminalCmdKContext(ctx, req.(*RerankTerminalCmdKContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CmdKService_GetRelevantChunks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRelevantChunksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CmdKServiceServer).GetRelevantChunks(m, &grpc.GenericServerStream[GetRelevantChunksRequest, StreamGetRelevantChunksResponseContextWrapped]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CmdKService_GetRelevantChunksServer = grpc.ServerStreamingServer[StreamGetRelevantChunksResponseContextWrapped]

// CmdKService_ServiceDesc is the grpc.ServiceDesc for CmdKService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CmdKService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.CmdKService",
	HandlerType: (*CmdKServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RerankCmdKContext",
			Handler:    _CmdKService_RerankCmdKContext_Handler,
		},
		{
			MethodName: "RerankTerminalCmdKContext",
			Handler:    _CmdKService_RerankTerminalCmdKContext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamCmdK",
			Handler:       _CmdKService_StreamCmdK_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamHypermode",
			Handler:       _CmdKService_StreamHypermode_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTerminalCmdK",
			Handler:       _CmdKService_StreamTerminalCmdK_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetRelevantChunks",
			Handler:       _CmdKService_GetRelevantChunks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	ConversationsService_GetCommitMetrics_FullMethodName       = "/aiserver.v1.ConversationsService/GetCommitMetrics"
	ConversationsService_GetConversationSummary_FullMethodName = "/aiserver.v1.ConversationsService/GetConversationSummary"
)

// ConversationsServiceClient is the client API for ConversationsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ConversationsService (var: lYe)
type ConversationsServiceClient interface {
	GetCommitMetrics(ctx context.Context, in *GetCommitMetricsRequest, opts ...grpc.CallOption) (*GetCommitMetricsResponse, error)
	GetConversationSummary(ctx context.Context, in *GetConversationSummaryRequest, opts ...grpc.CallOption) (*GetConversationSummaryResponse, error)
}

type conversationsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConversationsServiceClient(cc grpc.ClientConnInterface) ConversationsServiceClient {
	return &conversationsServiceClient{cc}
}

func (c *conversationsServiceClient) GetCommitMetrics(ctx context.Context, in *GetCommitMetricsRequest, opts ...grpc.CallOption) (*GetCommitMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommitMetricsResponse)
	err := c.cc.Invoke(ctx, ConversationsService_GetCommitMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationsServiceClient) GetConversationSummary(ctx context.Context, in *GetConversationSummaryRequest, opts ...grpc.CallOption) (*GetConversationSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConversationSummaryResponse)
	err := c.cc.Invoke(ctx, ConversationsService_GetConversationSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationsServiceServer is the server API for ConversationsService service.
// All implementations must embed UnimplementedConversationsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ConversationsService (var: lYe)
type ConversationsServiceServer interface {
	GetCommitMetrics(context.Context, *GetCommitMetricsRequest) (*GetCommitMetricsResponse, error)
	GetConversationSummary(context.Context, *GetConversationSummaryRequest) (*GetConversationSummaryResponse, error)
	mustEmbedUnimplementedConversationsServiceServer()
}

// UnimplementedConversationsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConversationsServiceServer struct{}

func (UnimplementedConversationsServiceServer) GetCommitMetrics(context.Context, *GetCommitMetricsRequest) (*GetCommitMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCommitMetrics not implemented")
}
func (UnimplementedConversationsServiceServer) GetConversationSummary(context.Context, *GetConversationSummaryRequest) (*GetConversationSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConversationSummary not implemented")
}
func (UnimplementedConversationsServiceServer) mustEmbedUnimplementedConversationsServiceServer() {}
func (UnimplementedConversationsServiceServer) testEmbeddedByValue()                              {}

// UnsafeConversationsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConversationsServiceServer will
// result in compilation errors.
type UnsafeConversationsServiceServer interface {
	mustEmbedUnimplementedConversationsServiceServer()
}

func RegisterConversationsServiceServer(s grpc.ServiceRegistrar, srv ConversationsServiceServer) {
	// If the following call panics, it indicates UnimplementedConversationsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConversationsService_ServiceDesc, srv)
}

func _ConversationsService_GetCommitMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommitMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).GetCommitMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_GetCommitMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).GetCommitMetrics(ctx, req.(*GetCommitMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationsService_GetConversationSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationsServiceServer).GetConversationSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConversationsService_GetConversationSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationsServiceServer).GetConversationSummary(ctx, req.(*GetConversationSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConversationsService_ServiceDesc is the grpc.ServiceDesc for ConversationsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConversationsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ConversationsService",
	HandlerType: (*ConversationsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCommitMetrics",
			Handler:    _ConversationsService_GetCommitMetrics_Handler,
		},
		{
			MethodName: "GetConversationSummary",
			Handler:    _ConversationsService_GetConversationSummary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	CppService_MarkCppForEval_FullMethodName      = "/aiserver.v1.CppService/MarkCppForEval"
	CppService_StreamHoldCpp_FullMethodName       = "/aiserver.v1.CppService/StreamHoldCpp"
	CppService_AvailableModels_FullMethodName     = "/aiserver.v1.CppService/AvailableModels"
	CppService_RecordCppFate_FullMethodName       = "/aiserver.v1.CppService/RecordCppFate"
	CppService_AddTabRequestToEval_FullMethodName = "/aiserver.v1.CppService/AddTabRequestToEval"
)

// CppServiceClient is the client API for CppService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.CppService (var: $Ve)
type CppServiceClient interface {
	MarkCppForEval(ctx context.Context, in *MarkCppRequest, opts ...grpc.CallOption) (*MarkCppResponse, error)
	StreamHoldCpp(ctx context.Context, in *StreamHoldCppRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamHoldCppResponse], error)
	AvailableModels(ctx context.Context, in *AvailableCppModelsRequest, opts ...grpc.CallOption) (*AvailableCppModelsResponse, error)
	RecordCppFate(ctx context.Context, in *RecordCppFateRequest, opts ...grpc.CallOption) (*RecordCppFateResponse, error)
	AddTabRequestToEval(ctx context.Context, in *AddTabRequestToEvalRequest, opts ...grpc.CallOption) (*AddTabRequestToEvalResponse, error)
}

type cppServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCppServiceClient(cc grpc.ClientConnInterface) CppServiceClient {
	return &cppServiceClient{cc}
}

func (c *cppServiceClient) MarkCppForEval(ctx context.Context, in *MarkCppRequest, opts ...grpc.CallOption) (*MarkCppResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkCppResponse)
	err := c.cc.Invoke(ctx, CppService_MarkCppForEval_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cppServiceClient) StreamHoldCpp(ctx context.Context, in *StreamHoldCppRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamHoldCppResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CppService_ServiceDesc.Streams[0], CppService_StreamHoldCpp_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamHoldCppRequest, StreamHoldCppResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CppService_StreamHoldCppClient = grpc.ServerStreamingClient[StreamHoldCppResponse]

func (c *cppServiceClient) AvailableModels(ctx context.Context, in *AvailableCppModelsRequest, opts ...grpc.CallOption) (*AvailableCppModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableCppModelsResponse)
	err := c.cc.Invoke(ctx, CppService_AvailableModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cppServiceClient) RecordCppFate(ctx context.Context, in *RecordCppFateRequest, opts ...grpc.CallOption) (*RecordCppFateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordCppFateResponse)
	err := c.cc.Invoke(ctx, CppService_RecordCppFate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cppServiceClient) AddTabRequestToEval(ctx context.Context, in *AddTabRequestToEvalRequest, opts ...grpc.CallOption) (*AddTabRequestToEvalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddTabRequestToEvalResponse)
	err := c.cc.Invoke(ctx, CppService_AddTabRequestToEval_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CppServiceServer is the server API for CppService service.
// All implementations must embed UnimplementedCppServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.CppService (var: $Ve)
type CppServiceServer interface {
	MarkCppForEval(context.Context, *MarkCppRequest) (*MarkCppResponse, error)
	StreamHoldCpp(*StreamHoldCppRequest, grpc.ServerStreamingServer[StreamHoldCppResponse]) error
	AvailableModels(context.Context, *AvailableCppModelsRequest) (*AvailableCppModelsResponse, error)
	RecordCppFate(context.Context, *RecordCppFateRequest) (*RecordCppFateResponse, error)
	AddTabRequestToEval(context.Context, *AddTabRequestToEvalRequest) (*AddTabRequestToEvalResponse, error)
	mustEmbedUnimplementedCppServiceServer()
}

// UnimplementedCppServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCppServiceServer struct{}

func (UnimplementedCppServiceServer) MarkCppForEval(context.Context, *MarkCppRequest) (*MarkCppResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkCppForEval not implemented")
}
func (UnimplementedCppServiceServer) StreamHoldCpp(*StreamHoldCppRequest, grpc.ServerStreamingServer[StreamHoldCppResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamHoldCpp not implemented")
}
func (UnimplementedCppServiceServer) AvailableModels(context.Context, *AvailableCppModelsRequest) (*AvailableCppModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AvailableModels not implemented")
}
func (UnimplementedCppServiceServer) RecordCppFate(context.Context, *RecordCppFateRequest) (*RecordCppFateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordCppFate not implemented")
}
func (UnimplementedCppServiceServer) AddTabRequestToEval(context.Context, *AddTabRequestToEvalRequest) (*AddTabRequestToEvalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddTabRequestToEval not implemented")
}
func (UnimplementedCppServiceServer) mustEmbedUnimplementedCppServiceServer() {}
func (UnimplementedCppServiceServer) testEmbeddedByValue()                    {}

// UnsafeCppServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CppServiceServer will
// result in compilation errors.
type UnsafeCppServiceServer interface {
	mustEmbedUnimplementedCppServiceServer()
}

func RegisterCppServiceServer(s grpc.ServiceRegistrar, srv CppServiceServer) {
	// If the following call panics, it indicates UnimplementedCppServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CppService_ServiceDesc, srv)
}

func _CppService_MarkCppForEval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkCppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CppServiceServer).MarkCppForEval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CppService_MarkCppForEval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CppServiceServer).MarkCppForEval(ctx, req.(*MarkCppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CppService_StreamHoldCpp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamHoldCppRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CppServiceServer).StreamHoldCpp(m, &grpc.GenericServerStream[StreamHoldCppRequest, StreamHoldCppResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CppService_StreamHoldCppServer = grpc.ServerStreamingServer[StreamHoldCppResponse]

func _CppService_AvailableModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvailableCppModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CppServiceServer).AvailableModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CppService_AvailableModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CppServiceServer).AvailableModels(ctx, req.(*AvailableCppModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CppService_RecordCppFate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordCppFateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CppServiceServer).RecordCppFate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CppService_RecordCppFate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CppServiceServer).RecordCppFate(ctx, req.(*RecordCppFateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CppService_AddTabRequestToEval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTabRequestToEvalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CppServiceServer).AddTabRequestToEval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CppService_AddTabRequestToEval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CppServiceServer).AddTabRequestToEval(ctx, req.(*AddTabRequestToEvalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CppService_ServiceDesc is the grpc.ServiceDesc for CppService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CppService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.CppService",
	HandlerType: (*CppServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MarkCppForEval",
			Handler:    _CppService_MarkCppForEval_Handler,
		},
		{
			MethodName: "AvailableModels",
			Handler:    _CppService_AvailableModels_Handler,
		},
		{
			MethodName: "RecordCppFate",
			Handler:    _CppService_RecordCppFate_Handler,
		},
		{
			MethodName: "AddTabRequestToEval",
			Handler:    _CppService_AddTabRequestToEval_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHoldCpp",
			Handler:       _CppService_StreamHoldCpp_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	CursorPredictionService_CursorPredictionConfig_FullMethodName = "/aiserver.v1.CursorPredictionService/CursorPredictionConfig"
)

// CursorPredictionServiceClient is the client API for CursorPredictionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.CursorPredictionService (var: uYe)
type CursorPredictionServiceClient interface {
	CursorPredictionConfig(ctx context.Context, in *CursorPredictionConfigRequest, opts ...grpc.CallOption) (*CursorPredictionConfigResponse, error)
}

type cursorPredictionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCursorPredictionServiceClient(cc grpc.ClientConnInterface) CursorPredictionServiceClient {
	return &cursorPredictionServiceClient{cc}
}

func (c *cursorPredictionServiceClient) CursorPredictionConfig(ctx context.Context, in *CursorPredictionConfigRequest, opts ...grpc.CallOption) (*CursorPredictionConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CursorPredictionConfigResponse)
	err := c.cc.Invoke(ctx, CursorPredictionService_CursorPredictionConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CursorPredictionServiceServer is the server API for CursorPredictionService service.
// All implementations must embed UnimplementedCursorPredictionServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.CursorPredictionService (var: uYe)
type CursorPredictionServiceServer interface {
	CursorPredictionConfig(context.Context, *CursorPredictionConfigRequest) (*CursorPredictionConfigResponse, error)
	mustEmbedUnimplementedCursorPredictionServiceServer()
}

// UnimplementedCursorPredictionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCursorPredictionServiceServer struct{}

func (UnimplementedCursorPredictionServiceServer) CursorPredictionConfig(context.Context, *CursorPredictionConfigRequest) (*CursorPredictionConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CursorPredictionConfig not implemented")
}
func (UnimplementedCursorPredictionServiceServer) mustEmbedUnimplementedCursorPredictionServiceServer() {
}
func (UnimplementedCursorPredictionServiceServer) testEmbeddedByValue() {}

// UnsafeCursorPredictionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CursorPredictionServiceServer will
// result in compilation errors.
type UnsafeCursorPredictionServiceServer interface {
	mustEmbedUnimplementedCursorPredictionServiceServer()
}

func RegisterCursorPredictionServiceServer(s grpc.ServiceRegistrar, srv CursorPredictionServiceServer) {
	// If the following call panics, it indicates UnimplementedCursorPredictionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CursorPredictionService_ServiceDesc, srv)
}

func _CursorPredictionService_CursorPredictionConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CursorPredictionConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CursorPredictionServiceServer).CursorPredictionConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CursorPredictionService_CursorPredictionConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CursorPredictionServiceServer).CursorPredictionConfig(ctx, req.(*CursorPredictionConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CursorPredictionService_ServiceDesc is the grpc.ServiceDesc for CursorPredictionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CursorPredictionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.CursorPredictionService",
	HandlerType: (*CursorPredictionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CursorPredictionConfig",
			Handler:    _CursorPredictionService_CursorPredictionConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	DashboardService_GetTeams_FullMethodName                                  = "/aiserver.v1.DashboardService/GetTeams"
	DashboardService_GetMe_FullMethodName                                     = "/aiserver.v1.DashboardService/GetMe"
	DashboardService_GetDirectoryGroups_FullMethodName                        = "/aiserver.v1.DashboardService/GetDirectoryGroups"
	DashboardService_UpdateDirectoryGroupSettings_FullMethodName              = "/aiserver.v1.DashboardService/UpdateDirectoryGroupSettings"
	DashboardService_GetGroups_FullMethodName                                 = "/aiserver.v1.DashboardService/GetGroups"
	DashboardService_GetGroupMembers_FullMethodName                           = "/aiserver.v1.DashboardService/GetGroupMembers"
	DashboardService_CreateGroup_FullMethodName                               = "/aiserver.v1.DashboardService/CreateGroup"
	DashboardService_UpdateGroup_FullMethodName                               = "/aiserver.v1.DashboardService/UpdateGroup"
	DashboardService_DeleteGroup_FullMethodName                               = "/aiserver.v1.DashboardService/DeleteGroup"
	DashboardService_AddGroupMembers_FullMethodName                           = "/aiserver.v1.DashboardService/AddGroupMembers"
	DashboardService_RemoveGroupMembers_FullMethodName                        = "/aiserver.v1.DashboardService/RemoveGroupMembers"
	DashboardService_BulkAssignGroupMembers_FullMethodName                    = "/aiserver.v1.DashboardService/BulkAssignGroupMembers"
	DashboardService_PreviewAttachGroupToDirectory_FullMethodName             = "/aiserver.v1.DashboardService/PreviewAttachGroupToDirectory"
	DashboardService_DetachGroupFromDirectory_FullMethodName                  = "/aiserver.v1.DashboardService/DetachGroupFromDirectory"
	DashboardService_GetScimConflicts_FullMethodName                          = "/aiserver.v1.DashboardService/GetScimConflicts"
	DashboardService_GetActivationCheckoutUrl_FullMethodName                  = "/aiserver.v1.DashboardService/GetActivationCheckoutUrl"
	DashboardService_GetTeamCustomerPortalUrl_FullMethodName                  = "/aiserver.v1.DashboardService/GetTeamCustomerPortalUrl"
	DashboardService_GetTeamMembers_FullMethodName                            = "/aiserver.v1.DashboardService/GetTeamMembers"
	DashboardService_SendTeamInvite_FullMethodName                            = "/aiserver.v1.DashboardService/SendTeamInvite"
	DashboardService_GetTeamInviteLink_FullMethodName                         = "/aiserver.v1.DashboardService/GetTeamInviteLink"
	DashboardService_AcceptInvite_FullMethodName                              = "/aiserver.v1.DashboardService/AcceptInvite"
	DashboardService_CreateTeam_FullMethodName                                = "/aiserver.v1.DashboardService/CreateTeam"
	DashboardService_GetJoinableTeamsByDomain_FullMethodName                  = "/aiserver.v1.DashboardService/GetJoinableTeamsByDomain"
	DashboardService_JoinTeamByDomain_FullMethodName                          = "/aiserver.v1.DashboardService/JoinTeamByDomain"
	DashboardService_UpdateTeamDomainJoinSetting_FullMethodName               = "/aiserver.v1.DashboardService/UpdateTeamDomainJoinSetting"
	DashboardService_GetTeamMemberDomains_FullMethodName                      = "/aiserver.v1.DashboardService/GetTeamMemberDomains"
	DashboardService_GetTeamIdForReactivation_FullMethodName                  = "/aiserver.v1.DashboardService/GetTeamIdForReactivation"
	DashboardService_ChangeSeat_FullMethodName                                = "/aiserver.v1.DashboardService/ChangeSeat"
	DashboardService_ChangeTeamSubscription_FullMethodName                    = "/aiserver.v1.DashboardService/ChangeTeamSubscription"
	DashboardService_ConnectGithubCallback_FullMethodName                     = "/aiserver.v1.DashboardService/ConnectGithubCallback"
	DashboardService_RegisterGithubCursorCode_FullMethodName                  = "/aiserver.v1.DashboardService/RegisterGithubCursorCode"
	DashboardService_DisconnectGithub_FullMethodName                          = "/aiserver.v1.DashboardService/DisconnectGithub"
	DashboardService_PrepareSetupGithubEnterpriseApp_FullMethodName           = "/aiserver.v1.DashboardService/PrepareSetupGithubEnterpriseApp"
	DashboardService_FinishSetupGithubEnterpriseApp_FullMethodName            = "/aiserver.v1.DashboardService/FinishSetupGithubEnterpriseApp"
	DashboardService_ListGithubEnterpriseApps_FullMethodName                  = "/aiserver.v1.DashboardService/ListGithubEnterpriseApps"
	DashboardService_DeleteGithubEnterpriseApp_FullMethodName                 = "/aiserver.v1.DashboardService/DeleteGithubEnterpriseApp"
	DashboardService_SetupGitlabEnterpriseInstance_FullMethodName             = "/aiserver.v1.DashboardService/SetupGitlabEnterpriseInstance"
	DashboardService_ListGitlabEnterpriseInstances_FullMethodName             = "/aiserver.v1.DashboardService/ListGitlabEnterpriseInstances"
	DashboardService_DeleteGitlabEnterpriseInstance_FullMethodName            = "/aiserver.v1.DashboardService/DeleteGitlabEnterpriseInstance"
	DashboardService_SyncGitlabRepos_FullMethodName                           = "/aiserver.v1.DashboardService/SyncGitlabRepos"
	DashboardService_UpdateRole_FullMethodName                                = "/aiserver.v1.DashboardService/UpdateRole"
	DashboardService_RemoveMember_FullMethodName                              = "/aiserver.v1.DashboardService/RemoveMember"
	DashboardService_GetTeamUsage_FullMethodName                              = "/aiserver.v1.DashboardService/GetTeamUsage"
	DashboardService_GetSignUpType_FullMethodName                             = "/aiserver.v1.DashboardService/GetSignUpType"
	DashboardService_GetHardLimit_FullMethodName                              = "/aiserver.v1.DashboardService/GetHardLimit"
	DashboardService_SetHardLimit_FullMethodName                              = "/aiserver.v1.DashboardService/SetHardLimit"
	DashboardService_EnableOnDemandSpend_FullMethodName                       = "/aiserver.v1.DashboardService/EnableOnDemandSpend"
	DashboardService_DeleteAccount_FullMethodName                             = "/aiserver.v1.DashboardService/DeleteAccount"
	DashboardService_SendDownloadEmail_FullMethodName                         = "/aiserver.v1.DashboardService/SendDownloadEmail"
	DashboardService_GetMonthlyInvoice_FullMethodName                         = "/aiserver.v1.DashboardService/GetMonthlyInvoice"
	DashboardService_ListInvoiceCycles_FullMethodName                         = "/aiserver.v1.DashboardService/ListInvoiceCycles"
	DashboardService_GetDailySpendByCategory_FullMethodName                   = "/aiserver.v1.DashboardService/GetDailySpendByCategory"
	DashboardService_GetPricingHistory_FullMethodName                         = "/aiserver.v1.DashboardService/GetPricingHistory"
	DashboardService_ListBackgroundComposerSecrets_FullMethodName             = "/aiserver.v1.DashboardService/ListBackgroundComposerSecrets"
	DashboardService_CreateBackgroundComposerSecret_FullMethodName            = "/aiserver.v1.DashboardService/CreateBackgroundComposerSecret"
	DashboardService_RevokeBackgroundComposerSecret_FullMethodName            = "/aiserver.v1.DashboardService/RevokeBackgroundComposerSecret"
	DashboardService_UpdateBackgroundComposerSecret_FullMethodName            = "/aiserver.v1.DashboardService/UpdateBackgroundComposerSecret"
	DashboardService_GetMcpConfig_FullMethodName                              = "/aiserver.v1.DashboardService/GetMcpConfig"
	DashboardService_GetAvailableMcpServers_FullMethodName                    = "/aiserver.v1.DashboardService/GetAvailableMcpServers"
	DashboardService_SetMcpConfig_FullMethodName                              = "/aiserver.v1.DashboardService/SetMcpConfig"
	DashboardService_UpdateUserDefaultMcpSettings_FullMethodName              = "/aiserver.v1.DashboardService/UpdateUserDefaultMcpSettings"
	DashboardService_StoreMcpOAuthToken_FullMethodName                        = "/aiserver.v1.DashboardService/StoreMcpOAuthToken"
	DashboardService_ValidateMcpOAuthTokens_FullMethodName                    = "/aiserver.v1.DashboardService/ValidateMcpOAuthTokens"
	DashboardService_StoreMcpOAuthPendingState_FullMethodName                 = "/aiserver.v1.DashboardService/StoreMcpOAuthPendingState"
	DashboardService_GetMcpOAuthPendingState_FullMethodName                   = "/aiserver.v1.DashboardService/GetMcpOAuthPendingState"
	DashboardService_CreateTeamWithFreeTrial_FullMethodName                   = "/aiserver.v1.DashboardService/CreateTeamWithFreeTrial"
	DashboardService_GetTeamHasValidPaymentMethod_FullMethodName              = "/aiserver.v1.DashboardService/GetTeamHasValidPaymentMethod"
	DashboardService_GetTeamPrivacyModeForced_FullMethodName                  = "/aiserver.v1.DashboardService/GetTeamPrivacyModeForced"
	DashboardService_SwitchTeamPrivacyMode_FullMethodName                     = "/aiserver.v1.DashboardService/SwitchTeamPrivacyMode"
	DashboardService_UpdateFastRequests_FullMethodName                        = "/aiserver.v1.DashboardService/UpdateFastRequests"
	DashboardService_GetFastRequests_FullMethodName                           = "/aiserver.v1.DashboardService/GetFastRequests"
	DashboardService_GetDownloadLink_FullMethodName                           = "/aiserver.v1.DashboardService/GetDownloadLink"
	DashboardService_GetCliDownloadUrl_FullMethodName                         = "/aiserver.v1.DashboardService/GetCliDownloadUrl"
	DashboardService_GetSsoConfigurationLinks_FullMethodName                  = "/aiserver.v1.DashboardService/GetSsoConfigurationLinks"
	DashboardService_GetScimConfigurationLinks_FullMethodName                 = "/aiserver.v1.DashboardService/GetScimConfigurationLinks"
	DashboardService_SetAdminOnlyUsagePricing_FullMethodName                  = "/aiserver.v1.DashboardService/SetAdminOnlyUsagePricing"
	DashboardService_GetYearlyUpgradeEligibility_FullMethodName               = "/aiserver.v1.DashboardService/GetYearlyUpgradeEligibility"
	DashboardService_UpgradeToYearly_FullMethodName                           = "/aiserver.v1.DashboardService/UpgradeToYearly"
	DashboardService_GetEnterpriseCTAEligibility_FullMethodName               = "/aiserver.v1.DashboardService/GetEnterpriseCTAEligibility"
	DashboardService_GetUsageBasedPremiumRequests_FullMethodName              = "/aiserver.v1.DashboardService/GetUsageBasedPremiumRequests"
	DashboardService_SetUsageBasedPremiumRequests_FullMethodName              = "/aiserver.v1.DashboardService/SetUsageBasedPremiumRequests"
	DashboardService_GetReferrals_FullMethodName                              = "/aiserver.v1.DashboardService/GetReferrals"
	DashboardService_CheckReferralCode_FullMethodName                         = "/aiserver.v1.DashboardService/CheckReferralCode"
	DashboardService_RedeemGiftCode_FullMethodName                            = "/aiserver.v1.DashboardService/RedeemGiftCode"
	DashboardService_GetTeamRepos_FullMethodName                              = "/aiserver.v1.DashboardService/GetTeamRepos"
	DashboardService_GetTeamReposOrEmptyIfNotInTeam_FullMethodName            = "/aiserver.v1.DashboardService/GetTeamReposOrEmptyIfNotInTeam"
	DashboardService_GetTeamRules_FullMethodName                              = "/aiserver.v1.DashboardService/GetTeamRules"
	DashboardService_CreateTeamRule_FullMethodName                            = "/aiserver.v1.DashboardService/CreateTeamRule"
	DashboardService_UpdateTeamRule_FullMethodName                            = "/aiserver.v1.DashboardService/UpdateTeamRule"
	DashboardService_DeleteTeamRule_FullMethodName                            = "/aiserver.v1.DashboardService/DeleteTeamRule"
	DashboardService_GetTeamHooks_FullMethodName                              = "/aiserver.v1.DashboardService/GetTeamHooks"
	DashboardService_CreateTeamHook_FullMethodName                            = "/aiserver.v1.DashboardService/CreateTeamHook"
	DashboardService_UpdateTeamHook_FullMethodName                            = "/aiserver.v1.DashboardService/UpdateTeamHook"
	DashboardService_DeleteTeamHook_FullMethodName                            = "/aiserver.v1.DashboardService/DeleteTeamHook"
	DashboardService_GetTeamCommands_FullMethodName                           = "/aiserver.v1.DashboardService/GetTeamCommands"
	DashboardService_CreateTeamCommand_FullMethodName                         = "/aiserver.v1.DashboardService/CreateTeamCommand"
	DashboardService_UpdateTeamCommand_FullMethodName                         = "/aiserver.v1.DashboardService/UpdateTeamCommand"
	DashboardService_DeleteTeamCommand_FullMethodName                         = "/aiserver.v1.DashboardService/DeleteTeamCommand"
	DashboardService_GetBugbotTeamRules_FullMethodName                        = "/aiserver.v1.DashboardService/GetBugbotTeamRules"
	DashboardService_CreateBugbotTeamRule_FullMethodName                      = "/aiserver.v1.DashboardService/CreateBugbotTeamRule"
	DashboardService_UpdateBugbotTeamRule_FullMethodName                      = "/aiserver.v1.DashboardService/UpdateBugbotTeamRule"
	DashboardService_DeleteBugbotTeamRule_FullMethodName                      = "/aiserver.v1.DashboardService/DeleteBugbotTeamRule"
	DashboardService_GetBugbotLearnedRules_FullMethodName                     = "/aiserver.v1.DashboardService/GetBugbotLearnedRules"
	DashboardService_UpdateBugbotLearnedRule_FullMethodName                   = "/aiserver.v1.DashboardService/UpdateBugbotLearnedRule"
	DashboardService_DeleteBugbotLearnedRule_FullMethodName                   = "/aiserver.v1.DashboardService/DeleteBugbotLearnedRule"
	DashboardService_CreateTeamRepo_FullMethodName                            = "/aiserver.v1.DashboardService/CreateTeamRepo"
	DashboardService_DeleteTeamRepo_FullMethodName                            = "/aiserver.v1.DashboardService/DeleteTeamRepo"
	DashboardService_AddRepoPattern_FullMethodName                            = "/aiserver.v1.DashboardService/AddRepoPattern"
	DashboardService_RemoveRepoPattern_FullMethodName                         = "/aiserver.v1.DashboardService/RemoveRepoPattern"
	DashboardService_SetTeamRepoType_FullMethodName                           = "/aiserver.v1.DashboardService/SetTeamRepoType"
	DashboardService_GetTeamAdminSettings_FullMethodName                      = "/aiserver.v1.DashboardService/GetTeamAdminSettings"
	DashboardService_GetTeamAdminSettingsOrEmptyIfNotInTeam_FullMethodName    = "/aiserver.v1.DashboardService/GetTeamAdminSettingsOrEmptyIfNotInTeam"
	DashboardService_GetBaseTeamAdminSettings_FullMethodName                  = "/aiserver.v1.DashboardService/GetBaseTeamAdminSettings"
	DashboardService_UpdateTeamAdminSettings_FullMethodName                   = "/aiserver.v1.DashboardService/UpdateTeamAdminSettings"
	DashboardService_CreateTeamFreeTrialCode_FullMethodName                   = "/aiserver.v1.DashboardService/CreateTeamFreeTrialCode"
	DashboardService_GetTeamAnalytics_FullMethodName                          = "/aiserver.v1.DashboardService/GetTeamAnalytics"
	DashboardService_GetUserAnalytics_FullMethodName                          = "/aiserver.v1.DashboardService/GetUserAnalytics"
	DashboardService_GetTeamRawData_FullMethodName                            = "/aiserver.v1.DashboardService/GetTeamRawData"
	DashboardService_GetClientUsageData_FullMethodName                        = "/aiserver.v1.DashboardService/GetClientUsageData"
	DashboardService_GetCurrentPeriodUsage_FullMethodName                     = "/aiserver.v1.DashboardService/GetCurrentPeriodUsage"
	DashboardService_GetPlanInfo_FullMethodName                               = "/aiserver.v1.DashboardService/GetPlanInfo"
	DashboardService_GetUsageLimitPolicyStatus_FullMethodName                 = "/aiserver.v1.DashboardService/GetUsageLimitPolicyStatus"
	DashboardService_GetAdvancedAnalyticsEnabled_FullMethodName               = "/aiserver.v1.DashboardService/GetAdvancedAnalyticsEnabled"
	DashboardService_GetTokenUsage_FullMethodName                             = "/aiserver.v1.DashboardService/GetTokenUsage"
	DashboardService_ValidateBedrockIamRole_FullMethodName                    = "/aiserver.v1.DashboardService/ValidateBedrockIamRole"
	DashboardService_AddUserToEarlyAccessList_FullMethodName                  = "/aiserver.v1.DashboardService/AddUserToEarlyAccessList"
	DashboardService_GetTeamSpend_FullMethodName                              = "/aiserver.v1.DashboardService/GetTeamSpend"
	DashboardService_GetCurrentBillingCycle_FullMethodName                    = "/aiserver.v1.DashboardService/GetCurrentBillingCycle"
	DashboardService_GetMonthlyBillingCycle_FullMethodName                    = "/aiserver.v1.DashboardService/GetMonthlyBillingCycle"
	DashboardService_GetBugbotSettings_FullMethodName                         = "/aiserver.v1.DashboardService/GetBugbotSettings"
	DashboardService_GetBugbotAnalyticsV2_FullMethodName                      = "/aiserver.v1.DashboardService/GetBugbotAnalyticsV2"
	DashboardService_GetBugBotPRAnalytics_FullMethodName                      = "/aiserver.v1.DashboardService/GetBugBotPRAnalytics"
	DashboardService_GetGithubInstallations_FullMethodName                    = "/aiserver.v1.DashboardService/GetGithubInstallations"
	DashboardService_GetInstallationRepos_FullMethodName                      = "/aiserver.v1.DashboardService/GetInstallationRepos"
	DashboardService_FetchAllInstallationRepos_FullMethodName                 = "/aiserver.v1.DashboardService/FetchAllInstallationRepos"
	DashboardService_GetInstallationGithubUsers_FullMethodName                = "/aiserver.v1.DashboardService/GetInstallationGithubUsers"
	DashboardService_GetTeamGithubUsers_FullMethodName                        = "/aiserver.v1.DashboardService/GetTeamGithubUsers"
	DashboardService_AddGithubUsersToTeam_FullMethodName                      = "/aiserver.v1.DashboardService/AddGithubUsersToTeam"
	DashboardService_GetUserPullRequests_FullMethodName                       = "/aiserver.v1.DashboardService/GetUserPullRequests"
	DashboardService_GetUserReviewRequests_FullMethodName                     = "/aiserver.v1.DashboardService/GetUserReviewRequests"
	DashboardService_UpdateGithubRepoSettings_FullMethodName                  = "/aiserver.v1.DashboardService/UpdateGithubRepoSettings"
	DashboardService_UpdateGithubInstallationSettings_FullMethodName          = "/aiserver.v1.DashboardService/UpdateGithubInstallationSettings"
	DashboardService_UpdateAllGithubRepoSettings_FullMethodName               = "/aiserver.v1.DashboardService/UpdateAllGithubRepoSettings"
	DashboardService_UpdateGithubInstallationTeamScope_FullMethodName         = "/aiserver.v1.DashboardService/UpdateGithubInstallationTeamScope"
	DashboardService_UpdateSelfGithubAllowlist_FullMethodName                 = "/aiserver.v1.DashboardService/UpdateSelfGithubAllowlist"
	DashboardService_GetTeamBugbotSettings_FullMethodName                     = "/aiserver.v1.DashboardService/GetTeamBugbotSettings"
	DashboardService_UpdateTeamBugbotSettings_FullMethodName                  = "/aiserver.v1.DashboardService/UpdateTeamBugbotSettings"
	DashboardService_GetBugbotUserSettings_FullMethodName                     = "/aiserver.v1.DashboardService/GetBugbotUserSettings"
	DashboardService_UpdateBugbotUserSettings_FullMethodName                  = "/aiserver.v1.DashboardService/UpdateBugbotUserSettings"
	DashboardService_GetBugBotProUserSettings_FullMethodName                  = "/aiserver.v1.DashboardService/GetBugBotProUserSettings"
	DashboardService_UpdateBugBotProUserSettings_FullMethodName               = "/aiserver.v1.DashboardService/UpdateBugBotProUserSettings"
	DashboardService_RecordBugbotDeeplinkEvent_FullMethodName                 = "/aiserver.v1.DashboardService/RecordBugbotDeeplinkEvent"
	DashboardService_RecordBugbotDeeplinkEventUnauthenticated_FullMethodName  = "/aiserver.v1.DashboardService/RecordBugbotDeeplinkEventUnauthenticated"
	DashboardService_RevokeBugBotLicenses_FullMethodName                      = "/aiserver.v1.DashboardService/RevokeBugBotLicenses"
	DashboardService_RevokeUserBugbotLicense_FullMethodName                   = "/aiserver.v1.DashboardService/RevokeUserBugbotLicense"
	DashboardService_StartBugbotBackfillLearning_FullMethodName               = "/aiserver.v1.DashboardService/StartBugbotBackfillLearning"
	DashboardService_SetSlackAuth_FullMethodName                              = "/aiserver.v1.DashboardService/SetSlackAuth"
	DashboardService_GetSlackTeamSettings_FullMethodName                      = "/aiserver.v1.DashboardService/GetSlackTeamSettings"
	DashboardService_UpdateSlackTeamSettings_FullMethodName                   = "/aiserver.v1.DashboardService/UpdateSlackTeamSettings"
	DashboardService_GetSlackSettings_FullMethodName                          = "/aiserver.v1.DashboardService/GetSlackSettings"
	DashboardService_GetSlackModelOptions_FullMethodName                      = "/aiserver.v1.DashboardService/GetSlackModelOptions"
	DashboardService_GetSlackInstallUrl_FullMethodName                        = "/aiserver.v1.DashboardService/GetSlackInstallUrl"
	DashboardService_GetSlackInstallUrlPublic_FullMethodName                  = "/aiserver.v1.DashboardService/GetSlackInstallUrlPublic"
	DashboardService_GetFilteredUsageEvents_FullMethodName                    = "/aiserver.v1.DashboardService/GetFilteredUsageEvents"
	DashboardService_GetAggregatedUsageEvents_FullMethodName                  = "/aiserver.v1.DashboardService/GetAggregatedUsageEvents"
	DashboardService_GetAuditLogs_FullMethodName                              = "/aiserver.v1.DashboardService/GetAuditLogs"
	DashboardService_GetUserPrivacyMode_FullMethodName                        = "/aiserver.v1.DashboardService/GetUserPrivacyMode"
	DashboardService_SetUserPrivacyMode_FullMethodName                        = "/aiserver.v1.DashboardService/SetUserPrivacyMode"
	DashboardService_WebAcknowledgeGracePeriodDisclaimer_FullMethodName       = "/aiserver.v1.DashboardService/WebAcknowledgeGracePeriodDisclaimer"
	DashboardService_SkipPrivacyModeGracePeriod_FullMethodName                = "/aiserver.v1.DashboardService/SkipPrivacyModeGracePeriod"
	DashboardService_NeedsPrivacyModeMigration_FullMethodName                 = "/aiserver.v1.DashboardService/NeedsPrivacyModeMigration"
	DashboardService_UpdateTeamPrivacyModeMigrationOptOut_FullMethodName      = "/aiserver.v1.DashboardService/UpdateTeamPrivacyModeMigrationOptOut"
	DashboardService_ShareConversation_FullMethodName                         = "/aiserver.v1.DashboardService/ShareConversation"
	DashboardService_GetSharedConversation_FullMethodName                     = "/aiserver.v1.DashboardService/GetSharedConversation"
	DashboardService_GetPublicSharedConversation_FullMethodName               = "/aiserver.v1.DashboardService/GetPublicSharedConversation"
	DashboardService_ListSharedConversations_FullMethodName                   = "/aiserver.v1.DashboardService/ListSharedConversations"
	DashboardService_DeleteSharedConversation_FullMethodName                  = "/aiserver.v1.DashboardService/DeleteSharedConversation"
	DashboardService_UpdateSharedConversationVisibility_FullMethodName        = "/aiserver.v1.DashboardService/UpdateSharedConversationVisibility"
	DashboardService_RevokeTeamInviteLink_FullMethodName                      = "/aiserver.v1.DashboardService/RevokeTeamInviteLink"
	DashboardService_ListTeamInviteLinks_FullMethodName                       = "/aiserver.v1.DashboardService/ListTeamInviteLinks"
	DashboardService_UpdateUserName_FullMethodName                            = "/aiserver.v1.DashboardService/UpdateUserName"
	DashboardService_ListInvoices_FullMethodName                              = "/aiserver.v1.DashboardService/ListInvoices"
	DashboardService_IsEligibleForRefund_FullMethodName                       = "/aiserver.v1.DashboardService/IsEligibleForRefund"
	DashboardService_GetRemainingRefunds_FullMethodName                       = "/aiserver.v1.DashboardService/GetRemainingRefunds"
	DashboardService_GetServiceAccountSpendLimit_FullMethodName               = "/aiserver.v1.DashboardService/GetServiceAccountSpendLimit"
	DashboardService_SetServiceAccountSpendLimit_FullMethodName               = "/aiserver.v1.DashboardService/SetServiceAccountSpendLimit"
	DashboardService_SetUserHardLimit_FullMethodName                          = "/aiserver.v1.DashboardService/SetUserHardLimit"
	DashboardService_SetUserMonthlyLimit_FullMethodName                       = "/aiserver.v1.DashboardService/SetUserMonthlyLimit"
	DashboardService_ToggleMarketingEmailOpt_FullMethodName                   = "/aiserver.v1.DashboardService/ToggleMarketingEmailOpt"
	DashboardService_GetMarketingEmailOpt_FullMethodName                      = "/aiserver.v1.DashboardService/GetMarketingEmailOpt"
	DashboardService_GetGlobalLeaderboardOptIn_FullMethodName                 = "/aiserver.v1.DashboardService/GetGlobalLeaderboardOptIn"
	DashboardService_SetGlobalLeaderboardOptIn_FullMethodName                 = "/aiserver.v1.DashboardService/SetGlobalLeaderboardOptIn"
	DashboardService_CreateTeamApiKey_FullMethodName                          = "/aiserver.v1.DashboardService/CreateTeamApiKey"
	DashboardService_RevokeTeamApiKey_FullMethodName                          = "/aiserver.v1.DashboardService/RevokeTeamApiKey"
	DashboardService_ListTeamApiKeys_FullMethodName                           = "/aiserver.v1.DashboardService/ListTeamApiKeys"
	DashboardService_CreateTeamServiceAccount_FullMethodName                  = "/aiserver.v1.DashboardService/CreateTeamServiceAccount"
	DashboardService_ListTeamServiceAccounts_FullMethodName                   = "/aiserver.v1.DashboardService/ListTeamServiceAccounts"
	DashboardService_DeleteTeamServiceAccount_FullMethodName                  = "/aiserver.v1.DashboardService/DeleteTeamServiceAccount"
	DashboardService_ArchiveTeamServiceAccount_FullMethodName                 = "/aiserver.v1.DashboardService/ArchiveTeamServiceAccount"
	DashboardService_RotateServiceAccountApiKey_FullMethodName                = "/aiserver.v1.DashboardService/RotateServiceAccountApiKey"
	DashboardService_GetTeamRepositoriesForServiceAccountScope_FullMethodName = "/aiserver.v1.DashboardService/GetTeamRepositoriesForServiceAccountScope"
	DashboardService_UpdateServiceAccountRepoScope_FullMethodName             = "/aiserver.v1.DashboardService/UpdateServiceAccountRepoScope"
	DashboardService_CreateUserApiKey_FullMethodName                          = "/aiserver.v1.DashboardService/CreateUserApiKey"
	DashboardService_RevokeUserApiKey_FullMethodName                          = "/aiserver.v1.DashboardService/RevokeUserApiKey"
	DashboardService_ListUserApiKeys_FullMethodName                           = "/aiserver.v1.DashboardService/ListUserApiKeys"
	DashboardService_ConfirmGithubInstallation_FullMethodName                 = "/aiserver.v1.DashboardService/ConfirmGithubInstallation"
	DashboardService_UpdateTeamName_FullMethodName                            = "/aiserver.v1.DashboardService/UpdateTeamName"
	DashboardService_UpdateTeamDashboardAnalyticsSetting_FullMethodName       = "/aiserver.v1.DashboardService/UpdateTeamDashboardAnalyticsSetting"
	DashboardService_GetSlackUserSettings_FullMethodName                      = "/aiserver.v1.DashboardService/GetSlackUserSettings"
	DashboardService_UpdateSlackUserSettings_FullMethodName                   = "/aiserver.v1.DashboardService/UpdateSlackUserSettings"
	DashboardService_GetSlackRepoRoutingRules_FullMethodName                  = "/aiserver.v1.DashboardService/GetSlackRepoRoutingRules"
	DashboardService_CreateSlackRepoRoutingRule_FullMethodName                = "/aiserver.v1.DashboardService/CreateSlackRepoRoutingRule"
	DashboardService_UpdateSlackRepoRoutingRule_FullMethodName                = "/aiserver.v1.DashboardService/UpdateSlackRepoRoutingRule"
	DashboardService_DeleteSlackRepoRoutingRule_FullMethodName                = "/aiserver.v1.DashboardService/DeleteSlackRepoRoutingRule"
	DashboardService_IsOnNewPricing_FullMethodName                            = "/aiserver.v1.DashboardService/IsOnNewPricing"
	DashboardService_GetLinearAuthUrl_FullMethodName                          = "/aiserver.v1.DashboardService/GetLinearAuthUrl"
	DashboardService_GetLinearStatus_FullMethodName                           = "/aiserver.v1.DashboardService/GetLinearStatus"
	DashboardService_DisconnectLinear_FullMethodName                          = "/aiserver.v1.DashboardService/DisconnectLinear"
	DashboardService_GetLinearTeams_FullMethodName                            = "/aiserver.v1.DashboardService/GetLinearTeams"
	DashboardService_GetLinearSettings_FullMethodName                         = "/aiserver.v1.DashboardService/GetLinearSettings"
	DashboardService_UpdateLinearTeamSetting_FullMethodName                   = "/aiserver.v1.DashboardService/UpdateLinearTeamSetting"
	DashboardService_UpdateLinearProjectSetting_FullMethodName                = "/aiserver.v1.DashboardService/UpdateLinearProjectSetting"
	DashboardService_GetLinearLabels_FullMethodName                           = "/aiserver.v1.DashboardService/GetLinearLabels"
	DashboardService_GetLinearIssues_FullMethodName                           = "/aiserver.v1.DashboardService/GetLinearIssues"
	DashboardService_DeleteBedrockIamRole_FullMethodName                      = "/aiserver.v1.DashboardService/DeleteBedrockIamRole"
	DashboardService_UnlinkSlackAccess_FullMethodName                         = "/aiserver.v1.DashboardService/UnlinkSlackAccess"
	DashboardService_ListSlackConversations_FullMethodName                    = "/aiserver.v1.DashboardService/ListSlackConversations"
	DashboardService_LogSlackbotAuthConversionFunnel_FullMethodName           = "/aiserver.v1.DashboardService/LogSlackbotAuthConversionFunnel"
	DashboardService_LogClickedConnectSlack_FullMethodName                    = "/aiserver.v1.DashboardService/LogClickedConnectSlack"
	DashboardService_CheckUserApiKeyAccess_FullMethodName                     = "/aiserver.v1.DashboardService/CheckUserApiKeyAccess"
	DashboardService_IsAllowedFreeTrialUsage_FullMethodName                   = "/aiserver.v1.DashboardService/IsAllowedFreeTrialUsage"
	DashboardService_CompletedLinkSlackAccount_FullMethodName                 = "/aiserver.v1.DashboardService/CompletedLinkSlackAccount"
	DashboardService_NotifyTeamAdmins_FullMethodName                          = "/aiserver.v1.DashboardService/NotifyTeamAdmins"
	DashboardService_GetAdminNotificationStatus_FullMethodName                = "/aiserver.v1.DashboardService/GetAdminNotificationStatus"
	DashboardService_OptOutNewPricing_FullMethodName                          = "/aiserver.v1.DashboardService/OptOutNewPricing"
	DashboardService_SubmitFeedback_FullMethodName                            = "/aiserver.v1.DashboardService/SubmitFeedback"
	DashboardService_CanStudentReverify_FullMethodName                        = "/aiserver.v1.DashboardService/CanStudentReverify"
	DashboardService_ClientAction_FullMethodName                              = "/aiserver.v1.DashboardService/ClientAction"
	DashboardService_ListUsageAlerts_FullMethodName                           = "/aiserver.v1.DashboardService/ListUsageAlerts"
	DashboardService_CreateUsageAlerts_FullMethodName                         = "/aiserver.v1.DashboardService/CreateUsageAlerts"
	DashboardService_DeleteUsageAlerts_FullMethodName                         = "/aiserver.v1.DashboardService/DeleteUsageAlerts"
	DashboardService_UpdateUsageAlerts_FullMethodName                         = "/aiserver.v1.DashboardService/UpdateUsageAlerts"
	DashboardService_RequestIndividualLimitsOptOut_FullMethodName             = "/aiserver.v1.DashboardService/RequestIndividualLimitsOptOut"
)

// DashboardServiceClient is the client API for DashboardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.DashboardService (var: Nje)
type DashboardServiceClient interface {
	GetTeams(ctx context.Context, in *GetTeamsRequest, opts ...grpc.CallOption) (*GetTeamsResponse, error)
	GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error)
	GetDirectoryGroups(ctx context.Context, in *GetDirectoryGroupsRequest, opts ...grpc.CallOption) (*GetDirectoryGroupsResponse, error)
	UpdateDirectoryGroupSettings(ctx context.Context, in *UpdateDirectoryGroupSettingsRequest, opts ...grpc.CallOption) (*UpdateDirectoryGroupSettingsResponse, error)
	GetGroups(ctx context.Context, in *GetGroupsRequest, opts ...grpc.CallOption) (*GetGroupsResponse, error)
	GetGroupMembers(ctx context.Context, in *GetGroupMembersRequest, opts ...grpc.CallOption) (*GetGroupMembersResponse, error)
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error)
	DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*DeleteGroupResponse, error)
	AddGroupMembers(ctx context.Context, in *AddGroupMembersRequest, opts ...grpc.CallOption) (*AddGroupMembersResponse, error)
	RemoveGroupMembers(ctx context.Context, in *RemoveGroupMembersRequest, opts ...grpc.CallOption) (*RemoveGroupMembersResponse, error)
	BulkAssignGroupMembers(ctx context.Context, in *BulkAssignGroupMembersRequest, opts ...grpc.CallOption) (*BulkAssignGroupMembersResponse, error)
	PreviewAttachGroupToDirectory(ctx context.Context, in *PreviewAttachGroupToDirectoryRequest, opts ...grpc.CallOption) (*PreviewAttachGroupToDirectoryResponse, error)
	DetachGroupFromDirectory(ctx context.Context, in *DetachGroupFromDirectoryRequest, opts ...grpc.CallOption) (*DetachGroupFromDirectoryResponse, error)
	GetScimConflicts(ctx context.Context, in *GetScimConflictsRequest, opts ...grpc.CallOption) (*GetScimConflictsResponse, error)
	GetActivationCheckoutUrl(ctx context.Context, in *GetActivationCheckoutUrlRequest, opts ...grpc.CallOption) (*GetActivationCheckoutUrlResponse, error)
	GetTeamCustomerPortalUrl(ctx context.Context, in *GetTeamCustomerPortalUrlRequest, opts ...grpc.CallOption) (*GetTeamCustomerPortalUrlResponse, error)
	GetTeamMembers(ctx context.Context, in *GetTeamMembersRequest, opts ...grpc.CallOption) (*GetTeamMembersResponse, error)
	SendTeamInvite(ctx context.Context, in *SendTeamInviteRequest, opts ...grpc.CallOption) (*SendTeamInviteResponse, error)
	GetTeamInviteLink(ctx context.Context, in *GetTeamInviteLinkRequest, opts ...grpc.CallOption) (*GetTeamInviteLinkResponse, error)
	AcceptInvite(ctx context.Context, in *AcceptInviteRequest, opts ...grpc.CallOption) (*AcceptInviteResponse, error)
	CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*CreateTeamResponse, error)
	GetJoinableTeamsByDomain(ctx context.Context, in *GetJoinableTeamsByDomainRequest, opts ...grpc.CallOption) (*GetJoinableTeamsByDomainResponse, error)
	JoinTeamByDomain(ctx context.Context, in *JoinTeamByDomainRequest, opts ...grpc.CallOption) (*JoinTeamByDomainResponse, error)
	UpdateTeamDomainJoinSetting(ctx context.Context, in *UpdateTeamDomainJoinSettingRequest, opts ...grpc.CallOption) (*UpdateTeamDomainJoinSettingResponse, error)
	GetTeamMemberDomains(ctx context.Context, in *GetTeamMemberDomainsRequest, opts ...grpc.CallOption) (*GetTeamMemberDomainsResponse, error)
	GetTeamIdForReactivation(ctx context.Context, in *GetTeamIdForReactivationRequest, opts ...grpc.CallOption) (*GetTeamIdForReactivationResponse, error)
	ChangeSeat(ctx context.Context, in *ChangeSeatRequest, opts ...grpc.CallOption) (*ChangeSeatResponse, error)
	ChangeTeamSubscription(ctx context.Context, in *ChangeTeamSubscriptionRequest, opts ...grpc.CallOption) (*ChangeTeamSubscriptionResponse, error)
	ConnectGithubCallback(ctx context.Context, in *ConnectGithubCallbackRequest, opts ...grpc.CallOption) (*ConnectGithubCallbackResponse, error)
	RegisterGithubCursorCode(ctx context.Context, in *RegisterGithubCursorCodeRequest, opts ...grpc.CallOption) (*RegisterGithubCursorCodeResponse, error)
	DisconnectGithub(ctx context.Context, in *DisconnectGithubRequest, opts ...grpc.CallOption) (*DisconnectGithubResponse, error)
	PrepareSetupGithubEnterpriseApp(ctx context.Context, in *PrepareSetupGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*PrepareSetupGithubEnterpriseAppResponse, error)
	FinishSetupGithubEnterpriseApp(ctx context.Context, in *FinishSetupGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*FinishSetupGithubEnterpriseAppResponse, error)
	ListGithubEnterpriseApps(ctx context.Context, in *ListGithubEnterpriseAppsRequest, opts ...grpc.CallOption) (*ListGithubEnterpriseAppsResponse, error)
	DeleteGithubEnterpriseApp(ctx context.Context, in *DeleteGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*DeleteGithubEnterpriseAppResponse, error)
	SetupGitlabEnterpriseInstance(ctx context.Context, in *SetupGitlabEnterpriseInstanceRequest, opts ...grpc.CallOption) (*SetupGitlabEnterpriseInstanceResponse, error)
	ListGitlabEnterpriseInstances(ctx context.Context, in *ListGitlabEnterpriseInstancesRequest, opts ...grpc.CallOption) (*ListGitlabEnterpriseInstancesResponse, error)
	DeleteGitlabEnterpriseInstance(ctx context.Context, in *DeleteGitlabEnterpriseInstanceRequest, opts ...grpc.CallOption) (*DeleteGitlabEnterpriseInstanceResponse, error)
	SyncGitlabRepos(ctx context.Context, in *SyncGitlabReposRequest, opts ...grpc.CallOption) (*SyncGitlabReposResponse, error)
	UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*UpdateRoleResponse, error)
	RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error)
	GetTeamUsage(ctx context.Context, in *GetTeamUsageRequest, opts ...grpc.CallOption) (*GetTeamUsageResponse, error)
	GetSignUpType(ctx context.Context, in *GetSignUpTypeRequest, opts ...grpc.CallOption) (*GetSignUpTypeResponse, error)
	GetHardLimit(ctx context.Context, in *GetHardLimitRequest, opts ...grpc.CallOption) (*GetHardLimitResponse, error)
	SetHardLimit(ctx context.Context, in *SetHardLimitRequest, opts ...grpc.CallOption) (*SetHardLimitResponse, error)
	EnableOnDemandSpend(ctx context.Context, in *EnableOnDemandSpendRequest, opts ...grpc.CallOption) (*EnableOnDemandSpendResponse, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error)
	SendDownloadEmail(ctx context.Context, in *SendDownloadEmailRequest, opts ...grpc.CallOption) (*SendDownloadEmailResponse, error)
	GetMonthlyInvoice(ctx context.Context, in *GetMonthlyInvoiceRequest, opts ...grpc.CallOption) (*GetMonthlyInvoiceResponse, error)
	ListInvoiceCycles(ctx context.Context, in *ListInvoiceCyclesRequest, opts ...grpc.CallOption) (*ListInvoiceCyclesResponse, error)
	GetDailySpendByCategory(ctx context.Context, in *GetDailySpendByCategoryRequest, opts ...grpc.CallOption) (*GetDailySpendByCategoryResponse, error)
	GetPricingHistory(ctx context.Context, in *GetPricingHistoryRequest, opts ...grpc.CallOption) (*GetPricingHistoryResponse, error)
	ListBackgroundComposerSecrets(ctx context.Context, in *ListBackgroundComposerSecretsRequest, opts ...grpc.CallOption) (*ListBackgroundComposerSecretsResponse, error)
	CreateBackgroundComposerSecret(ctx context.Context, in *CreateBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerSecretResponse, error)
	RevokeBackgroundComposerSecret(ctx context.Context, in *RevokeBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*RevokeBackgroundComposerSecretResponse, error)
	UpdateBackgroundComposerSecret(ctx context.Context, in *UpdateBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerSecretResponse, error)
	GetMcpConfig(ctx context.Context, in *GetMcpConfigRequest, opts ...grpc.CallOption) (*GetMcpConfigResponse, error)
	GetAvailableMcpServers(ctx context.Context, in *GetAvailableMcpServersRequest, opts ...grpc.CallOption) (*GetAvailableMcpServersResponse, error)
	SetMcpConfig(ctx context.Context, in *SetMcpConfigRequest, opts ...grpc.CallOption) (*SetMcpConfigResponse, error)
	UpdateUserDefaultMcpSettings(ctx context.Context, in *UpdateUserDefaultMcpSettingsRequest, opts ...grpc.CallOption) (*UpdateUserDefaultMcpSettingsResponse, error)
	StoreMcpOAuthToken(ctx context.Context, in *StoreMcpOAuthTokenRequest, opts ...grpc.CallOption) (*StoreMcpOAuthTokenResponse, error)
	ValidateMcpOAuthTokens(ctx context.Context, in *ValidateMcpOAuthTokensRequest, opts ...grpc.CallOption) (*ValidateMcpOAuthTokensResponse, error)
	StoreMcpOAuthPendingState(ctx context.Context, in *StoreMcpOAuthPendingStateRequest, opts ...grpc.CallOption) (*StoreMcpOAuthPendingStateResponse, error)
	GetMcpOAuthPendingState(ctx context.Context, in *GetMcpOAuthPendingStateRequest, opts ...grpc.CallOption) (*GetMcpOAuthPendingStateResponse, error)
	CreateTeamWithFreeTrial(ctx context.Context, in *CreateTeamWithFreeTrialRequest, opts ...grpc.CallOption) (*CreateTeamWithFreeTrialResponse, error)
	GetTeamHasValidPaymentMethod(ctx context.Context, in *GetTeamHasValidPaymentMethodRequest, opts ...grpc.CallOption) (*GetTeamHasValidPaymentMethodResponse, error)
	GetTeamPrivacyModeForced(ctx context.Context, in *GetTeamPrivacyModeForcedRequest, opts ...grpc.CallOption) (*GetTeamPrivacyModeForcedResponse, error)
	SwitchTeamPrivacyMode(ctx context.Context, in *SwitchTeamPrivacyModeRequest, opts ...grpc.CallOption) (*SwitchTeamPrivacyModeResponse, error)
	UpdateFastRequests(ctx context.Context, in *UpdateFastRequestsRequest, opts ...grpc.CallOption) (*UpdateFastRequestsResponse, error)
	GetFastRequests(ctx context.Context, in *GetFastRequestsRequest, opts ...grpc.CallOption) (*GetFastRequestsResponse, error)
	GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error)
	GetCliDownloadUrl(ctx context.Context, in *GetCliDownloadUrlRequest, opts ...grpc.CallOption) (*GetCliDownloadUrlResponse, error)
	GetSsoConfigurationLinks(ctx context.Context, in *GetSsoConfigurationLinksRequest, opts ...grpc.CallOption) (*GetSsoConfigurationLinksResponse, error)
	GetScimConfigurationLinks(ctx context.Context, in *GetScimConfigurationLinksRequest, opts ...grpc.CallOption) (*GetScimConfigurationLinksResponse, error)
	SetAdminOnlyUsagePricing(ctx context.Context, in *SetAdminOnlyUsagePricingRequest, opts ...grpc.CallOption) (*SetAdminOnlyUsagePricingResponse, error)
	GetYearlyUpgradeEligibility(ctx context.Context, in *GetYearlyUpgradeEligibilityRequest, opts ...grpc.CallOption) (*GetYearlyUpgradeEligibilityResponse, error)
	UpgradeToYearly(ctx context.Context, in *UpgradeToYearlyRequest, opts ...grpc.CallOption) (*UpgradeToYearlyResponse, error)
	GetEnterpriseCTAEligibility(ctx context.Context, in *GetEnterpriseCTAEligibilityRequest, opts ...grpc.CallOption) (*GetEnterpriseCTAEligibilityResponse, error)
	GetUsageBasedPremiumRequests(ctx context.Context, in *GetUsageBasedPremiumRequestsRequest, opts ...grpc.CallOption) (*GetUsageBasedPremiumRequestsResponse, error)
	SetUsageBasedPremiumRequests(ctx context.Context, in *SetUsageBasedPremiumRequestsRequest, opts ...grpc.CallOption) (*SetUsageBasedPremiumRequestsResponse, error)
	GetReferrals(ctx context.Context, in *GetReferralsRequest, opts ...grpc.CallOption) (*GetReferralsResponse, error)
	CheckReferralCode(ctx context.Context, in *CheckReferralCodeRequest, opts ...grpc.CallOption) (*CheckReferralCodeResponse, error)
	RedeemGiftCode(ctx context.Context, in *RedeemGiftCodeRequest, opts ...grpc.CallOption) (*RedeemGiftCodeResponse, error)
	GetTeamRepos(ctx context.Context, in *GetTeamReposRequest, opts ...grpc.CallOption) (*GetTeamReposResponse, error)
	GetTeamReposOrEmptyIfNotInTeam(ctx context.Context, in *GetTeamReposRequest, opts ...grpc.CallOption) (*GetTeamReposResponse, error)
	GetTeamRules(ctx context.Context, in *GetTeamRulesRequest, opts ...grpc.CallOption) (*GetTeamRulesResponse, error)
	CreateTeamRule(ctx context.Context, in *CreateTeamRuleRequest, opts ...grpc.CallOption) (*CreateTeamRuleResponse, error)
	UpdateTeamRule(ctx context.Context, in *UpdateTeamRuleRequest, opts ...grpc.CallOption) (*UpdateTeamRuleResponse, error)
	DeleteTeamRule(ctx context.Context, in *DeleteTeamRuleRequest, opts ...grpc.CallOption) (*DeleteTeamRuleResponse, error)
	GetTeamHooks(ctx context.Context, in *GetTeamHooksRequest, opts ...grpc.CallOption) (*GetTeamHooksResponse, error)
	CreateTeamHook(ctx context.Context, in *CreateTeamHookRequest, opts ...grpc.CallOption) (*CreateTeamHookResponse, error)
	UpdateTeamHook(ctx context.Context, in *UpdateTeamHookRequest, opts ...grpc.CallOption) (*UpdateTeamHookResponse, error)
	DeleteTeamHook(ctx context.Context, in *DeleteTeamHookRequest, opts ...grpc.CallOption) (*DeleteTeamHookResponse, error)
	GetTeamCommands(ctx context.Context, in *GetTeamCommandsRequest, opts ...grpc.CallOption) (*GetTeamCommandsResponse, error)
	CreateTeamCommand(ctx context.Context, in *CreateTeamCommandRequest, opts ...grpc.CallOption) (*CreateTeamCommandResponse, error)
	UpdateTeamCommand(ctx context.Context, in *UpdateTeamCommandRequest, opts ...grpc.CallOption) (*UpdateTeamCommandResponse, error)
	DeleteTeamCommand(ctx context.Context, in *DeleteTeamCommandRequest, opts ...grpc.CallOption) (*DeleteTeamCommandResponse, error)
	GetBugbotTeamRules(ctx context.Context, in *GetBugbotTeamRulesRequest, opts ...grpc.CallOption) (*GetBugbotTeamRulesResponse, error)
	CreateBugbotTeamRule(ctx context.Context, in *CreateBugbotTeamRuleRequest, opts ...grpc.CallOption) (*CreateBugbotTeamRuleResponse, error)
	UpdateBugbotTeamRule(ctx context.Context, in *UpdateBugbotTeamRuleRequest, opts ...grpc.CallOption) (*UpdateBugbotTeamRuleResponse, error)
	DeleteBugbotTeamRule(ctx context.Context, in *DeleteBugbotTeamRuleRequest, opts ...grpc.CallOption) (*DeleteBugbotTeamRuleResponse, error)
	GetBugbotLearnedRules(ctx context.Context, in *GetBugbotLearnedRulesRequest, opts ...grpc.CallOption) (*GetBugbotLearnedRulesResponse, error)
	UpdateBugbotLearnedRule(ctx context.Context, in *UpdateBugbotLearnedRuleRequest, opts ...grpc.CallOption) (*UpdateBugbotLearnedRuleResponse, error)
	DeleteBugbotLearnedRule(ctx context.Context, in *DeleteBugbotLearnedRuleRequest, opts ...grpc.CallOption) (*DeleteBugbotLearnedRuleResponse, error)
	CreateTeamRepo(ctx context.Context, in *CreateTeamRepoRequest, opts ...grpc.CallOption) (*CreateTeamRepoResponse, error)
	DeleteTeamRepo(ctx context.Context, in *DeleteTeamRepoRequest, opts ...grpc.CallOption) (*DeleteTeamRepoResponse, error)
	AddRepoPattern(ctx context.Context, in *AddRepoPatternRequest, opts ...grpc.CallOption) (*AddRepoPatternResponse, error)
	RemoveRepoPattern(ctx context.Context, in *RemoveRepoPatternRequest, opts ...grpc.CallOption) (*RemoveRepoPatternResponse, error)
	SetTeamRepoType(ctx context.Context, in *SetTeamRepoTypeRequest, opts ...grpc.CallOption) (*SetTeamRepoTypeResponse, error)
	GetTeamAdminSettings(ctx context.Context, in *GetTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error)
	GetTeamAdminSettingsOrEmptyIfNotInTeam(ctx context.Context, in *GetTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error)
	GetBaseTeamAdminSettings(ctx context.Context, in *GetBaseTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error)
	UpdateTeamAdminSettings(ctx context.Context, in *UpdateTeamAdminSettingsRequest, opts ...grpc.CallOption) (*UpdateTeamAdminSettingsResponse, error)
	CreateTeamFreeTrialCode(ctx context.Context, in *CreateTeamFreeTrialCodeRequest, opts ...grpc.CallOption) (*CreateTeamFreeTrialCodeResponse, error)
	GetTeamAnalytics(ctx context.Context, in *GetTeamAnalyticsRequest, opts ...grpc.CallOption) (*GetTeamAnalyticsResponse, error)
	GetUserAnalytics(ctx context.Context, in *GetUserAnalyticsRequest, opts ...grpc.CallOption) (*GetUserAnalyticsResponse, error)
	GetTeamRawData(ctx context.Context, in *GetTeamRawDataRequest, opts ...grpc.CallOption) (*GetTeamRawDataResponse, error)
	GetClientUsageData(ctx context.Context, in *GetClientUsageDataRequest, opts ...grpc.CallOption) (*GetClientUsageDataResponse, error)
	GetCurrentPeriodUsage(ctx context.Context, in *GetCurrentPeriodUsageRequest, opts ...grpc.CallOption) (*GetCurrentPeriodUsageResponse, error)
	GetPlanInfo(ctx context.Context, in *GetPlanInfoRequest, opts ...grpc.CallOption) (*GetPlanInfoResponse, error)
	GetUsageLimitPolicyStatus(ctx context.Context, in *GetUsageLimitPolicyStatusRequest, opts ...grpc.CallOption) (*GetUsageLimitPolicyStatusResponse, error)
	GetAdvancedAnalyticsEnabled(ctx context.Context, in *GetAdvancedAnalyticsEnabledRequest, opts ...grpc.CallOption) (*GetAdvancedAnalyticsEnabledResponse, error)
	GetTokenUsage(ctx context.Context, in *GetTokenUsageRequest, opts ...grpc.CallOption) (*GetTokenUsageResponse, error)
	ValidateBedrockIamRole(ctx context.Context, in *ValidateBedrockIamRoleRequest, opts ...grpc.CallOption) (*ValidateBedrockIamRoleResponse, error)
	AddUserToEarlyAccessList(ctx context.Context, in *AddUserToEarlyAccessListRequest, opts ...grpc.CallOption) (*AddUserToEarlyAccessListResponse, error)
	GetTeamSpend(ctx context.Context, in *GetTeamSpendRequest, opts ...grpc.CallOption) (*GetTeamSpendResponse, error)
	GetCurrentBillingCycle(ctx context.Context, in *GetCurrentBillingCycleRequest, opts ...grpc.CallOption) (*GetCurrentBillingCycleResponse, error)
	GetMonthlyBillingCycle(ctx context.Context, in *GetMonthlyBillingCycleRequest, opts ...grpc.CallOption) (*GetMonthlyBillingCycleResponse, error)
	GetBugbotSettings(ctx context.Context, in *GetBugbotSettingsRequest, opts ...grpc.CallOption) (*GetBugbotSettingsResponse, error)
	GetBugbotAnalyticsV2(ctx context.Context, in *GetBugbotAnalyticsV2Request, opts ...grpc.CallOption) (*GetBugbotAnalyticsV2Response, error)
	GetBugBotPRAnalytics(ctx context.Context, in *GetBugBotPRAnalyticsRequest, opts ...grpc.CallOption) (*GetBugBotPRAnalyticsResponse, error)
	GetGithubInstallations(ctx context.Context, in *GetGithubInstallationsRequest, opts ...grpc.CallOption) (*GetGithubInstallationsResponse, error)
	GetInstallationRepos(ctx context.Context, in *GetInstallationReposRequest, opts ...grpc.CallOption) (*GetInstallationReposResponse, error)
	FetchAllInstallationRepos(ctx context.Context, in *FetchAllInstallationReposRequest, opts ...grpc.CallOption) (*FetchAllInstallationReposResponse, error)
	GetInstallationGithubUsers(ctx context.Context, in *GetInstallationGithubUsersRequest, opts ...grpc.CallOption) (*GetInstallationGithubUsersResponse, error)
	GetTeamGithubUsers(ctx context.Context, in *GetTeamGithubUsersRequest, opts ...grpc.CallOption) (*GetTeamGithubUsersResponse, error)
	AddGithubUsersToTeam(ctx context.Context, in *AddGithubUsersToTeamRequest, opts ...grpc.CallOption) (*AddGithubUsersToTeamResponse, error)
	GetUserPullRequests(ctx context.Context, in *GetUserPullRequestsRequest, opts ...grpc.CallOption) (*GetUserPullRequestsResponse, error)
	GetUserReviewRequests(ctx context.Context, in *GetUserReviewRequestsRequest, opts ...grpc.CallOption) (*GetUserReviewRequestsResponse, error)
	UpdateGithubRepoSettings(ctx context.Context, in *UpdateGithubRepoSettingsRequest, opts ...grpc.CallOption) (*UpdateGithubRepoSettingsResponse, error)
	UpdateGithubInstallationSettings(ctx context.Context, in *UpdateGithubInstallationSettingsRequest, opts ...grpc.CallOption) (*UpdateGithubInstallationSettingsResponse, error)
	UpdateAllGithubRepoSettings(ctx context.Context, in *UpdateAllGithubRepoSettingsRequest, opts ...grpc.CallOption) (*UpdateAllGithubRepoSettingsResponse, error)
	UpdateGithubInstallationTeamScope(ctx context.Context, in *UpdateGithubInstallationTeamScopeRequest, opts ...grpc.CallOption) (*UpdateGithubInstallationTeamScopeResponse, error)
	UpdateSelfGithubAllowlist(ctx context.Context, in *UpdateSelfGithubAllowlistRequest, opts ...grpc.CallOption) (*UpdateSelfGithubAllowlistResponse, error)
	GetTeamBugbotSettings(ctx context.Context, in *GetTeamBugbotSettingsRequest, opts ...grpc.CallOption) (*GetTeamBugbotSettingsResponse, error)
	UpdateTeamBugbotSettings(ctx context.Context, in *UpdateTeamBugbotSettingsRequest, opts ...grpc.CallOption) (*UpdateTeamBugbotSettingsResponse, error)
	GetBugbotUserSettings(ctx context.Context, in *GetBugbotUserSettingsRequest, opts ...grpc.CallOption) (*GetBugbotUserSettingsResponse, error)
	UpdateBugbotUserSettings(ctx context.Context, in *UpdateBugbotUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBugbotUserSettingsResponse, error)
	GetBugBotProUserSettings(ctx context.Context, in *GetBugBotProUserSettingsRequest, opts ...grpc.CallOption) (*GetBugBotProUserSettingsResponse, error)
	UpdateBugBotProUserSettings(ctx context.Context, in *UpdateBugBotProUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBugBotProUserSettingsResponse, error)
	RecordBugbotDeeplinkEvent(ctx context.Context, in *RecordBugbotDeeplinkEventRequest, opts ...grpc.CallOption) (*RecordBugbotDeeplinkEventResponse, error)
	RecordBugbotDeeplinkEventUnauthenticated(ctx context.Context, in *RecordBugbotDeeplinkEventRequest, opts ...grpc.CallOption) (*RecordBugbotDeeplinkEventResponse, error)
	RevokeBugBotLicenses(ctx context.Context, in *RevokeBugBotLicensesRequest, opts ...grpc.CallOption) (*RevokeBugBotLicensesResponse, error)
	RevokeUserBugbotLicense(ctx context.Context, in *RevokeUserBugbotLicenseRequest, opts ...grpc.CallOption) (*RevokeUserBugbotLicenseResponse, error)
	StartBugbotBackfillLearning(ctx context.Context, in *StartBugbotBackfillLearningRequest, opts ...grpc.CallOption) (*StartBugbotBackfillLearningResponse, error)
	SetSlackAuth(ctx context.Context, in *SetSlackAuthRequest, opts ...grpc.CallOption) (*SetSlackAuthResponse, error)
	GetSlackTeamSettings(ctx context.Context, in *GetSlackTeamSettingsRequest, opts ...grpc.CallOption) (*GetSlackTeamSettingsResponse, error)
	UpdateSlackTeamSettings(ctx context.Context, in *UpdateSlackTeamSettingsRequest, opts ...grpc.CallOption) (*UpdateSlackTeamSettingsResponse, error)
	GetSlackSettings(ctx context.Context, in *GetSlackSettingsRequest, opts ...grpc.CallOption) (*GetSlackSettingsResponse, error)
	GetSlackModelOptions(ctx context.Context, in *GetSlackModelOptionsRequest, opts ...grpc.CallOption) (*GetSlackModelOptionsResponse, error)
	GetSlackInstallUrl(ctx context.Context, in *GetSlackInstallUrlRequest, opts ...grpc.CallOption) (*GetSlackInstallUrlResponse, error)
	GetSlackInstallUrlPublic(ctx context.Context, in *GetPublicSlackInstallUrlRequest, opts ...grpc.CallOption) (*GetPublicSlackInstallUrlResponse, error)
	GetFilteredUsageEvents(ctx context.Context, in *GetFilteredUsageEventsRequest, opts ...grpc.CallOption) (*GetFilteredUsageEventsResponse, error)
	GetAggregatedUsageEvents(ctx context.Context, in *GetAggregatedUsageEventsRequest, opts ...grpc.CallOption) (*GetAggregatedUsageEventsResponse, error)
	GetAuditLogs(ctx context.Context, in *GetAuditLogsRequest, opts ...grpc.CallOption) (*GetAuditLogsResponse, error)
	GetUserPrivacyMode(ctx context.Context, in *GetUserPrivacyModeRequest, opts ...grpc.CallOption) (*GetUserPrivacyModeResponse, error)
	SetUserPrivacyMode(ctx context.Context, in *SetUserPrivacyModeRequest, opts ...grpc.CallOption) (*SetUserPrivacyModeResponse, error)
	WebAcknowledgeGracePeriodDisclaimer(ctx context.Context, in *WebAcknowledgeGracePeriodDisclaimerRequest, opts ...grpc.CallOption) (*WebAcknowledgeGracePeriodDisclaimerResponse, error)
	SkipPrivacyModeGracePeriod(ctx context.Context, in *SkipPrivacyModeGracePeriodRequest, opts ...grpc.CallOption) (*SkipPrivacyModeGracePeriodResponse, error)
	NeedsPrivacyModeMigration(ctx context.Context, in *NeedsPrivacyModeMigrationRequest, opts ...grpc.CallOption) (*NeedsPrivacyModeMigrationResponse, error)
	UpdateTeamPrivacyModeMigrationOptOut(ctx context.Context, in *UpdateTeamPrivacyModeMigrationOptOutRequest, opts ...grpc.CallOption) (*UpdateTeamPrivacyModeMigrationOptOutResponse, error)
	ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ShareConversationResponse, error)
	GetSharedConversation(ctx context.Context, in *GetSharedConversationRequest, opts ...grpc.CallOption) (*GetSharedConversationResponse, error)
	GetPublicSharedConversation(ctx context.Context, in *GetPublicSharedConversationRequest, opts ...grpc.CallOption) (*GetPublicSharedConversationResponse, error)
	ListSharedConversations(ctx context.Context, in *ListSharedConversationsRequest, opts ...grpc.CallOption) (*ListSharedConversationsResponse, error)
	DeleteSharedConversation(ctx context.Context, in *DeleteSharedConversationRequest, opts ...grpc.CallOption) (*DeleteSharedConversationResponse, error)
	UpdateSharedConversationVisibility(ctx context.Context, in *UpdateSharedConversationVisibilityRequest, opts ...grpc.CallOption) (*UpdateSharedConversationVisibilityResponse, error)
	RevokeTeamInviteLink(ctx context.Context, in *RevokeTeamInviteLinkRequest, opts ...grpc.CallOption) (*RevokeTeamInviteLinkResponse, error)
	ListTeamInviteLinks(ctx context.Context, in *ListTeamInviteLinksRequest, opts ...grpc.CallOption) (*ListTeamInviteLinksResponse, error)
	UpdateUserName(ctx context.Context, in *UpdateUserNameRequest, opts ...grpc.CallOption) (*UpdateUserNameResponse, error)
	ListInvoices(ctx context.Context, in *ListInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error)
	IsEligibleForRefund(ctx context.Context, in *IsEligibleForRefundRequest, opts ...grpc.CallOption) (*IsEligibleForRefundResponse, error)
	GetRemainingRefunds(ctx context.Context, in *GetRemainingRefundsRequest, opts ...grpc.CallOption) (*GetRemainingRefundsResponse, error)
	GetServiceAccountSpendLimit(ctx context.Context, in *GetServiceAccountSpendLimitRequest, opts ...grpc.CallOption) (*GetServiceAccountSpendLimitResponse, error)
	SetServiceAccountSpendLimit(ctx context.Context, in *SetServiceAccountSpendLimitRequest, opts ...grpc.CallOption) (*SetServiceAccountSpendLimitResponse, error)
	SetUserHardLimit(ctx context.Context, in *SetUserHardLimitRequest, opts ...grpc.CallOption) (*SetUserHardLimitResponse, error)
	SetUserMonthlyLimit(ctx context.Context, in *SetUserMonthlyLimitRequest, opts ...grpc.CallOption) (*SetUserMonthlyLimitResponse, error)
	ToggleMarketingEmailOpt(ctx context.Context, in *ToggleMarketingEmailOptRequest, opts ...grpc.CallOption) (*ToggleMarketingEmailOptResponse, error)
	GetMarketingEmailOpt(ctx context.Context, in *GetMarketingEmailOptRequest, opts ...grpc.CallOption) (*GetMarketingEmailOptResponse, error)
	GetGlobalLeaderboardOptIn(ctx context.Context, in *GetGlobalLeaderboardOptInRequest, opts ...grpc.CallOption) (*GetGlobalLeaderboardOptInResponse, error)
	SetGlobalLeaderboardOptIn(ctx context.Context, in *SetGlobalLeaderboardOptInRequest, opts ...grpc.CallOption) (*SetGlobalLeaderboardOptInResponse, error)
	CreateTeamApiKey(ctx context.Context, in *CreateTeamApiKeyRequest, opts ...grpc.CallOption) (*CreateTeamApiKeyResponse, error)
	RevokeTeamApiKey(ctx context.Context, in *RevokeTeamApiKeyRequest, opts ...grpc.CallOption) (*RevokeTeamApiKeyResponse, error)
	ListTeamApiKeys(ctx context.Context, in *ListTeamApiKeysRequest, opts ...grpc.CallOption) (*ListTeamApiKeysResponse, error)
	CreateTeamServiceAccount(ctx context.Context, in *CreateTeamServiceAccountRequest, opts ...grpc.CallOption) (*CreateTeamServiceAccountResponse, error)
	ListTeamServiceAccounts(ctx context.Context, in *ListTeamServiceAccountsRequest, opts ...grpc.CallOption) (*ListTeamServiceAccountsResponse, error)
	DeleteTeamServiceAccount(ctx context.Context, in *DeleteTeamServiceAccountRequest, opts ...grpc.CallOption) (*DeleteTeamServiceAccountResponse, error)
	ArchiveTeamServiceAccount(ctx context.Context, in *ArchiveTeamServiceAccountRequest, opts ...grpc.CallOption) (*ArchiveTeamServiceAccountResponse, error)
	RotateServiceAccountApiKey(ctx context.Context, in *RotateServiceAccountApiKeyRequest, opts ...grpc.CallOption) (*RotateServiceAccountApiKeyResponse, error)
	GetTeamRepositoriesForServiceAccountScope(ctx context.Context, in *GetTeamRepositoriesForServiceAccountScopeRequest, opts ...grpc.CallOption) (*GetTeamRepositoriesForServiceAccountScopeResponse, error)
	UpdateServiceAccountRepoScope(ctx context.Context, in *UpdateServiceAccountRepoScopeRequest, opts ...grpc.CallOption) (*UpdateServiceAccountRepoScopeResponse, error)
	CreateUserApiKey(ctx context.Context, in *CreateUserApiKeyRequest, opts ...grpc.CallOption) (*CreateUserApiKeyResponse, error)
	RevokeUserApiKey(ctx context.Context, in *RevokeUserApiKeyRequest, opts ...grpc.CallOption) (*RevokeUserApiKeyResponse, error)
	ListUserApiKeys(ctx context.Context, in *ListUserApiKeysRequest, opts ...grpc.CallOption) (*ListUserApiKeysResponse, error)
	ConfirmGithubInstallation(ctx context.Context, in *ConfirmGithubInstallationRequest, opts ...grpc.CallOption) (*ConfirmGithubInstallationResponse, error)
	UpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest, opts ...grpc.CallOption) (*UpdateTeamNameResponse, error)
	UpdateTeamDashboardAnalyticsSetting(ctx context.Context, in *UpdateTeamDashboardAnalyticsSettingRequest, opts ...grpc.CallOption) (*UpdateTeamDashboardAnalyticsSettingResponse, error)
	GetSlackUserSettings(ctx context.Context, in *GetSlackUserSettingsRequest, opts ...grpc.CallOption) (*GetSlackUserSettingsResponse, error)
	UpdateSlackUserSettings(ctx context.Context, in *UpdateSlackUserSettingsRequest, opts ...grpc.CallOption) (*UpdateSlackUserSettingsResponse, error)
	GetSlackRepoRoutingRules(ctx context.Context, in *GetSlackRepoRoutingRulesRequest, opts ...grpc.CallOption) (*GetSlackRepoRoutingRulesResponse, error)
	CreateSlackRepoRoutingRule(ctx context.Context, in *CreateSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*CreateSlackRepoRoutingRuleResponse, error)
	UpdateSlackRepoRoutingRule(ctx context.Context, in *UpdateSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*UpdateSlackRepoRoutingRuleResponse, error)
	DeleteSlackRepoRoutingRule(ctx context.Context, in *DeleteSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*DeleteSlackRepoRoutingRuleResponse, error)
	IsOnNewPricing(ctx context.Context, in *IsOnNewPricingRequest, opts ...grpc.CallOption) (*IsOnNewPricingResponse, error)
	GetLinearAuthUrl(ctx context.Context, in *GetLinearAuthUrlRequest, opts ...grpc.CallOption) (*GetLinearAuthUrlResponse, error)
	GetLinearStatus(ctx context.Context, in *GetLinearStatusRequest, opts ...grpc.CallOption) (*GetLinearStatusResponse, error)
	DisconnectLinear(ctx context.Context, in *DisconnectLinearRequest, opts ...grpc.CallOption) (*DisconnectLinearResponse, error)
	GetLinearTeams(ctx context.Context, in *GetLinearTeamsRequest, opts ...grpc.CallOption) (*GetLinearTeamsResponse, error)
	GetLinearSettings(ctx context.Context, in *GetLinearSettingsRequest, opts ...grpc.CallOption) (*GetLinearSettingsResponse, error)
	UpdateLinearTeamSetting(ctx context.Context, in *UpdateLinearTeamSettingRequest, opts ...grpc.CallOption) (*UpdateLinearTeamSettingResponse, error)
	UpdateLinearProjectSetting(ctx context.Context, in *UpdateLinearProjectSettingRequest, opts ...grpc.CallOption) (*UpdateLinearProjectSettingResponse, error)
	GetLinearLabels(ctx context.Context, in *GetLinearLabelsRequest, opts ...grpc.CallOption) (*GetLinearLabelsResponse, error)
	GetLinearIssues(ctx context.Context, in *GetLinearIssuesRequest, opts ...grpc.CallOption) (*GetLinearIssuesResponse, error)
	DeleteBedrockIamRole(ctx context.Context, in *DeleteBedrockIamRoleRequest, opts ...grpc.CallOption) (*DeleteBedrockIamRoleResponse, error)
	UnlinkSlackAccess(ctx context.Context, in *UnlinkSlackAccessRequest, opts ...grpc.CallOption) (*UnlinkSlackAccessResponse, error)
	ListSlackConversations(ctx context.Context, in *ListSlackConversationsRequest, opts ...grpc.CallOption) (*ListSlackConversationsResponse, error)
	LogSlackbotAuthConversionFunnel(ctx context.Context, in *LogSlackbotAuthConversionFunnelRequest, opts ...grpc.CallOption) (*LogSlackbotAuthConversionFunnelResponse, error)
	LogClickedConnectSlack(ctx context.Context, in *LogClickedConnectSlackRequest, opts ...grpc.CallOption) (*LogClickedConnectSlackResponse, error)
	CheckUserApiKeyAccess(ctx context.Context, in *CheckUserApiKeyAccessRequest, opts ...grpc.CallOption) (*CheckUserApiKeyAccessResponse, error)
	IsAllowedFreeTrialUsage(ctx context.Context, in *IsAllowedFreeTrialUsageRequest, opts ...grpc.CallOption) (*IsAllowedFreeTrialUsageResponse, error)
	CompletedLinkSlackAccount(ctx context.Context, in *CompletedLinkSlackAccountRequest, opts ...grpc.CallOption) (*CompletedLinkSlackAccountResponse, error)
	NotifyTeamAdmins(ctx context.Context, in *NotifyTeamAdminsRequest, opts ...grpc.CallOption) (*NotifyTeamAdminsResponse, error)
	GetAdminNotificationStatus(ctx context.Context, in *GetAdminNotificationStatusRequest, opts ...grpc.CallOption) (*GetAdminNotificationStatusResponse, error)
	OptOutNewPricing(ctx context.Context, in *OptOutNewPricingRequest, opts ...grpc.CallOption) (*OptOutNewPricingResponse, error)
	SubmitFeedback(ctx context.Context, in *SubmitFeedbackRequest, opts ...grpc.CallOption) (*SubmitFeedbackResponse, error)
	CanStudentReverify(ctx context.Context, in *CanStudentReverifyRequest, opts ...grpc.CallOption) (*CanStudentReverifyResponse, error)
	ClientAction(ctx context.Context, in *ClientActionRequest, opts ...grpc.CallOption) (*ClientActionResponse, error)
	ListUsageAlerts(ctx context.Context, in *ListUsageAlertsRequest, opts ...grpc.CallOption) (*ListUsageAlertsResponse, error)
	CreateUsageAlerts(ctx context.Context, in *CreateUsageAlertsRequest, opts ...grpc.CallOption) (*CreateUsageAlertsResponse, error)
	DeleteUsageAlerts(ctx context.Context, in *DeleteUsageAlertsRequest, opts ...grpc.CallOption) (*DeleteUsageAlertsResponse, error)
	UpdateUsageAlerts(ctx context.Context, in *UpdateUsageAlertsRequest, opts ...grpc.CallOption) (*UpdateUsageAlertsResponse, error)
	RequestIndividualLimitsOptOut(ctx context.Context, in *RequestIndividualLimitsOptOutRequest, opts ...grpc.CallOption) (*RequestIndividualLimitsOptOutResponse, error)
}

type dashboardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDashboardServiceClient(cc grpc.ClientConnInterface) DashboardServiceClient {
	return &dashboardServiceClient{cc}
}

func (c *dashboardServiceClient) GetTeams(ctx context.Context, in *GetTeamsRequest, opts ...grpc.CallOption) (*GetTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*GetMeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMeResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetDirectoryGroups(ctx context.Context, in *GetDirectoryGroupsRequest, opts ...grpc.CallOption) (*GetDirectoryGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDirectoryGroupsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetDirectoryGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateDirectoryGroupSettings(ctx context.Context, in *UpdateDirectoryGroupSettingsRequest, opts ...grpc.CallOption) (*UpdateDirectoryGroupSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDirectoryGroupSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateDirectoryGroupSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetGroups(ctx context.Context, in *GetGroupsRequest, opts ...grpc.CallOption) (*GetGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetGroupMembers(ctx context.Context, in *GetGroupMembersRequest, opts ...grpc.CallOption) (*GetGroupMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupMembersResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetGroupMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGroupResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*DeleteGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGroupResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) AddGroupMembers(ctx context.Context, in *AddGroupMembersRequest, opts ...grpc.CallOption) (*AddGroupMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGroupMembersResponse)
	err := c.cc.Invoke(ctx, DashboardService_AddGroupMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RemoveGroupMembers(ctx context.Context, in *RemoveGroupMembersRequest, opts ...grpc.CallOption) (*RemoveGroupMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveGroupMembersResponse)
	err := c.cc.Invoke(ctx, DashboardService_RemoveGroupMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) BulkAssignGroupMembers(ctx context.Context, in *BulkAssignGroupMembersRequest, opts ...grpc.CallOption) (*BulkAssignGroupMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BulkAssignGroupMembersResponse)
	err := c.cc.Invoke(ctx, DashboardService_BulkAssignGroupMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) PreviewAttachGroupToDirectory(ctx context.Context, in *PreviewAttachGroupToDirectoryRequest, opts ...grpc.CallOption) (*PreviewAttachGroupToDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PreviewAttachGroupToDirectoryResponse)
	err := c.cc.Invoke(ctx, DashboardService_PreviewAttachGroupToDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DetachGroupFromDirectory(ctx context.Context, in *DetachGroupFromDirectoryRequest, opts ...grpc.CallOption) (*DetachGroupFromDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetachGroupFromDirectoryResponse)
	err := c.cc.Invoke(ctx, DashboardService_DetachGroupFromDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetScimConflicts(ctx context.Context, in *GetScimConflictsRequest, opts ...grpc.CallOption) (*GetScimConflictsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScimConflictsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetScimConflicts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetActivationCheckoutUrl(ctx context.Context, in *GetActivationCheckoutUrlRequest, opts ...grpc.CallOption) (*GetActivationCheckoutUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActivationCheckoutUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetActivationCheckoutUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamCustomerPortalUrl(ctx context.Context, in *GetTeamCustomerPortalUrlRequest, opts ...grpc.CallOption) (*GetTeamCustomerPortalUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamCustomerPortalUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamCustomerPortalUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamMembers(ctx context.Context, in *GetTeamMembersRequest, opts ...grpc.CallOption) (*GetTeamMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamMembersResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SendTeamInvite(ctx context.Context, in *SendTeamInviteRequest, opts ...grpc.CallOption) (*SendTeamInviteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendTeamInviteResponse)
	err := c.cc.Invoke(ctx, DashboardService_SendTeamInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamInviteLink(ctx context.Context, in *GetTeamInviteLinkRequest, opts ...grpc.CallOption) (*GetTeamInviteLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamInviteLinkResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) AcceptInvite(ctx context.Context, in *AcceptInviteRequest, opts ...grpc.CallOption) (*AcceptInviteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptInviteResponse)
	err := c.cc.Invoke(ctx, DashboardService_AcceptInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*CreateTeamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetJoinableTeamsByDomain(ctx context.Context, in *GetJoinableTeamsByDomainRequest, opts ...grpc.CallOption) (*GetJoinableTeamsByDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJoinableTeamsByDomainResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetJoinableTeamsByDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) JoinTeamByDomain(ctx context.Context, in *JoinTeamByDomainRequest, opts ...grpc.CallOption) (*JoinTeamByDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinTeamByDomainResponse)
	err := c.cc.Invoke(ctx, DashboardService_JoinTeamByDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamDomainJoinSetting(ctx context.Context, in *UpdateTeamDomainJoinSettingRequest, opts ...grpc.CallOption) (*UpdateTeamDomainJoinSettingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamDomainJoinSettingResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamDomainJoinSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamMemberDomains(ctx context.Context, in *GetTeamMemberDomainsRequest, opts ...grpc.CallOption) (*GetTeamMemberDomainsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamMemberDomainsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamMemberDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamIdForReactivation(ctx context.Context, in *GetTeamIdForReactivationRequest, opts ...grpc.CallOption) (*GetTeamIdForReactivationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamIdForReactivationResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamIdForReactivation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ChangeSeat(ctx context.Context, in *ChangeSeatRequest, opts ...grpc.CallOption) (*ChangeSeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeSeatResponse)
	err := c.cc.Invoke(ctx, DashboardService_ChangeSeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ChangeTeamSubscription(ctx context.Context, in *ChangeTeamSubscriptionRequest, opts ...grpc.CallOption) (*ChangeTeamSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeTeamSubscriptionResponse)
	err := c.cc.Invoke(ctx, DashboardService_ChangeTeamSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ConnectGithubCallback(ctx context.Context, in *ConnectGithubCallbackRequest, opts ...grpc.CallOption) (*ConnectGithubCallbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectGithubCallbackResponse)
	err := c.cc.Invoke(ctx, DashboardService_ConnectGithubCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RegisterGithubCursorCode(ctx context.Context, in *RegisterGithubCursorCodeRequest, opts ...grpc.CallOption) (*RegisterGithubCursorCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterGithubCursorCodeResponse)
	err := c.cc.Invoke(ctx, DashboardService_RegisterGithubCursorCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DisconnectGithub(ctx context.Context, in *DisconnectGithubRequest, opts ...grpc.CallOption) (*DisconnectGithubResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectGithubResponse)
	err := c.cc.Invoke(ctx, DashboardService_DisconnectGithub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) PrepareSetupGithubEnterpriseApp(ctx context.Context, in *PrepareSetupGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*PrepareSetupGithubEnterpriseAppResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareSetupGithubEnterpriseAppResponse)
	err := c.cc.Invoke(ctx, DashboardService_PrepareSetupGithubEnterpriseApp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) FinishSetupGithubEnterpriseApp(ctx context.Context, in *FinishSetupGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*FinishSetupGithubEnterpriseAppResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishSetupGithubEnterpriseAppResponse)
	err := c.cc.Invoke(ctx, DashboardService_FinishSetupGithubEnterpriseApp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListGithubEnterpriseApps(ctx context.Context, in *ListGithubEnterpriseAppsRequest, opts ...grpc.CallOption) (*ListGithubEnterpriseAppsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGithubEnterpriseAppsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListGithubEnterpriseApps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteGithubEnterpriseApp(ctx context.Context, in *DeleteGithubEnterpriseAppRequest, opts ...grpc.CallOption) (*DeleteGithubEnterpriseAppResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGithubEnterpriseAppResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteGithubEnterpriseApp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetupGitlabEnterpriseInstance(ctx context.Context, in *SetupGitlabEnterpriseInstanceRequest, opts ...grpc.CallOption) (*SetupGitlabEnterpriseInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupGitlabEnterpriseInstanceResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetupGitlabEnterpriseInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListGitlabEnterpriseInstances(ctx context.Context, in *ListGitlabEnterpriseInstancesRequest, opts ...grpc.CallOption) (*ListGitlabEnterpriseInstancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGitlabEnterpriseInstancesResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListGitlabEnterpriseInstances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteGitlabEnterpriseInstance(ctx context.Context, in *DeleteGitlabEnterpriseInstanceRequest, opts ...grpc.CallOption) (*DeleteGitlabEnterpriseInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGitlabEnterpriseInstanceResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteGitlabEnterpriseInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SyncGitlabRepos(ctx context.Context, in *SyncGitlabReposRequest, opts ...grpc.CallOption) (*SyncGitlabReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncGitlabReposResponse)
	err := c.cc.Invoke(ctx, DashboardService_SyncGitlabRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*UpdateRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRoleResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveMemberResponse)
	err := c.cc.Invoke(ctx, DashboardService_RemoveMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamUsage(ctx context.Context, in *GetTeamUsageRequest, opts ...grpc.CallOption) (*GetTeamUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamUsageResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSignUpType(ctx context.Context, in *GetSignUpTypeRequest, opts ...grpc.CallOption) (*GetSignUpTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSignUpTypeResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSignUpType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetHardLimit(ctx context.Context, in *GetHardLimitRequest, opts ...grpc.CallOption) (*GetHardLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHardLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetHardLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetHardLimit(ctx context.Context, in *SetHardLimitRequest, opts ...grpc.CallOption) (*SetHardLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetHardLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetHardLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) EnableOnDemandSpend(ctx context.Context, in *EnableOnDemandSpendRequest, opts ...grpc.CallOption) (*EnableOnDemandSpendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableOnDemandSpendResponse)
	err := c.cc.Invoke(ctx, DashboardService_EnableOnDemandSpend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*DeleteAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAccountResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SendDownloadEmail(ctx context.Context, in *SendDownloadEmailRequest, opts ...grpc.CallOption) (*SendDownloadEmailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendDownloadEmailResponse)
	err := c.cc.Invoke(ctx, DashboardService_SendDownloadEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMonthlyInvoice(ctx context.Context, in *GetMonthlyInvoiceRequest, opts ...grpc.CallOption) (*GetMonthlyInvoiceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMonthlyInvoiceResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMonthlyInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListInvoiceCycles(ctx context.Context, in *ListInvoiceCyclesRequest, opts ...grpc.CallOption) (*ListInvoiceCyclesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInvoiceCyclesResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListInvoiceCycles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetDailySpendByCategory(ctx context.Context, in *GetDailySpendByCategoryRequest, opts ...grpc.CallOption) (*GetDailySpendByCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDailySpendByCategoryResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetDailySpendByCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetPricingHistory(ctx context.Context, in *GetPricingHistoryRequest, opts ...grpc.CallOption) (*GetPricingHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPricingHistoryResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetPricingHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListBackgroundComposerSecrets(ctx context.Context, in *ListBackgroundComposerSecretsRequest, opts ...grpc.CallOption) (*ListBackgroundComposerSecretsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackgroundComposerSecretsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListBackgroundComposerSecrets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateBackgroundComposerSecret(ctx context.Context, in *CreateBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*CreateBackgroundComposerSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBackgroundComposerSecretResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateBackgroundComposerSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeBackgroundComposerSecret(ctx context.Context, in *RevokeBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*RevokeBackgroundComposerSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeBackgroundComposerSecretResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeBackgroundComposerSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateBackgroundComposerSecret(ctx context.Context, in *UpdateBackgroundComposerSecretRequest, opts ...grpc.CallOption) (*UpdateBackgroundComposerSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBackgroundComposerSecretResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateBackgroundComposerSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMcpConfig(ctx context.Context, in *GetMcpConfigRequest, opts ...grpc.CallOption) (*GetMcpConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMcpConfigResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMcpConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAvailableMcpServers(ctx context.Context, in *GetAvailableMcpServersRequest, opts ...grpc.CallOption) (*GetAvailableMcpServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAvailableMcpServersResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAvailableMcpServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetMcpConfig(ctx context.Context, in *SetMcpConfigRequest, opts ...grpc.CallOption) (*SetMcpConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMcpConfigResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetMcpConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateUserDefaultMcpSettings(ctx context.Context, in *UpdateUserDefaultMcpSettingsRequest, opts ...grpc.CallOption) (*UpdateUserDefaultMcpSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserDefaultMcpSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateUserDefaultMcpSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) StoreMcpOAuthToken(ctx context.Context, in *StoreMcpOAuthTokenRequest, opts ...grpc.CallOption) (*StoreMcpOAuthTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreMcpOAuthTokenResponse)
	err := c.cc.Invoke(ctx, DashboardService_StoreMcpOAuthToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ValidateMcpOAuthTokens(ctx context.Context, in *ValidateMcpOAuthTokensRequest, opts ...grpc.CallOption) (*ValidateMcpOAuthTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateMcpOAuthTokensResponse)
	err := c.cc.Invoke(ctx, DashboardService_ValidateMcpOAuthTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) StoreMcpOAuthPendingState(ctx context.Context, in *StoreMcpOAuthPendingStateRequest, opts ...grpc.CallOption) (*StoreMcpOAuthPendingStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreMcpOAuthPendingStateResponse)
	err := c.cc.Invoke(ctx, DashboardService_StoreMcpOAuthPendingState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMcpOAuthPendingState(ctx context.Context, in *GetMcpOAuthPendingStateRequest, opts ...grpc.CallOption) (*GetMcpOAuthPendingStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMcpOAuthPendingStateResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMcpOAuthPendingState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamWithFreeTrial(ctx context.Context, in *CreateTeamWithFreeTrialRequest, opts ...grpc.CallOption) (*CreateTeamWithFreeTrialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamWithFreeTrialResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamWithFreeTrial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamHasValidPaymentMethod(ctx context.Context, in *GetTeamHasValidPaymentMethodRequest, opts ...grpc.CallOption) (*GetTeamHasValidPaymentMethodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamHasValidPaymentMethodResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamHasValidPaymentMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamPrivacyModeForced(ctx context.Context, in *GetTeamPrivacyModeForcedRequest, opts ...grpc.CallOption) (*GetTeamPrivacyModeForcedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamPrivacyModeForcedResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamPrivacyModeForced_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SwitchTeamPrivacyMode(ctx context.Context, in *SwitchTeamPrivacyModeRequest, opts ...grpc.CallOption) (*SwitchTeamPrivacyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchTeamPrivacyModeResponse)
	err := c.cc.Invoke(ctx, DashboardService_SwitchTeamPrivacyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateFastRequests(ctx context.Context, in *UpdateFastRequestsRequest, opts ...grpc.CallOption) (*UpdateFastRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateFastRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateFastRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetFastRequests(ctx context.Context, in *GetFastRequestsRequest, opts ...grpc.CallOption) (*GetFastRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFastRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetFastRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetDownloadLink(ctx context.Context, in *GetDownloadLinkRequest, opts ...grpc.CallOption) (*GetDownloadLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDownloadLinkResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetDownloadLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetCliDownloadUrl(ctx context.Context, in *GetCliDownloadUrlRequest, opts ...grpc.CallOption) (*GetCliDownloadUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCliDownloadUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetCliDownloadUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSsoConfigurationLinks(ctx context.Context, in *GetSsoConfigurationLinksRequest, opts ...grpc.CallOption) (*GetSsoConfigurationLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSsoConfigurationLinksResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSsoConfigurationLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetScimConfigurationLinks(ctx context.Context, in *GetScimConfigurationLinksRequest, opts ...grpc.CallOption) (*GetScimConfigurationLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScimConfigurationLinksResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetScimConfigurationLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetAdminOnlyUsagePricing(ctx context.Context, in *SetAdminOnlyUsagePricingRequest, opts ...grpc.CallOption) (*SetAdminOnlyUsagePricingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAdminOnlyUsagePricingResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetAdminOnlyUsagePricing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetYearlyUpgradeEligibility(ctx context.Context, in *GetYearlyUpgradeEligibilityRequest, opts ...grpc.CallOption) (*GetYearlyUpgradeEligibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetYearlyUpgradeEligibilityResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetYearlyUpgradeEligibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpgradeToYearly(ctx context.Context, in *UpgradeToYearlyRequest, opts ...grpc.CallOption) (*UpgradeToYearlyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpgradeToYearlyResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpgradeToYearly_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetEnterpriseCTAEligibility(ctx context.Context, in *GetEnterpriseCTAEligibilityRequest, opts ...grpc.CallOption) (*GetEnterpriseCTAEligibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEnterpriseCTAEligibilityResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetEnterpriseCTAEligibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUsageBasedPremiumRequests(ctx context.Context, in *GetUsageBasedPremiumRequestsRequest, opts ...grpc.CallOption) (*GetUsageBasedPremiumRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsageBasedPremiumRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUsageBasedPremiumRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetUsageBasedPremiumRequests(ctx context.Context, in *SetUsageBasedPremiumRequestsRequest, opts ...grpc.CallOption) (*SetUsageBasedPremiumRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUsageBasedPremiumRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetUsageBasedPremiumRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetReferrals(ctx context.Context, in *GetReferralsRequest, opts ...grpc.CallOption) (*GetReferralsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReferralsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetReferrals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CheckReferralCode(ctx context.Context, in *CheckReferralCodeRequest, opts ...grpc.CallOption) (*CheckReferralCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckReferralCodeResponse)
	err := c.cc.Invoke(ctx, DashboardService_CheckReferralCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RedeemGiftCode(ctx context.Context, in *RedeemGiftCodeRequest, opts ...grpc.CallOption) (*RedeemGiftCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RedeemGiftCodeResponse)
	err := c.cc.Invoke(ctx, DashboardService_RedeemGiftCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamRepos(ctx context.Context, in *GetTeamReposRequest, opts ...grpc.CallOption) (*GetTeamReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamReposResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamReposOrEmptyIfNotInTeam(ctx context.Context, in *GetTeamReposRequest, opts ...grpc.CallOption) (*GetTeamReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamReposResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamReposOrEmptyIfNotInTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamRules(ctx context.Context, in *GetTeamRulesRequest, opts ...grpc.CallOption) (*GetTeamRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamRulesResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamRule(ctx context.Context, in *CreateTeamRuleRequest, opts ...grpc.CallOption) (*CreateTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamRule(ctx context.Context, in *UpdateTeamRuleRequest, opts ...grpc.CallOption) (*UpdateTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteTeamRule(ctx context.Context, in *DeleteTeamRuleRequest, opts ...grpc.CallOption) (*DeleteTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamHooks(ctx context.Context, in *GetTeamHooksRequest, opts ...grpc.CallOption) (*GetTeamHooksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamHooksResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamHooks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamHook(ctx context.Context, in *CreateTeamHookRequest, opts ...grpc.CallOption) (*CreateTeamHookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamHookResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamHook(ctx context.Context, in *UpdateTeamHookRequest, opts ...grpc.CallOption) (*UpdateTeamHookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamHookResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteTeamHook(ctx context.Context, in *DeleteTeamHookRequest, opts ...grpc.CallOption) (*DeleteTeamHookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamHookResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteTeamHook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamCommands(ctx context.Context, in *GetTeamCommandsRequest, opts ...grpc.CallOption) (*GetTeamCommandsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamCommandsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamCommands_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamCommand(ctx context.Context, in *CreateTeamCommandRequest, opts ...grpc.CallOption) (*CreateTeamCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamCommandResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamCommand(ctx context.Context, in *UpdateTeamCommandRequest, opts ...grpc.CallOption) (*UpdateTeamCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamCommandResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteTeamCommand(ctx context.Context, in *DeleteTeamCommandRequest, opts ...grpc.CallOption) (*DeleteTeamCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamCommandResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteTeamCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugbotTeamRules(ctx context.Context, in *GetBugbotTeamRulesRequest, opts ...grpc.CallOption) (*GetBugbotTeamRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugbotTeamRulesResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugbotTeamRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateBugbotTeamRule(ctx context.Context, in *CreateBugbotTeamRuleRequest, opts ...grpc.CallOption) (*CreateBugbotTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBugbotTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateBugbotTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateBugbotTeamRule(ctx context.Context, in *UpdateBugbotTeamRuleRequest, opts ...grpc.CallOption) (*UpdateBugbotTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBugbotTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateBugbotTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteBugbotTeamRule(ctx context.Context, in *DeleteBugbotTeamRuleRequest, opts ...grpc.CallOption) (*DeleteBugbotTeamRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBugbotTeamRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteBugbotTeamRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugbotLearnedRules(ctx context.Context, in *GetBugbotLearnedRulesRequest, opts ...grpc.CallOption) (*GetBugbotLearnedRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugbotLearnedRulesResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugbotLearnedRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateBugbotLearnedRule(ctx context.Context, in *UpdateBugbotLearnedRuleRequest, opts ...grpc.CallOption) (*UpdateBugbotLearnedRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBugbotLearnedRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateBugbotLearnedRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteBugbotLearnedRule(ctx context.Context, in *DeleteBugbotLearnedRuleRequest, opts ...grpc.CallOption) (*DeleteBugbotLearnedRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBugbotLearnedRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteBugbotLearnedRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamRepo(ctx context.Context, in *CreateTeamRepoRequest, opts ...grpc.CallOption) (*CreateTeamRepoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamRepoResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamRepo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteTeamRepo(ctx context.Context, in *DeleteTeamRepoRequest, opts ...grpc.CallOption) (*DeleteTeamRepoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamRepoResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteTeamRepo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) AddRepoPattern(ctx context.Context, in *AddRepoPatternRequest, opts ...grpc.CallOption) (*AddRepoPatternResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddRepoPatternResponse)
	err := c.cc.Invoke(ctx, DashboardService_AddRepoPattern_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RemoveRepoPattern(ctx context.Context, in *RemoveRepoPatternRequest, opts ...grpc.CallOption) (*RemoveRepoPatternResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveRepoPatternResponse)
	err := c.cc.Invoke(ctx, DashboardService_RemoveRepoPattern_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetTeamRepoType(ctx context.Context, in *SetTeamRepoTypeRequest, opts ...grpc.CallOption) (*SetTeamRepoTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTeamRepoTypeResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetTeamRepoType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamAdminSettings(ctx context.Context, in *GetTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamAdminSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamAdminSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamAdminSettingsOrEmptyIfNotInTeam(ctx context.Context, in *GetTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamAdminSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamAdminSettingsOrEmptyIfNotInTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBaseTeamAdminSettings(ctx context.Context, in *GetBaseTeamAdminSettingsRequest, opts ...grpc.CallOption) (*GetTeamAdminSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamAdminSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBaseTeamAdminSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamAdminSettings(ctx context.Context, in *UpdateTeamAdminSettingsRequest, opts ...grpc.CallOption) (*UpdateTeamAdminSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamAdminSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamAdminSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamFreeTrialCode(ctx context.Context, in *CreateTeamFreeTrialCodeRequest, opts ...grpc.CallOption) (*CreateTeamFreeTrialCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamFreeTrialCodeResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamFreeTrialCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamAnalytics(ctx context.Context, in *GetTeamAnalyticsRequest, opts ...grpc.CallOption) (*GetTeamAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamAnalyticsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUserAnalytics(ctx context.Context, in *GetUserAnalyticsRequest, opts ...grpc.CallOption) (*GetUserAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserAnalyticsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUserAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamRawData(ctx context.Context, in *GetTeamRawDataRequest, opts ...grpc.CallOption) (*GetTeamRawDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamRawDataResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamRawData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetClientUsageData(ctx context.Context, in *GetClientUsageDataRequest, opts ...grpc.CallOption) (*GetClientUsageDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientUsageDataResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetClientUsageData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetCurrentPeriodUsage(ctx context.Context, in *GetCurrentPeriodUsageRequest, opts ...grpc.CallOption) (*GetCurrentPeriodUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentPeriodUsageResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetCurrentPeriodUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetPlanInfo(ctx context.Context, in *GetPlanInfoRequest, opts ...grpc.CallOption) (*GetPlanInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlanInfoResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetPlanInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUsageLimitPolicyStatus(ctx context.Context, in *GetUsageLimitPolicyStatusRequest, opts ...grpc.CallOption) (*GetUsageLimitPolicyStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsageLimitPolicyStatusResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUsageLimitPolicyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAdvancedAnalyticsEnabled(ctx context.Context, in *GetAdvancedAnalyticsEnabledRequest, opts ...grpc.CallOption) (*GetAdvancedAnalyticsEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAdvancedAnalyticsEnabledResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAdvancedAnalyticsEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTokenUsage(ctx context.Context, in *GetTokenUsageRequest, opts ...grpc.CallOption) (*GetTokenUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTokenUsageResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTokenUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ValidateBedrockIamRole(ctx context.Context, in *ValidateBedrockIamRoleRequest, opts ...grpc.CallOption) (*ValidateBedrockIamRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateBedrockIamRoleResponse)
	err := c.cc.Invoke(ctx, DashboardService_ValidateBedrockIamRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) AddUserToEarlyAccessList(ctx context.Context, in *AddUserToEarlyAccessListRequest, opts ...grpc.CallOption) (*AddUserToEarlyAccessListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddUserToEarlyAccessListResponse)
	err := c.cc.Invoke(ctx, DashboardService_AddUserToEarlyAccessList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamSpend(ctx context.Context, in *GetTeamSpendRequest, opts ...grpc.CallOption) (*GetTeamSpendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamSpendResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamSpend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetCurrentBillingCycle(ctx context.Context, in *GetCurrentBillingCycleRequest, opts ...grpc.CallOption) (*GetCurrentBillingCycleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentBillingCycleResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetCurrentBillingCycle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMonthlyBillingCycle(ctx context.Context, in *GetMonthlyBillingCycleRequest, opts ...grpc.CallOption) (*GetMonthlyBillingCycleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMonthlyBillingCycleResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMonthlyBillingCycle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugbotSettings(ctx context.Context, in *GetBugbotSettingsRequest, opts ...grpc.CallOption) (*GetBugbotSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugbotSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugbotSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugbotAnalyticsV2(ctx context.Context, in *GetBugbotAnalyticsV2Request, opts ...grpc.CallOption) (*GetBugbotAnalyticsV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugbotAnalyticsV2Response)
	err := c.cc.Invoke(ctx, DashboardService_GetBugbotAnalyticsV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugBotPRAnalytics(ctx context.Context, in *GetBugBotPRAnalyticsRequest, opts ...grpc.CallOption) (*GetBugBotPRAnalyticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugBotPRAnalyticsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugBotPRAnalytics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetGithubInstallations(ctx context.Context, in *GetGithubInstallationsRequest, opts ...grpc.CallOption) (*GetGithubInstallationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGithubInstallationsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetGithubInstallations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetInstallationRepos(ctx context.Context, in *GetInstallationReposRequest, opts ...grpc.CallOption) (*GetInstallationReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInstallationReposResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetInstallationRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) FetchAllInstallationRepos(ctx context.Context, in *FetchAllInstallationReposRequest, opts ...grpc.CallOption) (*FetchAllInstallationReposResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchAllInstallationReposResponse)
	err := c.cc.Invoke(ctx, DashboardService_FetchAllInstallationRepos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetInstallationGithubUsers(ctx context.Context, in *GetInstallationGithubUsersRequest, opts ...grpc.CallOption) (*GetInstallationGithubUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInstallationGithubUsersResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetInstallationGithubUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamGithubUsers(ctx context.Context, in *GetTeamGithubUsersRequest, opts ...grpc.CallOption) (*GetTeamGithubUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamGithubUsersResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamGithubUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) AddGithubUsersToTeam(ctx context.Context, in *AddGithubUsersToTeamRequest, opts ...grpc.CallOption) (*AddGithubUsersToTeamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGithubUsersToTeamResponse)
	err := c.cc.Invoke(ctx, DashboardService_AddGithubUsersToTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUserPullRequests(ctx context.Context, in *GetUserPullRequestsRequest, opts ...grpc.CallOption) (*GetUserPullRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserPullRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUserPullRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUserReviewRequests(ctx context.Context, in *GetUserReviewRequestsRequest, opts ...grpc.CallOption) (*GetUserReviewRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserReviewRequestsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUserReviewRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateGithubRepoSettings(ctx context.Context, in *UpdateGithubRepoSettingsRequest, opts ...grpc.CallOption) (*UpdateGithubRepoSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGithubRepoSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateGithubRepoSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateGithubInstallationSettings(ctx context.Context, in *UpdateGithubInstallationSettingsRequest, opts ...grpc.CallOption) (*UpdateGithubInstallationSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGithubInstallationSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateGithubInstallationSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateAllGithubRepoSettings(ctx context.Context, in *UpdateAllGithubRepoSettingsRequest, opts ...grpc.CallOption) (*UpdateAllGithubRepoSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAllGithubRepoSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateAllGithubRepoSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateGithubInstallationTeamScope(ctx context.Context, in *UpdateGithubInstallationTeamScopeRequest, opts ...grpc.CallOption) (*UpdateGithubInstallationTeamScopeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGithubInstallationTeamScopeResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateGithubInstallationTeamScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateSelfGithubAllowlist(ctx context.Context, in *UpdateSelfGithubAllowlistRequest, opts ...grpc.CallOption) (*UpdateSelfGithubAllowlistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSelfGithubAllowlistResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateSelfGithubAllowlist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamBugbotSettings(ctx context.Context, in *GetTeamBugbotSettingsRequest, opts ...grpc.CallOption) (*GetTeamBugbotSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamBugbotSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamBugbotSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamBugbotSettings(ctx context.Context, in *UpdateTeamBugbotSettingsRequest, opts ...grpc.CallOption) (*UpdateTeamBugbotSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamBugbotSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamBugbotSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugbotUserSettings(ctx context.Context, in *GetBugbotUserSettingsRequest, opts ...grpc.CallOption) (*GetBugbotUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugbotUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugbotUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateBugbotUserSettings(ctx context.Context, in *UpdateBugbotUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBugbotUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBugbotUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateBugbotUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetBugBotProUserSettings(ctx context.Context, in *GetBugBotProUserSettingsRequest, opts ...grpc.CallOption) (*GetBugBotProUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBugBotProUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetBugBotProUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateBugBotProUserSettings(ctx context.Context, in *UpdateBugBotProUserSettingsRequest, opts ...grpc.CallOption) (*UpdateBugBotProUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateBugBotProUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateBugBotProUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RecordBugbotDeeplinkEvent(ctx context.Context, in *RecordBugbotDeeplinkEventRequest, opts ...grpc.CallOption) (*RecordBugbotDeeplinkEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordBugbotDeeplinkEventResponse)
	err := c.cc.Invoke(ctx, DashboardService_RecordBugbotDeeplinkEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RecordBugbotDeeplinkEventUnauthenticated(ctx context.Context, in *RecordBugbotDeeplinkEventRequest, opts ...grpc.CallOption) (*RecordBugbotDeeplinkEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordBugbotDeeplinkEventResponse)
	err := c.cc.Invoke(ctx, DashboardService_RecordBugbotDeeplinkEventUnauthenticated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeBugBotLicenses(ctx context.Context, in *RevokeBugBotLicensesRequest, opts ...grpc.CallOption) (*RevokeBugBotLicensesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeBugBotLicensesResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeBugBotLicenses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeUserBugbotLicense(ctx context.Context, in *RevokeUserBugbotLicenseRequest, opts ...grpc.CallOption) (*RevokeUserBugbotLicenseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeUserBugbotLicenseResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeUserBugbotLicense_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) StartBugbotBackfillLearning(ctx context.Context, in *StartBugbotBackfillLearningRequest, opts ...grpc.CallOption) (*StartBugbotBackfillLearningResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartBugbotBackfillLearningResponse)
	err := c.cc.Invoke(ctx, DashboardService_StartBugbotBackfillLearning_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetSlackAuth(ctx context.Context, in *SetSlackAuthRequest, opts ...grpc.CallOption) (*SetSlackAuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSlackAuthResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetSlackAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackTeamSettings(ctx context.Context, in *GetSlackTeamSettingsRequest, opts ...grpc.CallOption) (*GetSlackTeamSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackTeamSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackTeamSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateSlackTeamSettings(ctx context.Context, in *UpdateSlackTeamSettingsRequest, opts ...grpc.CallOption) (*UpdateSlackTeamSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSlackTeamSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateSlackTeamSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackSettings(ctx context.Context, in *GetSlackSettingsRequest, opts ...grpc.CallOption) (*GetSlackSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackModelOptions(ctx context.Context, in *GetSlackModelOptionsRequest, opts ...grpc.CallOption) (*GetSlackModelOptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackModelOptionsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackModelOptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackInstallUrl(ctx context.Context, in *GetSlackInstallUrlRequest, opts ...grpc.CallOption) (*GetSlackInstallUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackInstallUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackInstallUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackInstallUrlPublic(ctx context.Context, in *GetPublicSlackInstallUrlRequest, opts ...grpc.CallOption) (*GetPublicSlackInstallUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPublicSlackInstallUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackInstallUrlPublic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetFilteredUsageEvents(ctx context.Context, in *GetFilteredUsageEventsRequest, opts ...grpc.CallOption) (*GetFilteredUsageEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFilteredUsageEventsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetFilteredUsageEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAggregatedUsageEvents(ctx context.Context, in *GetAggregatedUsageEventsRequest, opts ...grpc.CallOption) (*GetAggregatedUsageEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAggregatedUsageEventsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAggregatedUsageEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAuditLogs(ctx context.Context, in *GetAuditLogsRequest, opts ...grpc.CallOption) (*GetAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuditLogsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetUserPrivacyMode(ctx context.Context, in *GetUserPrivacyModeRequest, opts ...grpc.CallOption) (*GetUserPrivacyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserPrivacyModeResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetUserPrivacyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetUserPrivacyMode(ctx context.Context, in *SetUserPrivacyModeRequest, opts ...grpc.CallOption) (*SetUserPrivacyModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserPrivacyModeResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetUserPrivacyMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) WebAcknowledgeGracePeriodDisclaimer(ctx context.Context, in *WebAcknowledgeGracePeriodDisclaimerRequest, opts ...grpc.CallOption) (*WebAcknowledgeGracePeriodDisclaimerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WebAcknowledgeGracePeriodDisclaimerResponse)
	err := c.cc.Invoke(ctx, DashboardService_WebAcknowledgeGracePeriodDisclaimer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SkipPrivacyModeGracePeriod(ctx context.Context, in *SkipPrivacyModeGracePeriodRequest, opts ...grpc.CallOption) (*SkipPrivacyModeGracePeriodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SkipPrivacyModeGracePeriodResponse)
	err := c.cc.Invoke(ctx, DashboardService_SkipPrivacyModeGracePeriod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) NeedsPrivacyModeMigration(ctx context.Context, in *NeedsPrivacyModeMigrationRequest, opts ...grpc.CallOption) (*NeedsPrivacyModeMigrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NeedsPrivacyModeMigrationResponse)
	err := c.cc.Invoke(ctx, DashboardService_NeedsPrivacyModeMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamPrivacyModeMigrationOptOut(ctx context.Context, in *UpdateTeamPrivacyModeMigrationOptOutRequest, opts ...grpc.CallOption) (*UpdateTeamPrivacyModeMigrationOptOutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamPrivacyModeMigrationOptOutResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamPrivacyModeMigrationOptOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ShareConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShareConversationResponse)
	err := c.cc.Invoke(ctx, DashboardService_ShareConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSharedConversation(ctx context.Context, in *GetSharedConversationRequest, opts ...grpc.CallOption) (*GetSharedConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSharedConversationResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSharedConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetPublicSharedConversation(ctx context.Context, in *GetPublicSharedConversationRequest, opts ...grpc.CallOption) (*GetPublicSharedConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPublicSharedConversationResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetPublicSharedConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListSharedConversations(ctx context.Context, in *ListSharedConversationsRequest, opts ...grpc.CallOption) (*ListSharedConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSharedConversationsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListSharedConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteSharedConversation(ctx context.Context, in *DeleteSharedConversationRequest, opts ...grpc.CallOption) (*DeleteSharedConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSharedConversationResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteSharedConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateSharedConversationVisibility(ctx context.Context, in *UpdateSharedConversationVisibilityRequest, opts ...grpc.CallOption) (*UpdateSharedConversationVisibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSharedConversationVisibilityResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateSharedConversationVisibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeTeamInviteLink(ctx context.Context, in *RevokeTeamInviteLinkRequest, opts ...grpc.CallOption) (*RevokeTeamInviteLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeTeamInviteLinkResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeTeamInviteLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListTeamInviteLinks(ctx context.Context, in *ListTeamInviteLinksRequest, opts ...grpc.CallOption) (*ListTeamInviteLinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamInviteLinksResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListTeamInviteLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateUserName(ctx context.Context, in *UpdateUserNameRequest, opts ...grpc.CallOption) (*UpdateUserNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserNameResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateUserName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListInvoices(ctx context.Context, in *ListInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInvoicesResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) IsEligibleForRefund(ctx context.Context, in *IsEligibleForRefundRequest, opts ...grpc.CallOption) (*IsEligibleForRefundResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsEligibleForRefundResponse)
	err := c.cc.Invoke(ctx, DashboardService_IsEligibleForRefund_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetRemainingRefunds(ctx context.Context, in *GetRemainingRefundsRequest, opts ...grpc.CallOption) (*GetRemainingRefundsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRemainingRefundsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetRemainingRefunds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetServiceAccountSpendLimit(ctx context.Context, in *GetServiceAccountSpendLimitRequest, opts ...grpc.CallOption) (*GetServiceAccountSpendLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServiceAccountSpendLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetServiceAccountSpendLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetServiceAccountSpendLimit(ctx context.Context, in *SetServiceAccountSpendLimitRequest, opts ...grpc.CallOption) (*SetServiceAccountSpendLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetServiceAccountSpendLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetServiceAccountSpendLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetUserHardLimit(ctx context.Context, in *SetUserHardLimitRequest, opts ...grpc.CallOption) (*SetUserHardLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserHardLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetUserHardLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetUserMonthlyLimit(ctx context.Context, in *SetUserMonthlyLimitRequest, opts ...grpc.CallOption) (*SetUserMonthlyLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserMonthlyLimitResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetUserMonthlyLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ToggleMarketingEmailOpt(ctx context.Context, in *ToggleMarketingEmailOptRequest, opts ...grpc.CallOption) (*ToggleMarketingEmailOptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ToggleMarketingEmailOptResponse)
	err := c.cc.Invoke(ctx, DashboardService_ToggleMarketingEmailOpt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetMarketingEmailOpt(ctx context.Context, in *GetMarketingEmailOptRequest, opts ...grpc.CallOption) (*GetMarketingEmailOptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMarketingEmailOptResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetMarketingEmailOpt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetGlobalLeaderboardOptIn(ctx context.Context, in *GetGlobalLeaderboardOptInRequest, opts ...grpc.CallOption) (*GetGlobalLeaderboardOptInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGlobalLeaderboardOptInResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetGlobalLeaderboardOptIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SetGlobalLeaderboardOptIn(ctx context.Context, in *SetGlobalLeaderboardOptInRequest, opts ...grpc.CallOption) (*SetGlobalLeaderboardOptInResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetGlobalLeaderboardOptInResponse)
	err := c.cc.Invoke(ctx, DashboardService_SetGlobalLeaderboardOptIn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamApiKey(ctx context.Context, in *CreateTeamApiKeyRequest, opts ...grpc.CallOption) (*CreateTeamApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamApiKeyResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeTeamApiKey(ctx context.Context, in *RevokeTeamApiKeyRequest, opts ...grpc.CallOption) (*RevokeTeamApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeTeamApiKeyResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeTeamApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListTeamApiKeys(ctx context.Context, in *ListTeamApiKeysRequest, opts ...grpc.CallOption) (*ListTeamApiKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamApiKeysResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListTeamApiKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateTeamServiceAccount(ctx context.Context, in *CreateTeamServiceAccountRequest, opts ...grpc.CallOption) (*CreateTeamServiceAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTeamServiceAccountResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateTeamServiceAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListTeamServiceAccounts(ctx context.Context, in *ListTeamServiceAccountsRequest, opts ...grpc.CallOption) (*ListTeamServiceAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamServiceAccountsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListTeamServiceAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteTeamServiceAccount(ctx context.Context, in *DeleteTeamServiceAccountRequest, opts ...grpc.CallOption) (*DeleteTeamServiceAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamServiceAccountResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteTeamServiceAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ArchiveTeamServiceAccount(ctx context.Context, in *ArchiveTeamServiceAccountRequest, opts ...grpc.CallOption) (*ArchiveTeamServiceAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArchiveTeamServiceAccountResponse)
	err := c.cc.Invoke(ctx, DashboardService_ArchiveTeamServiceAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RotateServiceAccountApiKey(ctx context.Context, in *RotateServiceAccountApiKeyRequest, opts ...grpc.CallOption) (*RotateServiceAccountApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RotateServiceAccountApiKeyResponse)
	err := c.cc.Invoke(ctx, DashboardService_RotateServiceAccountApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetTeamRepositoriesForServiceAccountScope(ctx context.Context, in *GetTeamRepositoriesForServiceAccountScopeRequest, opts ...grpc.CallOption) (*GetTeamRepositoriesForServiceAccountScopeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamRepositoriesForServiceAccountScopeResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetTeamRepositoriesForServiceAccountScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateServiceAccountRepoScope(ctx context.Context, in *UpdateServiceAccountRepoScopeRequest, opts ...grpc.CallOption) (*UpdateServiceAccountRepoScopeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateServiceAccountRepoScopeResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateServiceAccountRepoScope_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateUserApiKey(ctx context.Context, in *CreateUserApiKeyRequest, opts ...grpc.CallOption) (*CreateUserApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserApiKeyResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateUserApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RevokeUserApiKey(ctx context.Context, in *RevokeUserApiKeyRequest, opts ...grpc.CallOption) (*RevokeUserApiKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeUserApiKeyResponse)
	err := c.cc.Invoke(ctx, DashboardService_RevokeUserApiKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListUserApiKeys(ctx context.Context, in *ListUserApiKeysRequest, opts ...grpc.CallOption) (*ListUserApiKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserApiKeysResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListUserApiKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ConfirmGithubInstallation(ctx context.Context, in *ConfirmGithubInstallationRequest, opts ...grpc.CallOption) (*ConfirmGithubInstallationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfirmGithubInstallationResponse)
	err := c.cc.Invoke(ctx, DashboardService_ConfirmGithubInstallation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest, opts ...grpc.CallOption) (*UpdateTeamNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamNameResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateTeamDashboardAnalyticsSetting(ctx context.Context, in *UpdateTeamDashboardAnalyticsSettingRequest, opts ...grpc.CallOption) (*UpdateTeamDashboardAnalyticsSettingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTeamDashboardAnalyticsSettingResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateTeamDashboardAnalyticsSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackUserSettings(ctx context.Context, in *GetSlackUserSettingsRequest, opts ...grpc.CallOption) (*GetSlackUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateSlackUserSettings(ctx context.Context, in *UpdateSlackUserSettingsRequest, opts ...grpc.CallOption) (*UpdateSlackUserSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSlackUserSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateSlackUserSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetSlackRepoRoutingRules(ctx context.Context, in *GetSlackRepoRoutingRulesRequest, opts ...grpc.CallOption) (*GetSlackRepoRoutingRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlackRepoRoutingRulesResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetSlackRepoRoutingRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateSlackRepoRoutingRule(ctx context.Context, in *CreateSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*CreateSlackRepoRoutingRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSlackRepoRoutingRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateSlackRepoRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateSlackRepoRoutingRule(ctx context.Context, in *UpdateSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*UpdateSlackRepoRoutingRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSlackRepoRoutingRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateSlackRepoRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteSlackRepoRoutingRule(ctx context.Context, in *DeleteSlackRepoRoutingRuleRequest, opts ...grpc.CallOption) (*DeleteSlackRepoRoutingRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSlackRepoRoutingRuleResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteSlackRepoRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) IsOnNewPricing(ctx context.Context, in *IsOnNewPricingRequest, opts ...grpc.CallOption) (*IsOnNewPricingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsOnNewPricingResponse)
	err := c.cc.Invoke(ctx, DashboardService_IsOnNewPricing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearAuthUrl(ctx context.Context, in *GetLinearAuthUrlRequest, opts ...grpc.CallOption) (*GetLinearAuthUrlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearAuthUrlResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearAuthUrl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearStatus(ctx context.Context, in *GetLinearStatusRequest, opts ...grpc.CallOption) (*GetLinearStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearStatusResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DisconnectLinear(ctx context.Context, in *DisconnectLinearRequest, opts ...grpc.CallOption) (*DisconnectLinearResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectLinearResponse)
	err := c.cc.Invoke(ctx, DashboardService_DisconnectLinear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearTeams(ctx context.Context, in *GetLinearTeamsRequest, opts ...grpc.CallOption) (*GetLinearTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearTeamsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearSettings(ctx context.Context, in *GetLinearSettingsRequest, opts ...grpc.CallOption) (*GetLinearSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearSettingsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateLinearTeamSetting(ctx context.Context, in *UpdateLinearTeamSettingRequest, opts ...grpc.CallOption) (*UpdateLinearTeamSettingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLinearTeamSettingResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateLinearTeamSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateLinearProjectSetting(ctx context.Context, in *UpdateLinearProjectSettingRequest, opts ...grpc.CallOption) (*UpdateLinearProjectSettingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLinearProjectSettingResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateLinearProjectSetting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearLabels(ctx context.Context, in *GetLinearLabelsRequest, opts ...grpc.CallOption) (*GetLinearLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearLabelsResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetLinearIssues(ctx context.Context, in *GetLinearIssuesRequest, opts ...grpc.CallOption) (*GetLinearIssuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinearIssuesResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetLinearIssues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteBedrockIamRole(ctx context.Context, in *DeleteBedrockIamRoleRequest, opts ...grpc.CallOption) (*DeleteBedrockIamRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteBedrockIamRoleResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteBedrockIamRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UnlinkSlackAccess(ctx context.Context, in *UnlinkSlackAccessRequest, opts ...grpc.CallOption) (*UnlinkSlackAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlinkSlackAccessResponse)
	err := c.cc.Invoke(ctx, DashboardService_UnlinkSlackAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListSlackConversations(ctx context.Context, in *ListSlackConversationsRequest, opts ...grpc.CallOption) (*ListSlackConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSlackConversationsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListSlackConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) LogSlackbotAuthConversionFunnel(ctx context.Context, in *LogSlackbotAuthConversionFunnelRequest, opts ...grpc.CallOption) (*LogSlackbotAuthConversionFunnelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogSlackbotAuthConversionFunnelResponse)
	err := c.cc.Invoke(ctx, DashboardService_LogSlackbotAuthConversionFunnel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) LogClickedConnectSlack(ctx context.Context, in *LogClickedConnectSlackRequest, opts ...grpc.CallOption) (*LogClickedConnectSlackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogClickedConnectSlackResponse)
	err := c.cc.Invoke(ctx, DashboardService_LogClickedConnectSlack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CheckUserApiKeyAccess(ctx context.Context, in *CheckUserApiKeyAccessRequest, opts ...grpc.CallOption) (*CheckUserApiKeyAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUserApiKeyAccessResponse)
	err := c.cc.Invoke(ctx, DashboardService_CheckUserApiKeyAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) IsAllowedFreeTrialUsage(ctx context.Context, in *IsAllowedFreeTrialUsageRequest, opts ...grpc.CallOption) (*IsAllowedFreeTrialUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsAllowedFreeTrialUsageResponse)
	err := c.cc.Invoke(ctx, DashboardService_IsAllowedFreeTrialUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CompletedLinkSlackAccount(ctx context.Context, in *CompletedLinkSlackAccountRequest, opts ...grpc.CallOption) (*CompletedLinkSlackAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompletedLinkSlackAccountResponse)
	err := c.cc.Invoke(ctx, DashboardService_CompletedLinkSlackAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) NotifyTeamAdmins(ctx context.Context, in *NotifyTeamAdminsRequest, opts ...grpc.CallOption) (*NotifyTeamAdminsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotifyTeamAdminsResponse)
	err := c.cc.Invoke(ctx, DashboardService_NotifyTeamAdmins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) GetAdminNotificationStatus(ctx context.Context, in *GetAdminNotificationStatusRequest, opts ...grpc.CallOption) (*GetAdminNotificationStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAdminNotificationStatusResponse)
	err := c.cc.Invoke(ctx, DashboardService_GetAdminNotificationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) OptOutNewPricing(ctx context.Context, in *OptOutNewPricingRequest, opts ...grpc.CallOption) (*OptOutNewPricingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OptOutNewPricingResponse)
	err := c.cc.Invoke(ctx, DashboardService_OptOutNewPricing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) SubmitFeedback(ctx context.Context, in *SubmitFeedbackRequest, opts ...grpc.CallOption) (*SubmitFeedbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitFeedbackResponse)
	err := c.cc.Invoke(ctx, DashboardService_SubmitFeedback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CanStudentReverify(ctx context.Context, in *CanStudentReverifyRequest, opts ...grpc.CallOption) (*CanStudentReverifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanStudentReverifyResponse)
	err := c.cc.Invoke(ctx, DashboardService_CanStudentReverify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ClientAction(ctx context.Context, in *ClientActionRequest, opts ...grpc.CallOption) (*ClientActionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClientActionResponse)
	err := c.cc.Invoke(ctx, DashboardService_ClientAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) ListUsageAlerts(ctx context.Context, in *ListUsageAlertsRequest, opts ...grpc.CallOption) (*ListUsageAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsageAlertsResponse)
	err := c.cc.Invoke(ctx, DashboardService_ListUsageAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) CreateUsageAlerts(ctx context.Context, in *CreateUsageAlertsRequest, opts ...grpc.CallOption) (*CreateUsageAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUsageAlertsResponse)
	err := c.cc.Invoke(ctx, DashboardService_CreateUsageAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) DeleteUsageAlerts(ctx context.Context, in *DeleteUsageAlertsRequest, opts ...grpc.CallOption) (*DeleteUsageAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUsageAlertsResponse)
	err := c.cc.Invoke(ctx, DashboardService_DeleteUsageAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) UpdateUsageAlerts(ctx context.Context, in *UpdateUsageAlertsRequest, opts ...grpc.CallOption) (*UpdateUsageAlertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUsageAlertsResponse)
	err := c.cc.Invoke(ctx, DashboardService_UpdateUsageAlerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dashboardServiceClient) RequestIndividualLimitsOptOut(ctx context.Context, in *RequestIndividualLimitsOptOutRequest, opts ...grpc.CallOption) (*RequestIndividualLimitsOptOutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestIndividualLimitsOptOutResponse)
	err := c.cc.Invoke(ctx, DashboardService_RequestIndividualLimitsOptOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DashboardServiceServer is the server API for DashboardService service.
// All implementations must embed UnimplementedDashboardServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.DashboardService (var: Nje)
type DashboardServiceServer interface {
	GetTeams(context.Context, *GetTeamsRequest) (*GetTeamsResponse, error)
	GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error)
	GetDirectoryGroups(context.Context, *GetDirectoryGroupsRequest) (*GetDirectoryGroupsResponse, error)
	UpdateDirectoryGroupSettings(context.Context, *UpdateDirectoryGroupSettingsRequest) (*UpdateDirectoryGroupSettingsResponse, error)
	GetGroups(context.Context, *GetGroupsRequest) (*GetGroupsResponse, error)
	GetGroupMembers(context.Context, *GetGroupMembersRequest) (*GetGroupMembersResponse, error)
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error)
	UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error)
	DeleteGroup(context.Context, *DeleteGroupRequest) (*DeleteGroupResponse, error)
	AddGroupMembers(context.Context, *AddGroupMembersRequest) (*AddGroupMembersResponse, error)
	RemoveGroupMembers(context.Context, *RemoveGroupMembersRequest) (*RemoveGroupMembersResponse, error)
	BulkAssignGroupMembers(context.Context, *BulkAssignGroupMembersRequest) (*BulkAssignGroupMembersResponse, error)
	PreviewAttachGroupToDirectory(context.Context, *PreviewAttachGroupToDirectoryRequest) (*PreviewAttachGroupToDirectoryResponse, error)
	DetachGroupFromDirectory(context.Context, *DetachGroupFromDirectoryRequest) (*DetachGroupFromDirectoryResponse, error)
	GetScimConflicts(context.Context, *GetScimConflictsRequest) (*GetScimConflictsResponse, error)
	GetActivationCheckoutUrl(context.Context, *GetActivationCheckoutUrlRequest) (*GetActivationCheckoutUrlResponse, error)
	GetTeamCustomerPortalUrl(context.Context, *GetTeamCustomerPortalUrlRequest) (*GetTeamCustomerPortalUrlResponse, error)
	GetTeamMembers(context.Context, *GetTeamMembersRequest) (*GetTeamMembersResponse, error)
	SendTeamInvite(context.Context, *SendTeamInviteRequest) (*SendTeamInviteResponse, error)
	GetTeamInviteLink(context.Context, *GetTeamInviteLinkRequest) (*GetTeamInviteLinkResponse, error)
	AcceptInvite(context.Context, *AcceptInviteRequest) (*AcceptInviteResponse, error)
	CreateTeam(context.Context, *CreateTeamRequest) (*CreateTeamResponse, error)
	GetJoinableTeamsByDomain(context.Context, *GetJoinableTeamsByDomainRequest) (*GetJoinableTeamsByDomainResponse, error)
	JoinTeamByDomain(context.Context, *JoinTeamByDomainRequest) (*JoinTeamByDomainResponse, error)
	UpdateTeamDomainJoinSetting(context.Context, *UpdateTeamDomainJoinSettingRequest) (*UpdateTeamDomainJoinSettingResponse, error)
	GetTeamMemberDomains(context.Context, *GetTeamMemberDomainsRequest) (*GetTeamMemberDomainsResponse, error)
	GetTeamIdForReactivation(context.Context, *GetTeamIdForReactivationRequest) (*GetTeamIdForReactivationResponse, error)
	ChangeSeat(context.Context, *ChangeSeatRequest) (*ChangeSeatResponse, error)
	ChangeTeamSubscription(context.Context, *ChangeTeamSubscriptionRequest) (*ChangeTeamSubscriptionResponse, error)
	ConnectGithubCallback(context.Context, *ConnectGithubCallbackRequest) (*ConnectGithubCallbackResponse, error)
	RegisterGithubCursorCode(context.Context, *RegisterGithubCursorCodeRequest) (*RegisterGithubCursorCodeResponse, error)
	DisconnectGithub(context.Context, *DisconnectGithubRequest) (*DisconnectGithubResponse, error)
	PrepareSetupGithubEnterpriseApp(context.Context, *PrepareSetupGithubEnterpriseAppRequest) (*PrepareSetupGithubEnterpriseAppResponse, error)
	FinishSetupGithubEnterpriseApp(context.Context, *FinishSetupGithubEnterpriseAppRequest) (*FinishSetupGithubEnterpriseAppResponse, error)
	ListGithubEnterpriseApps(context.Context, *ListGithubEnterpriseAppsRequest) (*ListGithubEnterpriseAppsResponse, error)
	DeleteGithubEnterpriseApp(context.Context, *DeleteGithubEnterpriseAppRequest) (*DeleteGithubEnterpriseAppResponse, error)
	SetupGitlabEnterpriseInstance(context.Context, *SetupGitlabEnterpriseInstanceRequest) (*SetupGitlabEnterpriseInstanceResponse, error)
	ListGitlabEnterpriseInstances(context.Context, *ListGitlabEnterpriseInstancesRequest) (*ListGitlabEnterpriseInstancesResponse, error)
	DeleteGitlabEnterpriseInstance(context.Context, *DeleteGitlabEnterpriseInstanceRequest) (*DeleteGitlabEnterpriseInstanceResponse, error)
	SyncGitlabRepos(context.Context, *SyncGitlabReposRequest) (*SyncGitlabReposResponse, error)
	UpdateRole(context.Context, *UpdateRoleRequest) (*UpdateRoleResponse, error)
	RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error)
	GetTeamUsage(context.Context, *GetTeamUsageRequest) (*GetTeamUsageResponse, error)
	GetSignUpType(context.Context, *GetSignUpTypeRequest) (*GetSignUpTypeResponse, error)
	GetHardLimit(context.Context, *GetHardLimitRequest) (*GetHardLimitResponse, error)
	SetHardLimit(context.Context, *SetHardLimitRequest) (*SetHardLimitResponse, error)
	EnableOnDemandSpend(context.Context, *EnableOnDemandSpendRequest) (*EnableOnDemandSpendResponse, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error)
	SendDownloadEmail(context.Context, *SendDownloadEmailRequest) (*SendDownloadEmailResponse, error)
	GetMonthlyInvoice(context.Context, *GetMonthlyInvoiceRequest) (*GetMonthlyInvoiceResponse, error)
	ListInvoiceCycles(context.Context, *ListInvoiceCyclesRequest) (*ListInvoiceCyclesResponse, error)
	GetDailySpendByCategory(context.Context, *GetDailySpendByCategoryRequest) (*GetDailySpendByCategoryResponse, error)
	GetPricingHistory(context.Context, *GetPricingHistoryRequest) (*GetPricingHistoryResponse, error)
	ListBackgroundComposerSecrets(context.Context, *ListBackgroundComposerSecretsRequest) (*ListBackgroundComposerSecretsResponse, error)
	CreateBackgroundComposerSecret(context.Context, *CreateBackgroundComposerSecretRequest) (*CreateBackgroundComposerSecretResponse, error)
	RevokeBackgroundComposerSecret(context.Context, *RevokeBackgroundComposerSecretRequest) (*RevokeBackgroundComposerSecretResponse, error)
	UpdateBackgroundComposerSecret(context.Context, *UpdateBackgroundComposerSecretRequest) (*UpdateBackgroundComposerSecretResponse, error)
	GetMcpConfig(context.Context, *GetMcpConfigRequest) (*GetMcpConfigResponse, error)
	GetAvailableMcpServers(context.Context, *GetAvailableMcpServersRequest) (*GetAvailableMcpServersResponse, error)
	SetMcpConfig(context.Context, *SetMcpConfigRequest) (*SetMcpConfigResponse, error)
	UpdateUserDefaultMcpSettings(context.Context, *UpdateUserDefaultMcpSettingsRequest) (*UpdateUserDefaultMcpSettingsResponse, error)
	StoreMcpOAuthToken(context.Context, *StoreMcpOAuthTokenRequest) (*StoreMcpOAuthTokenResponse, error)
	ValidateMcpOAuthTokens(context.Context, *ValidateMcpOAuthTokensRequest) (*ValidateMcpOAuthTokensResponse, error)
	StoreMcpOAuthPendingState(context.Context, *StoreMcpOAuthPendingStateRequest) (*StoreMcpOAuthPendingStateResponse, error)
	GetMcpOAuthPendingState(context.Context, *GetMcpOAuthPendingStateRequest) (*GetMcpOAuthPendingStateResponse, error)
	CreateTeamWithFreeTrial(context.Context, *CreateTeamWithFreeTrialRequest) (*CreateTeamWithFreeTrialResponse, error)
	GetTeamHasValidPaymentMethod(context.Context, *GetTeamHasValidPaymentMethodRequest) (*GetTeamHasValidPaymentMethodResponse, error)
	GetTeamPrivacyModeForced(context.Context, *GetTeamPrivacyModeForcedRequest) (*GetTeamPrivacyModeForcedResponse, error)
	SwitchTeamPrivacyMode(context.Context, *SwitchTeamPrivacyModeRequest) (*SwitchTeamPrivacyModeResponse, error)
	UpdateFastRequests(context.Context, *UpdateFastRequestsRequest) (*UpdateFastRequestsResponse, error)
	GetFastRequests(context.Context, *GetFastRequestsRequest) (*GetFastRequestsResponse, error)
	GetDownloadLink(context.Context, *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error)
	GetCliDownloadUrl(context.Context, *GetCliDownloadUrlRequest) (*GetCliDownloadUrlResponse, error)
	GetSsoConfigurationLinks(context.Context, *GetSsoConfigurationLinksRequest) (*GetSsoConfigurationLinksResponse, error)
	GetScimConfigurationLinks(context.Context, *GetScimConfigurationLinksRequest) (*GetScimConfigurationLinksResponse, error)
	SetAdminOnlyUsagePricing(context.Context, *SetAdminOnlyUsagePricingRequest) (*SetAdminOnlyUsagePricingResponse, error)
	GetYearlyUpgradeEligibility(context.Context, *GetYearlyUpgradeEligibilityRequest) (*GetYearlyUpgradeEligibilityResponse, error)
	UpgradeToYearly(context.Context, *UpgradeToYearlyRequest) (*UpgradeToYearlyResponse, error)
	GetEnterpriseCTAEligibility(context.Context, *GetEnterpriseCTAEligibilityRequest) (*GetEnterpriseCTAEligibilityResponse, error)
	GetUsageBasedPremiumRequests(context.Context, *GetUsageBasedPremiumRequestsRequest) (*GetUsageBasedPremiumRequestsResponse, error)
	SetUsageBasedPremiumRequests(context.Context, *SetUsageBasedPremiumRequestsRequest) (*SetUsageBasedPremiumRequestsResponse, error)
	GetReferrals(context.Context, *GetReferralsRequest) (*GetReferralsResponse, error)
	CheckReferralCode(context.Context, *CheckReferralCodeRequest) (*CheckReferralCodeResponse, error)
	RedeemGiftCode(context.Context, *RedeemGiftCodeRequest) (*RedeemGiftCodeResponse, error)
	GetTeamRepos(context.Context, *GetTeamReposRequest) (*GetTeamReposResponse, error)
	GetTeamReposOrEmptyIfNotInTeam(context.Context, *GetTeamReposRequest) (*GetTeamReposResponse, error)
	GetTeamRules(context.Context, *GetTeamRulesRequest) (*GetTeamRulesResponse, error)
	CreateTeamRule(context.Context, *CreateTeamRuleRequest) (*CreateTeamRuleResponse, error)
	UpdateTeamRule(context.Context, *UpdateTeamRuleRequest) (*UpdateTeamRuleResponse, error)
	DeleteTeamRule(context.Context, *DeleteTeamRuleRequest) (*DeleteTeamRuleResponse, error)
	GetTeamHooks(context.Context, *GetTeamHooksRequest) (*GetTeamHooksResponse, error)
	CreateTeamHook(context.Context, *CreateTeamHookRequest) (*CreateTeamHookResponse, error)
	UpdateTeamHook(context.Context, *UpdateTeamHookRequest) (*UpdateTeamHookResponse, error)
	DeleteTeamHook(context.Context, *DeleteTeamHookRequest) (*DeleteTeamHookResponse, error)
	GetTeamCommands(context.Context, *GetTeamCommandsRequest) (*GetTeamCommandsResponse, error)
	CreateTeamCommand(context.Context, *CreateTeamCommandRequest) (*CreateTeamCommandResponse, error)
	UpdateTeamCommand(context.Context, *UpdateTeamCommandRequest) (*UpdateTeamCommandResponse, error)
	DeleteTeamCommand(context.Context, *DeleteTeamCommandRequest) (*DeleteTeamCommandResponse, error)
	GetBugbotTeamRules(context.Context, *GetBugbotTeamRulesRequest) (*GetBugbotTeamRulesResponse, error)
	CreateBugbotTeamRule(context.Context, *CreateBugbotTeamRuleRequest) (*CreateBugbotTeamRuleResponse, error)
	UpdateBugbotTeamRule(context.Context, *UpdateBugbotTeamRuleRequest) (*UpdateBugbotTeamRuleResponse, error)
	DeleteBugbotTeamRule(context.Context, *DeleteBugbotTeamRuleRequest) (*DeleteBugbotTeamRuleResponse, error)
	GetBugbotLearnedRules(context.Context, *GetBugbotLearnedRulesRequest) (*GetBugbotLearnedRulesResponse, error)
	UpdateBugbotLearnedRule(context.Context, *UpdateBugbotLearnedRuleRequest) (*UpdateBugbotLearnedRuleResponse, error)
	DeleteBugbotLearnedRule(context.Context, *DeleteBugbotLearnedRuleRequest) (*DeleteBugbotLearnedRuleResponse, error)
	CreateTeamRepo(context.Context, *CreateTeamRepoRequest) (*CreateTeamRepoResponse, error)
	DeleteTeamRepo(context.Context, *DeleteTeamRepoRequest) (*DeleteTeamRepoResponse, error)
	AddRepoPattern(context.Context, *AddRepoPatternRequest) (*AddRepoPatternResponse, error)
	RemoveRepoPattern(context.Context, *RemoveRepoPatternRequest) (*RemoveRepoPatternResponse, error)
	SetTeamRepoType(context.Context, *SetTeamRepoTypeRequest) (*SetTeamRepoTypeResponse, error)
	GetTeamAdminSettings(context.Context, *GetTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error)
	GetTeamAdminSettingsOrEmptyIfNotInTeam(context.Context, *GetTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error)
	GetBaseTeamAdminSettings(context.Context, *GetBaseTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error)
	UpdateTeamAdminSettings(context.Context, *UpdateTeamAdminSettingsRequest) (*UpdateTeamAdminSettingsResponse, error)
	CreateTeamFreeTrialCode(context.Context, *CreateTeamFreeTrialCodeRequest) (*CreateTeamFreeTrialCodeResponse, error)
	GetTeamAnalytics(context.Context, *GetTeamAnalyticsRequest) (*GetTeamAnalyticsResponse, error)
	GetUserAnalytics(context.Context, *GetUserAnalyticsRequest) (*GetUserAnalyticsResponse, error)
	GetTeamRawData(context.Context, *GetTeamRawDataRequest) (*GetTeamRawDataResponse, error)
	GetClientUsageData(context.Context, *GetClientUsageDataRequest) (*GetClientUsageDataResponse, error)
	GetCurrentPeriodUsage(context.Context, *GetCurrentPeriodUsageRequest) (*GetCurrentPeriodUsageResponse, error)
	GetPlanInfo(context.Context, *GetPlanInfoRequest) (*GetPlanInfoResponse, error)
	GetUsageLimitPolicyStatus(context.Context, *GetUsageLimitPolicyStatusRequest) (*GetUsageLimitPolicyStatusResponse, error)
	GetAdvancedAnalyticsEnabled(context.Context, *GetAdvancedAnalyticsEnabledRequest) (*GetAdvancedAnalyticsEnabledResponse, error)
	GetTokenUsage(context.Context, *GetTokenUsageRequest) (*GetTokenUsageResponse, error)
	ValidateBedrockIamRole(context.Context, *ValidateBedrockIamRoleRequest) (*ValidateBedrockIamRoleResponse, error)
	AddUserToEarlyAccessList(context.Context, *AddUserToEarlyAccessListRequest) (*AddUserToEarlyAccessListResponse, error)
	GetTeamSpend(context.Context, *GetTeamSpendRequest) (*GetTeamSpendResponse, error)
	GetCurrentBillingCycle(context.Context, *GetCurrentBillingCycleRequest) (*GetCurrentBillingCycleResponse, error)
	GetMonthlyBillingCycle(context.Context, *GetMonthlyBillingCycleRequest) (*GetMonthlyBillingCycleResponse, error)
	GetBugbotSettings(context.Context, *GetBugbotSettingsRequest) (*GetBugbotSettingsResponse, error)
	GetBugbotAnalyticsV2(context.Context, *GetBugbotAnalyticsV2Request) (*GetBugbotAnalyticsV2Response, error)
	GetBugBotPRAnalytics(context.Context, *GetBugBotPRAnalyticsRequest) (*GetBugBotPRAnalyticsResponse, error)
	GetGithubInstallations(context.Context, *GetGithubInstallationsRequest) (*GetGithubInstallationsResponse, error)
	GetInstallationRepos(context.Context, *GetInstallationReposRequest) (*GetInstallationReposResponse, error)
	FetchAllInstallationRepos(context.Context, *FetchAllInstallationReposRequest) (*FetchAllInstallationReposResponse, error)
	GetInstallationGithubUsers(context.Context, *GetInstallationGithubUsersRequest) (*GetInstallationGithubUsersResponse, error)
	GetTeamGithubUsers(context.Context, *GetTeamGithubUsersRequest) (*GetTeamGithubUsersResponse, error)
	AddGithubUsersToTeam(context.Context, *AddGithubUsersToTeamRequest) (*AddGithubUsersToTeamResponse, error)
	GetUserPullRequests(context.Context, *GetUserPullRequestsRequest) (*GetUserPullRequestsResponse, error)
	GetUserReviewRequests(context.Context, *GetUserReviewRequestsRequest) (*GetUserReviewRequestsResponse, error)
	UpdateGithubRepoSettings(context.Context, *UpdateGithubRepoSettingsRequest) (*UpdateGithubRepoSettingsResponse, error)
	UpdateGithubInstallationSettings(context.Context, *UpdateGithubInstallationSettingsRequest) (*UpdateGithubInstallationSettingsResponse, error)
	UpdateAllGithubRepoSettings(context.Context, *UpdateAllGithubRepoSettingsRequest) (*UpdateAllGithubRepoSettingsResponse, error)
	UpdateGithubInstallationTeamScope(context.Context, *UpdateGithubInstallationTeamScopeRequest) (*UpdateGithubInstallationTeamScopeResponse, error)
	UpdateSelfGithubAllowlist(context.Context, *UpdateSelfGithubAllowlistRequest) (*UpdateSelfGithubAllowlistResponse, error)
	GetTeamBugbotSettings(context.Context, *GetTeamBugbotSettingsRequest) (*GetTeamBugbotSettingsResponse, error)
	UpdateTeamBugbotSettings(context.Context, *UpdateTeamBugbotSettingsRequest) (*UpdateTeamBugbotSettingsResponse, error)
	GetBugbotUserSettings(context.Context, *GetBugbotUserSettingsRequest) (*GetBugbotUserSettingsResponse, error)
	UpdateBugbotUserSettings(context.Context, *UpdateBugbotUserSettingsRequest) (*UpdateBugbotUserSettingsResponse, error)
	GetBugBotProUserSettings(context.Context, *GetBugBotProUserSettingsRequest) (*GetBugBotProUserSettingsResponse, error)
	UpdateBugBotProUserSettings(context.Context, *UpdateBugBotProUserSettingsRequest) (*UpdateBugBotProUserSettingsResponse, error)
	RecordBugbotDeeplinkEvent(context.Context, *RecordBugbotDeeplinkEventRequest) (*RecordBugbotDeeplinkEventResponse, error)
	RecordBugbotDeeplinkEventUnauthenticated(context.Context, *RecordBugbotDeeplinkEventRequest) (*RecordBugbotDeeplinkEventResponse, error)
	RevokeBugBotLicenses(context.Context, *RevokeBugBotLicensesRequest) (*RevokeBugBotLicensesResponse, error)
	RevokeUserBugbotLicense(context.Context, *RevokeUserBugbotLicenseRequest) (*RevokeUserBugbotLicenseResponse, error)
	StartBugbotBackfillLearning(context.Context, *StartBugbotBackfillLearningRequest) (*StartBugbotBackfillLearningResponse, error)
	SetSlackAuth(context.Context, *SetSlackAuthRequest) (*SetSlackAuthResponse, error)
	GetSlackTeamSettings(context.Context, *GetSlackTeamSettingsRequest) (*GetSlackTeamSettingsResponse, error)
	UpdateSlackTeamSettings(context.Context, *UpdateSlackTeamSettingsRequest) (*UpdateSlackTeamSettingsResponse, error)
	GetSlackSettings(context.Context, *GetSlackSettingsRequest) (*GetSlackSettingsResponse, error)
	GetSlackModelOptions(context.Context, *GetSlackModelOptionsRequest) (*GetSlackModelOptionsResponse, error)
	GetSlackInstallUrl(context.Context, *GetSlackInstallUrlRequest) (*GetSlackInstallUrlResponse, error)
	GetSlackInstallUrlPublic(context.Context, *GetPublicSlackInstallUrlRequest) (*GetPublicSlackInstallUrlResponse, error)
	GetFilteredUsageEvents(context.Context, *GetFilteredUsageEventsRequest) (*GetFilteredUsageEventsResponse, error)
	GetAggregatedUsageEvents(context.Context, *GetAggregatedUsageEventsRequest) (*GetAggregatedUsageEventsResponse, error)
	GetAuditLogs(context.Context, *GetAuditLogsRequest) (*GetAuditLogsResponse, error)
	GetUserPrivacyMode(context.Context, *GetUserPrivacyModeRequest) (*GetUserPrivacyModeResponse, error)
	SetUserPrivacyMode(context.Context, *SetUserPrivacyModeRequest) (*SetUserPrivacyModeResponse, error)
	WebAcknowledgeGracePeriodDisclaimer(context.Context, *WebAcknowledgeGracePeriodDisclaimerRequest) (*WebAcknowledgeGracePeriodDisclaimerResponse, error)
	SkipPrivacyModeGracePeriod(context.Context, *SkipPrivacyModeGracePeriodRequest) (*SkipPrivacyModeGracePeriodResponse, error)
	NeedsPrivacyModeMigration(context.Context, *NeedsPrivacyModeMigrationRequest) (*NeedsPrivacyModeMigrationResponse, error)
	UpdateTeamPrivacyModeMigrationOptOut(context.Context, *UpdateTeamPrivacyModeMigrationOptOutRequest) (*UpdateTeamPrivacyModeMigrationOptOutResponse, error)
	ShareConversation(context.Context, *ShareConversationRequest) (*ShareConversationResponse, error)
	GetSharedConversation(context.Context, *GetSharedConversationRequest) (*GetSharedConversationResponse, error)
	GetPublicSharedConversation(context.Context, *GetPublicSharedConversationRequest) (*GetPublicSharedConversationResponse, error)
	ListSharedConversations(context.Context, *ListSharedConversationsRequest) (*ListSharedConversationsResponse, error)
	DeleteSharedConversation(context.Context, *DeleteSharedConversationRequest) (*DeleteSharedConversationResponse, error)
	UpdateSharedConversationVisibility(context.Context, *UpdateSharedConversationVisibilityRequest) (*UpdateSharedConversationVisibilityResponse, error)
	RevokeTeamInviteLink(context.Context, *RevokeTeamInviteLinkRequest) (*RevokeTeamInviteLinkResponse, error)
	ListTeamInviteLinks(context.Context, *ListTeamInviteLinksRequest) (*ListTeamInviteLinksResponse, error)
	UpdateUserName(context.Context, *UpdateUserNameRequest) (*UpdateUserNameResponse, error)
	ListInvoices(context.Context, *ListInvoicesRequest) (*ListInvoicesResponse, error)
	IsEligibleForRefund(context.Context, *IsEligibleForRefundRequest) (*IsEligibleForRefundResponse, error)
	GetRemainingRefunds(context.Context, *GetRemainingRefundsRequest) (*GetRemainingRefundsResponse, error)
	GetServiceAccountSpendLimit(context.Context, *GetServiceAccountSpendLimitRequest) (*GetServiceAccountSpendLimitResponse, error)
	SetServiceAccountSpendLimit(context.Context, *SetServiceAccountSpendLimitRequest) (*SetServiceAccountSpendLimitResponse, error)
	SetUserHardLimit(context.Context, *SetUserHardLimitRequest) (*SetUserHardLimitResponse, error)
	SetUserMonthlyLimit(context.Context, *SetUserMonthlyLimitRequest) (*SetUserMonthlyLimitResponse, error)
	ToggleMarketingEmailOpt(context.Context, *ToggleMarketingEmailOptRequest) (*ToggleMarketingEmailOptResponse, error)
	GetMarketingEmailOpt(context.Context, *GetMarketingEmailOptRequest) (*GetMarketingEmailOptResponse, error)
	GetGlobalLeaderboardOptIn(context.Context, *GetGlobalLeaderboardOptInRequest) (*GetGlobalLeaderboardOptInResponse, error)
	SetGlobalLeaderboardOptIn(context.Context, *SetGlobalLeaderboardOptInRequest) (*SetGlobalLeaderboardOptInResponse, error)
	CreateTeamApiKey(context.Context, *CreateTeamApiKeyRequest) (*CreateTeamApiKeyResponse, error)
	RevokeTeamApiKey(context.Context, *RevokeTeamApiKeyRequest) (*RevokeTeamApiKeyResponse, error)
	ListTeamApiKeys(context.Context, *ListTeamApiKeysRequest) (*ListTeamApiKeysResponse, error)
	CreateTeamServiceAccount(context.Context, *CreateTeamServiceAccountRequest) (*CreateTeamServiceAccountResponse, error)
	ListTeamServiceAccounts(context.Context, *ListTeamServiceAccountsRequest) (*ListTeamServiceAccountsResponse, error)
	DeleteTeamServiceAccount(context.Context, *DeleteTeamServiceAccountRequest) (*DeleteTeamServiceAccountResponse, error)
	ArchiveTeamServiceAccount(context.Context, *ArchiveTeamServiceAccountRequest) (*ArchiveTeamServiceAccountResponse, error)
	RotateServiceAccountApiKey(context.Context, *RotateServiceAccountApiKeyRequest) (*RotateServiceAccountApiKeyResponse, error)
	GetTeamRepositoriesForServiceAccountScope(context.Context, *GetTeamRepositoriesForServiceAccountScopeRequest) (*GetTeamRepositoriesForServiceAccountScopeResponse, error)
	UpdateServiceAccountRepoScope(context.Context, *UpdateServiceAccountRepoScopeRequest) (*UpdateServiceAccountRepoScopeResponse, error)
	CreateUserApiKey(context.Context, *CreateUserApiKeyRequest) (*CreateUserApiKeyResponse, error)
	RevokeUserApiKey(context.Context, *RevokeUserApiKeyRequest) (*RevokeUserApiKeyResponse, error)
	ListUserApiKeys(context.Context, *ListUserApiKeysRequest) (*ListUserApiKeysResponse, error)
	ConfirmGithubInstallation(context.Context, *ConfirmGithubInstallationRequest) (*ConfirmGithubInstallationResponse, error)
	UpdateTeamName(context.Context, *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error)
	UpdateTeamDashboardAnalyticsSetting(context.Context, *UpdateTeamDashboardAnalyticsSettingRequest) (*UpdateTeamDashboardAnalyticsSettingResponse, error)
	GetSlackUserSettings(context.Context, *GetSlackUserSettingsRequest) (*GetSlackUserSettingsResponse, error)
	UpdateSlackUserSettings(context.Context, *UpdateSlackUserSettingsRequest) (*UpdateSlackUserSettingsResponse, error)
	GetSlackRepoRoutingRules(context.Context, *GetSlackRepoRoutingRulesRequest) (*GetSlackRepoRoutingRulesResponse, error)
	CreateSlackRepoRoutingRule(context.Context, *CreateSlackRepoRoutingRuleRequest) (*CreateSlackRepoRoutingRuleResponse, error)
	UpdateSlackRepoRoutingRule(context.Context, *UpdateSlackRepoRoutingRuleRequest) (*UpdateSlackRepoRoutingRuleResponse, error)
	DeleteSlackRepoRoutingRule(context.Context, *DeleteSlackRepoRoutingRuleRequest) (*DeleteSlackRepoRoutingRuleResponse, error)
	IsOnNewPricing(context.Context, *IsOnNewPricingRequest) (*IsOnNewPricingResponse, error)
	GetLinearAuthUrl(context.Context, *GetLinearAuthUrlRequest) (*GetLinearAuthUrlResponse, error)
	GetLinearStatus(context.Context, *GetLinearStatusRequest) (*GetLinearStatusResponse, error)
	DisconnectLinear(context.Context, *DisconnectLinearRequest) (*DisconnectLinearResponse, error)
	GetLinearTeams(context.Context, *GetLinearTeamsRequest) (*GetLinearTeamsResponse, error)
	GetLinearSettings(context.Context, *GetLinearSettingsRequest) (*GetLinearSettingsResponse, error)
	UpdateLinearTeamSetting(context.Context, *UpdateLinearTeamSettingRequest) (*UpdateLinearTeamSettingResponse, error)
	UpdateLinearProjectSetting(context.Context, *UpdateLinearProjectSettingRequest) (*UpdateLinearProjectSettingResponse, error)
	GetLinearLabels(context.Context, *GetLinearLabelsRequest) (*GetLinearLabelsResponse, error)
	GetLinearIssues(context.Context, *GetLinearIssuesRequest) (*GetLinearIssuesResponse, error)
	DeleteBedrockIamRole(context.Context, *DeleteBedrockIamRoleRequest) (*DeleteBedrockIamRoleResponse, error)
	UnlinkSlackAccess(context.Context, *UnlinkSlackAccessRequest) (*UnlinkSlackAccessResponse, error)
	ListSlackConversations(context.Context, *ListSlackConversationsRequest) (*ListSlackConversationsResponse, error)
	LogSlackbotAuthConversionFunnel(context.Context, *LogSlackbotAuthConversionFunnelRequest) (*LogSlackbotAuthConversionFunnelResponse, error)
	LogClickedConnectSlack(context.Context, *LogClickedConnectSlackRequest) (*LogClickedConnectSlackResponse, error)
	CheckUserApiKeyAccess(context.Context, *CheckUserApiKeyAccessRequest) (*CheckUserApiKeyAccessResponse, error)
	IsAllowedFreeTrialUsage(context.Context, *IsAllowedFreeTrialUsageRequest) (*IsAllowedFreeTrialUsageResponse, error)
	CompletedLinkSlackAccount(context.Context, *CompletedLinkSlackAccountRequest) (*CompletedLinkSlackAccountResponse, error)
	NotifyTeamAdmins(context.Context, *NotifyTeamAdminsRequest) (*NotifyTeamAdminsResponse, error)
	GetAdminNotificationStatus(context.Context, *GetAdminNotificationStatusRequest) (*GetAdminNotificationStatusResponse, error)
	OptOutNewPricing(context.Context, *OptOutNewPricingRequest) (*OptOutNewPricingResponse, error)
	SubmitFeedback(context.Context, *SubmitFeedbackRequest) (*SubmitFeedbackResponse, error)
	CanStudentReverify(context.Context, *CanStudentReverifyRequest) (*CanStudentReverifyResponse, error)
	ClientAction(context.Context, *ClientActionRequest) (*ClientActionResponse, error)
	ListUsageAlerts(context.Context, *ListUsageAlertsRequest) (*ListUsageAlertsResponse, error)
	CreateUsageAlerts(context.Context, *CreateUsageAlertsRequest) (*CreateUsageAlertsResponse, error)
	DeleteUsageAlerts(context.Context, *DeleteUsageAlertsRequest) (*DeleteUsageAlertsResponse, error)
	UpdateUsageAlerts(context.Context, *UpdateUsageAlertsRequest) (*UpdateUsageAlertsResponse, error)
	RequestIndividualLimitsOptOut(context.Context, *RequestIndividualLimitsOptOutRequest) (*RequestIndividualLimitsOptOutResponse, error)
	mustEmbedUnimplementedDashboardServiceServer()
}

// UnimplementedDashboardServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDashboardServiceServer struct{}

func (UnimplementedDashboardServiceServer) GetTeams(context.Context, *GetTeamsRequest) (*GetTeamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeams not implemented")
}
func (UnimplementedDashboardServiceServer) GetMe(context.Context, *GetMeRequest) (*GetMeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedDashboardServiceServer) GetDirectoryGroups(context.Context, *GetDirectoryGroupsRequest) (*GetDirectoryGroupsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDirectoryGroups not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateDirectoryGroupSettings(context.Context, *UpdateDirectoryGroupSettingsRequest) (*UpdateDirectoryGroupSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDirectoryGroupSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetGroups(context.Context, *GetGroupsRequest) (*GetGroupsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGroups not implemented")
}
func (UnimplementedDashboardServiceServer) GetGroupMembers(context.Context, *GetGroupMembersRequest) (*GetGroupMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGroupMembers not implemented")
}
func (UnimplementedDashboardServiceServer) CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteGroup(context.Context, *DeleteGroupRequest) (*DeleteGroupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedDashboardServiceServer) AddGroupMembers(context.Context, *AddGroupMembersRequest) (*AddGroupMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddGroupMembers not implemented")
}
func (UnimplementedDashboardServiceServer) RemoveGroupMembers(context.Context, *RemoveGroupMembersRequest) (*RemoveGroupMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveGroupMembers not implemented")
}
func (UnimplementedDashboardServiceServer) BulkAssignGroupMembers(context.Context, *BulkAssignGroupMembersRequest) (*BulkAssignGroupMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BulkAssignGroupMembers not implemented")
}
func (UnimplementedDashboardServiceServer) PreviewAttachGroupToDirectory(context.Context, *PreviewAttachGroupToDirectoryRequest) (*PreviewAttachGroupToDirectoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PreviewAttachGroupToDirectory not implemented")
}
func (UnimplementedDashboardServiceServer) DetachGroupFromDirectory(context.Context, *DetachGroupFromDirectoryRequest) (*DetachGroupFromDirectoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachGroupFromDirectory not implemented")
}
func (UnimplementedDashboardServiceServer) GetScimConflicts(context.Context, *GetScimConflictsRequest) (*GetScimConflictsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScimConflicts not implemented")
}
func (UnimplementedDashboardServiceServer) GetActivationCheckoutUrl(context.Context, *GetActivationCheckoutUrlRequest) (*GetActivationCheckoutUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetActivationCheckoutUrl not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamCustomerPortalUrl(context.Context, *GetTeamCustomerPortalUrlRequest) (*GetTeamCustomerPortalUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamCustomerPortalUrl not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamMembers(context.Context, *GetTeamMembersRequest) (*GetTeamMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamMembers not implemented")
}
func (UnimplementedDashboardServiceServer) SendTeamInvite(context.Context, *SendTeamInviteRequest) (*SendTeamInviteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendTeamInvite not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamInviteLink(context.Context, *GetTeamInviteLinkRequest) (*GetTeamInviteLinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamInviteLink not implemented")
}
func (UnimplementedDashboardServiceServer) AcceptInvite(context.Context, *AcceptInviteRequest) (*AcceptInviteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptInvite not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeam(context.Context, *CreateTeamRequest) (*CreateTeamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeam not implemented")
}
func (UnimplementedDashboardServiceServer) GetJoinableTeamsByDomain(context.Context, *GetJoinableTeamsByDomainRequest) (*GetJoinableTeamsByDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetJoinableTeamsByDomain not implemented")
}
func (UnimplementedDashboardServiceServer) JoinTeamByDomain(context.Context, *JoinTeamByDomainRequest) (*JoinTeamByDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinTeamByDomain not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamDomainJoinSetting(context.Context, *UpdateTeamDomainJoinSettingRequest) (*UpdateTeamDomainJoinSettingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamDomainJoinSetting not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamMemberDomains(context.Context, *GetTeamMemberDomainsRequest) (*GetTeamMemberDomainsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamMemberDomains not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamIdForReactivation(context.Context, *GetTeamIdForReactivationRequest) (*GetTeamIdForReactivationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamIdForReactivation not implemented")
}
func (UnimplementedDashboardServiceServer) ChangeSeat(context.Context, *ChangeSeatRequest) (*ChangeSeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeSeat not implemented")
}
func (UnimplementedDashboardServiceServer) ChangeTeamSubscription(context.Context, *ChangeTeamSubscriptionRequest) (*ChangeTeamSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeTeamSubscription not implemented")
}
func (UnimplementedDashboardServiceServer) ConnectGithubCallback(context.Context, *ConnectGithubCallbackRequest) (*ConnectGithubCallbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConnectGithubCallback not implemented")
}
func (UnimplementedDashboardServiceServer) RegisterGithubCursorCode(context.Context, *RegisterGithubCursorCodeRequest) (*RegisterGithubCursorCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterGithubCursorCode not implemented")
}
func (UnimplementedDashboardServiceServer) DisconnectGithub(context.Context, *DisconnectGithubRequest) (*DisconnectGithubResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisconnectGithub not implemented")
}
func (UnimplementedDashboardServiceServer) PrepareSetupGithubEnterpriseApp(context.Context, *PrepareSetupGithubEnterpriseAppRequest) (*PrepareSetupGithubEnterpriseAppResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PrepareSetupGithubEnterpriseApp not implemented")
}
func (UnimplementedDashboardServiceServer) FinishSetupGithubEnterpriseApp(context.Context, *FinishSetupGithubEnterpriseAppRequest) (*FinishSetupGithubEnterpriseAppResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FinishSetupGithubEnterpriseApp not implemented")
}
func (UnimplementedDashboardServiceServer) ListGithubEnterpriseApps(context.Context, *ListGithubEnterpriseAppsRequest) (*ListGithubEnterpriseAppsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGithubEnterpriseApps not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteGithubEnterpriseApp(context.Context, *DeleteGithubEnterpriseAppRequest) (*DeleteGithubEnterpriseAppResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGithubEnterpriseApp not implemented")
}
func (UnimplementedDashboardServiceServer) SetupGitlabEnterpriseInstance(context.Context, *SetupGitlabEnterpriseInstanceRequest) (*SetupGitlabEnterpriseInstanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetupGitlabEnterpriseInstance not implemented")
}
func (UnimplementedDashboardServiceServer) ListGitlabEnterpriseInstances(context.Context, *ListGitlabEnterpriseInstancesRequest) (*ListGitlabEnterpriseInstancesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGitlabEnterpriseInstances not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteGitlabEnterpriseInstance(context.Context, *DeleteGitlabEnterpriseInstanceRequest) (*DeleteGitlabEnterpriseInstanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGitlabEnterpriseInstance not implemented")
}
func (UnimplementedDashboardServiceServer) SyncGitlabRepos(context.Context, *SyncGitlabReposRequest) (*SyncGitlabReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncGitlabRepos not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateRole(context.Context, *UpdateRoleRequest) (*UpdateRoleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedDashboardServiceServer) RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveMember not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamUsage(context.Context, *GetTeamUsageRequest) (*GetTeamUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamUsage not implemented")
}
func (UnimplementedDashboardServiceServer) GetSignUpType(context.Context, *GetSignUpTypeRequest) (*GetSignUpTypeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSignUpType not implemented")
}
func (UnimplementedDashboardServiceServer) GetHardLimit(context.Context, *GetHardLimitRequest) (*GetHardLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHardLimit not implemented")
}
func (UnimplementedDashboardServiceServer) SetHardLimit(context.Context, *SetHardLimitRequest) (*SetHardLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetHardLimit not implemented")
}
func (UnimplementedDashboardServiceServer) EnableOnDemandSpend(context.Context, *EnableOnDemandSpendRequest) (*EnableOnDemandSpendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableOnDemandSpend not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*DeleteAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedDashboardServiceServer) SendDownloadEmail(context.Context, *SendDownloadEmailRequest) (*SendDownloadEmailResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendDownloadEmail not implemented")
}
func (UnimplementedDashboardServiceServer) GetMonthlyInvoice(context.Context, *GetMonthlyInvoiceRequest) (*GetMonthlyInvoiceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMonthlyInvoice not implemented")
}
func (UnimplementedDashboardServiceServer) ListInvoiceCycles(context.Context, *ListInvoiceCyclesRequest) (*ListInvoiceCyclesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListInvoiceCycles not implemented")
}
func (UnimplementedDashboardServiceServer) GetDailySpendByCategory(context.Context, *GetDailySpendByCategoryRequest) (*GetDailySpendByCategoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDailySpendByCategory not implemented")
}
func (UnimplementedDashboardServiceServer) GetPricingHistory(context.Context, *GetPricingHistoryRequest) (*GetPricingHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPricingHistory not implemented")
}
func (UnimplementedDashboardServiceServer) ListBackgroundComposerSecrets(context.Context, *ListBackgroundComposerSecretsRequest) (*ListBackgroundComposerSecretsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBackgroundComposerSecrets not implemented")
}
func (UnimplementedDashboardServiceServer) CreateBackgroundComposerSecret(context.Context, *CreateBackgroundComposerSecretRequest) (*CreateBackgroundComposerSecretResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBackgroundComposerSecret not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeBackgroundComposerSecret(context.Context, *RevokeBackgroundComposerSecretRequest) (*RevokeBackgroundComposerSecretResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeBackgroundComposerSecret not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateBackgroundComposerSecret(context.Context, *UpdateBackgroundComposerSecretRequest) (*UpdateBackgroundComposerSecretResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBackgroundComposerSecret not implemented")
}
func (UnimplementedDashboardServiceServer) GetMcpConfig(context.Context, *GetMcpConfigRequest) (*GetMcpConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMcpConfig not implemented")
}
func (UnimplementedDashboardServiceServer) GetAvailableMcpServers(context.Context, *GetAvailableMcpServersRequest) (*GetAvailableMcpServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailableMcpServers not implemented")
}
func (UnimplementedDashboardServiceServer) SetMcpConfig(context.Context, *SetMcpConfigRequest) (*SetMcpConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetMcpConfig not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateUserDefaultMcpSettings(context.Context, *UpdateUserDefaultMcpSettingsRequest) (*UpdateUserDefaultMcpSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserDefaultMcpSettings not implemented")
}
func (UnimplementedDashboardServiceServer) StoreMcpOAuthToken(context.Context, *StoreMcpOAuthTokenRequest) (*StoreMcpOAuthTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StoreMcpOAuthToken not implemented")
}
func (UnimplementedDashboardServiceServer) ValidateMcpOAuthTokens(context.Context, *ValidateMcpOAuthTokensRequest) (*ValidateMcpOAuthTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateMcpOAuthTokens not implemented")
}
func (UnimplementedDashboardServiceServer) StoreMcpOAuthPendingState(context.Context, *StoreMcpOAuthPendingStateRequest) (*StoreMcpOAuthPendingStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StoreMcpOAuthPendingState not implemented")
}
func (UnimplementedDashboardServiceServer) GetMcpOAuthPendingState(context.Context, *GetMcpOAuthPendingStateRequest) (*GetMcpOAuthPendingStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMcpOAuthPendingState not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamWithFreeTrial(context.Context, *CreateTeamWithFreeTrialRequest) (*CreateTeamWithFreeTrialResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamWithFreeTrial not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamHasValidPaymentMethod(context.Context, *GetTeamHasValidPaymentMethodRequest) (*GetTeamHasValidPaymentMethodResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamHasValidPaymentMethod not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamPrivacyModeForced(context.Context, *GetTeamPrivacyModeForcedRequest) (*GetTeamPrivacyModeForcedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamPrivacyModeForced not implemented")
}
func (UnimplementedDashboardServiceServer) SwitchTeamPrivacyMode(context.Context, *SwitchTeamPrivacyModeRequest) (*SwitchTeamPrivacyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwitchTeamPrivacyMode not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateFastRequests(context.Context, *UpdateFastRequestsRequest) (*UpdateFastRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateFastRequests not implemented")
}
func (UnimplementedDashboardServiceServer) GetFastRequests(context.Context, *GetFastRequestsRequest) (*GetFastRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFastRequests not implemented")
}
func (UnimplementedDashboardServiceServer) GetDownloadLink(context.Context, *GetDownloadLinkRequest) (*GetDownloadLinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDownloadLink not implemented")
}
func (UnimplementedDashboardServiceServer) GetCliDownloadUrl(context.Context, *GetCliDownloadUrlRequest) (*GetCliDownloadUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCliDownloadUrl not implemented")
}
func (UnimplementedDashboardServiceServer) GetSsoConfigurationLinks(context.Context, *GetSsoConfigurationLinksRequest) (*GetSsoConfigurationLinksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSsoConfigurationLinks not implemented")
}
func (UnimplementedDashboardServiceServer) GetScimConfigurationLinks(context.Context, *GetScimConfigurationLinksRequest) (*GetScimConfigurationLinksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScimConfigurationLinks not implemented")
}
func (UnimplementedDashboardServiceServer) SetAdminOnlyUsagePricing(context.Context, *SetAdminOnlyUsagePricingRequest) (*SetAdminOnlyUsagePricingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetAdminOnlyUsagePricing not implemented")
}
func (UnimplementedDashboardServiceServer) GetYearlyUpgradeEligibility(context.Context, *GetYearlyUpgradeEligibilityRequest) (*GetYearlyUpgradeEligibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetYearlyUpgradeEligibility not implemented")
}
func (UnimplementedDashboardServiceServer) UpgradeToYearly(context.Context, *UpgradeToYearlyRequest) (*UpgradeToYearlyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpgradeToYearly not implemented")
}
func (UnimplementedDashboardServiceServer) GetEnterpriseCTAEligibility(context.Context, *GetEnterpriseCTAEligibilityRequest) (*GetEnterpriseCTAEligibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEnterpriseCTAEligibility not implemented")
}
func (UnimplementedDashboardServiceServer) GetUsageBasedPremiumRequests(context.Context, *GetUsageBasedPremiumRequestsRequest) (*GetUsageBasedPremiumRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUsageBasedPremiumRequests not implemented")
}
func (UnimplementedDashboardServiceServer) SetUsageBasedPremiumRequests(context.Context, *SetUsageBasedPremiumRequestsRequest) (*SetUsageBasedPremiumRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUsageBasedPremiumRequests not implemented")
}
func (UnimplementedDashboardServiceServer) GetReferrals(context.Context, *GetReferralsRequest) (*GetReferralsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetReferrals not implemented")
}
func (UnimplementedDashboardServiceServer) CheckReferralCode(context.Context, *CheckReferralCodeRequest) (*CheckReferralCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckReferralCode not implemented")
}
func (UnimplementedDashboardServiceServer) RedeemGiftCode(context.Context, *RedeemGiftCodeRequest) (*RedeemGiftCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RedeemGiftCode not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamRepos(context.Context, *GetTeamReposRequest) (*GetTeamReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamRepos not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamReposOrEmptyIfNotInTeam(context.Context, *GetTeamReposRequest) (*GetTeamReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamReposOrEmptyIfNotInTeam not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamRules(context.Context, *GetTeamRulesRequest) (*GetTeamRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamRules not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamRule(context.Context, *CreateTeamRuleRequest) (*CreateTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamRule(context.Context, *UpdateTeamRuleRequest) (*UpdateTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteTeamRule(context.Context, *DeleteTeamRuleRequest) (*DeleteTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamHooks(context.Context, *GetTeamHooksRequest) (*GetTeamHooksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamHooks not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamHook(context.Context, *CreateTeamHookRequest) (*CreateTeamHookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamHook not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamHook(context.Context, *UpdateTeamHookRequest) (*UpdateTeamHookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamHook not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteTeamHook(context.Context, *DeleteTeamHookRequest) (*DeleteTeamHookResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamHook not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamCommands(context.Context, *GetTeamCommandsRequest) (*GetTeamCommandsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamCommands not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamCommand(context.Context, *CreateTeamCommandRequest) (*CreateTeamCommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamCommand not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamCommand(context.Context, *UpdateTeamCommandRequest) (*UpdateTeamCommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamCommand not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteTeamCommand(context.Context, *DeleteTeamCommandRequest) (*DeleteTeamCommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamCommand not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugbotTeamRules(context.Context, *GetBugbotTeamRulesRequest) (*GetBugbotTeamRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugbotTeamRules not implemented")
}
func (UnimplementedDashboardServiceServer) CreateBugbotTeamRule(context.Context, *CreateBugbotTeamRuleRequest) (*CreateBugbotTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBugbotTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateBugbotTeamRule(context.Context, *UpdateBugbotTeamRuleRequest) (*UpdateBugbotTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBugbotTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteBugbotTeamRule(context.Context, *DeleteBugbotTeamRuleRequest) (*DeleteBugbotTeamRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteBugbotTeamRule not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugbotLearnedRules(context.Context, *GetBugbotLearnedRulesRequest) (*GetBugbotLearnedRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugbotLearnedRules not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateBugbotLearnedRule(context.Context, *UpdateBugbotLearnedRuleRequest) (*UpdateBugbotLearnedRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBugbotLearnedRule not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteBugbotLearnedRule(context.Context, *DeleteBugbotLearnedRuleRequest) (*DeleteBugbotLearnedRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteBugbotLearnedRule not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamRepo(context.Context, *CreateTeamRepoRequest) (*CreateTeamRepoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamRepo not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteTeamRepo(context.Context, *DeleteTeamRepoRequest) (*DeleteTeamRepoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamRepo not implemented")
}
func (UnimplementedDashboardServiceServer) AddRepoPattern(context.Context, *AddRepoPatternRequest) (*AddRepoPatternResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddRepoPattern not implemented")
}
func (UnimplementedDashboardServiceServer) RemoveRepoPattern(context.Context, *RemoveRepoPatternRequest) (*RemoveRepoPatternResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRepoPattern not implemented")
}
func (UnimplementedDashboardServiceServer) SetTeamRepoType(context.Context, *SetTeamRepoTypeRequest) (*SetTeamRepoTypeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetTeamRepoType not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamAdminSettings(context.Context, *GetTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamAdminSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamAdminSettingsOrEmptyIfNotInTeam(context.Context, *GetTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamAdminSettingsOrEmptyIfNotInTeam not implemented")
}
func (UnimplementedDashboardServiceServer) GetBaseTeamAdminSettings(context.Context, *GetBaseTeamAdminSettingsRequest) (*GetTeamAdminSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBaseTeamAdminSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamAdminSettings(context.Context, *UpdateTeamAdminSettingsRequest) (*UpdateTeamAdminSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamAdminSettings not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamFreeTrialCode(context.Context, *CreateTeamFreeTrialCodeRequest) (*CreateTeamFreeTrialCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamFreeTrialCode not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamAnalytics(context.Context, *GetTeamAnalyticsRequest) (*GetTeamAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamAnalytics not implemented")
}
func (UnimplementedDashboardServiceServer) GetUserAnalytics(context.Context, *GetUserAnalyticsRequest) (*GetUserAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserAnalytics not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamRawData(context.Context, *GetTeamRawDataRequest) (*GetTeamRawDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamRawData not implemented")
}
func (UnimplementedDashboardServiceServer) GetClientUsageData(context.Context, *GetClientUsageDataRequest) (*GetClientUsageDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClientUsageData not implemented")
}
func (UnimplementedDashboardServiceServer) GetCurrentPeriodUsage(context.Context, *GetCurrentPeriodUsageRequest) (*GetCurrentPeriodUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCurrentPeriodUsage not implemented")
}
func (UnimplementedDashboardServiceServer) GetPlanInfo(context.Context, *GetPlanInfoRequest) (*GetPlanInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlanInfo not implemented")
}
func (UnimplementedDashboardServiceServer) GetUsageLimitPolicyStatus(context.Context, *GetUsageLimitPolicyStatusRequest) (*GetUsageLimitPolicyStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUsageLimitPolicyStatus not implemented")
}
func (UnimplementedDashboardServiceServer) GetAdvancedAnalyticsEnabled(context.Context, *GetAdvancedAnalyticsEnabledRequest) (*GetAdvancedAnalyticsEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAdvancedAnalyticsEnabled not implemented")
}
func (UnimplementedDashboardServiceServer) GetTokenUsage(context.Context, *GetTokenUsageRequest) (*GetTokenUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTokenUsage not implemented")
}
func (UnimplementedDashboardServiceServer) ValidateBedrockIamRole(context.Context, *ValidateBedrockIamRoleRequest) (*ValidateBedrockIamRoleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateBedrockIamRole not implemented")
}
func (UnimplementedDashboardServiceServer) AddUserToEarlyAccessList(context.Context, *AddUserToEarlyAccessListRequest) (*AddUserToEarlyAccessListResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddUserToEarlyAccessList not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamSpend(context.Context, *GetTeamSpendRequest) (*GetTeamSpendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamSpend not implemented")
}
func (UnimplementedDashboardServiceServer) GetCurrentBillingCycle(context.Context, *GetCurrentBillingCycleRequest) (*GetCurrentBillingCycleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCurrentBillingCycle not implemented")
}
func (UnimplementedDashboardServiceServer) GetMonthlyBillingCycle(context.Context, *GetMonthlyBillingCycleRequest) (*GetMonthlyBillingCycleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMonthlyBillingCycle not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugbotSettings(context.Context, *GetBugbotSettingsRequest) (*GetBugbotSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugbotSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugbotAnalyticsV2(context.Context, *GetBugbotAnalyticsV2Request) (*GetBugbotAnalyticsV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugbotAnalyticsV2 not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugBotPRAnalytics(context.Context, *GetBugBotPRAnalyticsRequest) (*GetBugBotPRAnalyticsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugBotPRAnalytics not implemented")
}
func (UnimplementedDashboardServiceServer) GetGithubInstallations(context.Context, *GetGithubInstallationsRequest) (*GetGithubInstallationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGithubInstallations not implemented")
}
func (UnimplementedDashboardServiceServer) GetInstallationRepos(context.Context, *GetInstallationReposRequest) (*GetInstallationReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInstallationRepos not implemented")
}
func (UnimplementedDashboardServiceServer) FetchAllInstallationRepos(context.Context, *FetchAllInstallationReposRequest) (*FetchAllInstallationReposResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FetchAllInstallationRepos not implemented")
}
func (UnimplementedDashboardServiceServer) GetInstallationGithubUsers(context.Context, *GetInstallationGithubUsersRequest) (*GetInstallationGithubUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInstallationGithubUsers not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamGithubUsers(context.Context, *GetTeamGithubUsersRequest) (*GetTeamGithubUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamGithubUsers not implemented")
}
func (UnimplementedDashboardServiceServer) AddGithubUsersToTeam(context.Context, *AddGithubUsersToTeamRequest) (*AddGithubUsersToTeamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddGithubUsersToTeam not implemented")
}
func (UnimplementedDashboardServiceServer) GetUserPullRequests(context.Context, *GetUserPullRequestsRequest) (*GetUserPullRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserPullRequests not implemented")
}
func (UnimplementedDashboardServiceServer) GetUserReviewRequests(context.Context, *GetUserReviewRequestsRequest) (*GetUserReviewRequestsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserReviewRequests not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateGithubRepoSettings(context.Context, *UpdateGithubRepoSettingsRequest) (*UpdateGithubRepoSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGithubRepoSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateGithubInstallationSettings(context.Context, *UpdateGithubInstallationSettingsRequest) (*UpdateGithubInstallationSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGithubInstallationSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateAllGithubRepoSettings(context.Context, *UpdateAllGithubRepoSettingsRequest) (*UpdateAllGithubRepoSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateAllGithubRepoSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateGithubInstallationTeamScope(context.Context, *UpdateGithubInstallationTeamScopeRequest) (*UpdateGithubInstallationTeamScopeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGithubInstallationTeamScope not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateSelfGithubAllowlist(context.Context, *UpdateSelfGithubAllowlistRequest) (*UpdateSelfGithubAllowlistResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSelfGithubAllowlist not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamBugbotSettings(context.Context, *GetTeamBugbotSettingsRequest) (*GetTeamBugbotSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamBugbotSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamBugbotSettings(context.Context, *UpdateTeamBugbotSettingsRequest) (*UpdateTeamBugbotSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamBugbotSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugbotUserSettings(context.Context, *GetBugbotUserSettingsRequest) (*GetBugbotUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugbotUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateBugbotUserSettings(context.Context, *UpdateBugbotUserSettingsRequest) (*UpdateBugbotUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBugbotUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetBugBotProUserSettings(context.Context, *GetBugBotProUserSettingsRequest) (*GetBugBotProUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBugBotProUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateBugBotProUserSettings(context.Context, *UpdateBugBotProUserSettingsRequest) (*UpdateBugBotProUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBugBotProUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) RecordBugbotDeeplinkEvent(context.Context, *RecordBugbotDeeplinkEventRequest) (*RecordBugbotDeeplinkEventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordBugbotDeeplinkEvent not implemented")
}
func (UnimplementedDashboardServiceServer) RecordBugbotDeeplinkEventUnauthenticated(context.Context, *RecordBugbotDeeplinkEventRequest) (*RecordBugbotDeeplinkEventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordBugbotDeeplinkEventUnauthenticated not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeBugBotLicenses(context.Context, *RevokeBugBotLicensesRequest) (*RevokeBugBotLicensesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeBugBotLicenses not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeUserBugbotLicense(context.Context, *RevokeUserBugbotLicenseRequest) (*RevokeUserBugbotLicenseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeUserBugbotLicense not implemented")
}
func (UnimplementedDashboardServiceServer) StartBugbotBackfillLearning(context.Context, *StartBugbotBackfillLearningRequest) (*StartBugbotBackfillLearningResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartBugbotBackfillLearning not implemented")
}
func (UnimplementedDashboardServiceServer) SetSlackAuth(context.Context, *SetSlackAuthRequest) (*SetSlackAuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSlackAuth not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackTeamSettings(context.Context, *GetSlackTeamSettingsRequest) (*GetSlackTeamSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackTeamSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateSlackTeamSettings(context.Context, *UpdateSlackTeamSettingsRequest) (*UpdateSlackTeamSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSlackTeamSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackSettings(context.Context, *GetSlackSettingsRequest) (*GetSlackSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackModelOptions(context.Context, *GetSlackModelOptionsRequest) (*GetSlackModelOptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackModelOptions not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackInstallUrl(context.Context, *GetSlackInstallUrlRequest) (*GetSlackInstallUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackInstallUrl not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackInstallUrlPublic(context.Context, *GetPublicSlackInstallUrlRequest) (*GetPublicSlackInstallUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackInstallUrlPublic not implemented")
}
func (UnimplementedDashboardServiceServer) GetFilteredUsageEvents(context.Context, *GetFilteredUsageEventsRequest) (*GetFilteredUsageEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFilteredUsageEvents not implemented")
}
func (UnimplementedDashboardServiceServer) GetAggregatedUsageEvents(context.Context, *GetAggregatedUsageEventsRequest) (*GetAggregatedUsageEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAggregatedUsageEvents not implemented")
}
func (UnimplementedDashboardServiceServer) GetAuditLogs(context.Context, *GetAuditLogsRequest) (*GetAuditLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAuditLogs not implemented")
}
func (UnimplementedDashboardServiceServer) GetUserPrivacyMode(context.Context, *GetUserPrivacyModeRequest) (*GetUserPrivacyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserPrivacyMode not implemented")
}
func (UnimplementedDashboardServiceServer) SetUserPrivacyMode(context.Context, *SetUserPrivacyModeRequest) (*SetUserPrivacyModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUserPrivacyMode not implemented")
}
func (UnimplementedDashboardServiceServer) WebAcknowledgeGracePeriodDisclaimer(context.Context, *WebAcknowledgeGracePeriodDisclaimerRequest) (*WebAcknowledgeGracePeriodDisclaimerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WebAcknowledgeGracePeriodDisclaimer not implemented")
}
func (UnimplementedDashboardServiceServer) SkipPrivacyModeGracePeriod(context.Context, *SkipPrivacyModeGracePeriodRequest) (*SkipPrivacyModeGracePeriodResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SkipPrivacyModeGracePeriod not implemented")
}
func (UnimplementedDashboardServiceServer) NeedsPrivacyModeMigration(context.Context, *NeedsPrivacyModeMigrationRequest) (*NeedsPrivacyModeMigrationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NeedsPrivacyModeMigration not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamPrivacyModeMigrationOptOut(context.Context, *UpdateTeamPrivacyModeMigrationOptOutRequest) (*UpdateTeamPrivacyModeMigrationOptOutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamPrivacyModeMigrationOptOut not implemented")
}
func (UnimplementedDashboardServiceServer) ShareConversation(context.Context, *ShareConversationRequest) (*ShareConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShareConversation not implemented")
}
func (UnimplementedDashboardServiceServer) GetSharedConversation(context.Context, *GetSharedConversationRequest) (*GetSharedConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSharedConversation not implemented")
}
func (UnimplementedDashboardServiceServer) GetPublicSharedConversation(context.Context, *GetPublicSharedConversationRequest) (*GetPublicSharedConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPublicSharedConversation not implemented")
}
func (UnimplementedDashboardServiceServer) ListSharedConversations(context.Context, *ListSharedConversationsRequest) (*ListSharedConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSharedConversations not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteSharedConversation(context.Context, *DeleteSharedConversationRequest) (*DeleteSharedConversationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSharedConversation not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateSharedConversationVisibility(context.Context, *UpdateSharedConversationVisibilityRequest) (*UpdateSharedConversationVisibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSharedConversationVisibility not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeTeamInviteLink(context.Context, *RevokeTeamInviteLinkRequest) (*RevokeTeamInviteLinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeTeamInviteLink not implemented")
}
func (UnimplementedDashboardServiceServer) ListTeamInviteLinks(context.Context, *ListTeamInviteLinksRequest) (*ListTeamInviteLinksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTeamInviteLinks not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateUserName(context.Context, *UpdateUserNameRequest) (*UpdateUserNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUserName not implemented")
}
func (UnimplementedDashboardServiceServer) ListInvoices(context.Context, *ListInvoicesRequest) (*ListInvoicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListInvoices not implemented")
}
func (UnimplementedDashboardServiceServer) IsEligibleForRefund(context.Context, *IsEligibleForRefundRequest) (*IsEligibleForRefundResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsEligibleForRefund not implemented")
}
func (UnimplementedDashboardServiceServer) GetRemainingRefunds(context.Context, *GetRemainingRefundsRequest) (*GetRemainingRefundsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRemainingRefunds not implemented")
}
func (UnimplementedDashboardServiceServer) GetServiceAccountSpendLimit(context.Context, *GetServiceAccountSpendLimitRequest) (*GetServiceAccountSpendLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServiceAccountSpendLimit not implemented")
}
func (UnimplementedDashboardServiceServer) SetServiceAccountSpendLimit(context.Context, *SetServiceAccountSpendLimitRequest) (*SetServiceAccountSpendLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetServiceAccountSpendLimit not implemented")
}
func (UnimplementedDashboardServiceServer) SetUserHardLimit(context.Context, *SetUserHardLimitRequest) (*SetUserHardLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUserHardLimit not implemented")
}
func (UnimplementedDashboardServiceServer) SetUserMonthlyLimit(context.Context, *SetUserMonthlyLimitRequest) (*SetUserMonthlyLimitResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetUserMonthlyLimit not implemented")
}
func (UnimplementedDashboardServiceServer) ToggleMarketingEmailOpt(context.Context, *ToggleMarketingEmailOptRequest) (*ToggleMarketingEmailOptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ToggleMarketingEmailOpt not implemented")
}
func (UnimplementedDashboardServiceServer) GetMarketingEmailOpt(context.Context, *GetMarketingEmailOptRequest) (*GetMarketingEmailOptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMarketingEmailOpt not implemented")
}
func (UnimplementedDashboardServiceServer) GetGlobalLeaderboardOptIn(context.Context, *GetGlobalLeaderboardOptInRequest) (*GetGlobalLeaderboardOptInResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGlobalLeaderboardOptIn not implemented")
}
func (UnimplementedDashboardServiceServer) SetGlobalLeaderboardOptIn(context.Context, *SetGlobalLeaderboardOptInRequest) (*SetGlobalLeaderboardOptInResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetGlobalLeaderboardOptIn not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamApiKey(context.Context, *CreateTeamApiKeyRequest) (*CreateTeamApiKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamApiKey not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeTeamApiKey(context.Context, *RevokeTeamApiKeyRequest) (*RevokeTeamApiKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeTeamApiKey not implemented")
}
func (UnimplementedDashboardServiceServer) ListTeamApiKeys(context.Context, *ListTeamApiKeysRequest) (*ListTeamApiKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTeamApiKeys not implemented")
}
func (UnimplementedDashboardServiceServer) CreateTeamServiceAccount(context.Context, *CreateTeamServiceAccountRequest) (*CreateTeamServiceAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeamServiceAccount not implemented")
}
func (UnimplementedDashboardServiceServer) ListTeamServiceAccounts(context.Context, *ListTeamServiceAccountsRequest) (*ListTeamServiceAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTeamServiceAccounts not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteTeamServiceAccount(context.Context, *DeleteTeamServiceAccountRequest) (*DeleteTeamServiceAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeamServiceAccount not implemented")
}
func (UnimplementedDashboardServiceServer) ArchiveTeamServiceAccount(context.Context, *ArchiveTeamServiceAccountRequest) (*ArchiveTeamServiceAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ArchiveTeamServiceAccount not implemented")
}
func (UnimplementedDashboardServiceServer) RotateServiceAccountApiKey(context.Context, *RotateServiceAccountApiKeyRequest) (*RotateServiceAccountApiKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RotateServiceAccountApiKey not implemented")
}
func (UnimplementedDashboardServiceServer) GetTeamRepositoriesForServiceAccountScope(context.Context, *GetTeamRepositoriesForServiceAccountScopeRequest) (*GetTeamRepositoriesForServiceAccountScopeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamRepositoriesForServiceAccountScope not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateServiceAccountRepoScope(context.Context, *UpdateServiceAccountRepoScopeRequest) (*UpdateServiceAccountRepoScopeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateServiceAccountRepoScope not implemented")
}
func (UnimplementedDashboardServiceServer) CreateUserApiKey(context.Context, *CreateUserApiKeyRequest) (*CreateUserApiKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUserApiKey not implemented")
}
func (UnimplementedDashboardServiceServer) RevokeUserApiKey(context.Context, *RevokeUserApiKeyRequest) (*RevokeUserApiKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeUserApiKey not implemented")
}
func (UnimplementedDashboardServiceServer) ListUserApiKeys(context.Context, *ListUserApiKeysRequest) (*ListUserApiKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUserApiKeys not implemented")
}
func (UnimplementedDashboardServiceServer) ConfirmGithubInstallation(context.Context, *ConfirmGithubInstallationRequest) (*ConfirmGithubInstallationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfirmGithubInstallation not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamName(context.Context, *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamName not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateTeamDashboardAnalyticsSetting(context.Context, *UpdateTeamDashboardAnalyticsSettingRequest) (*UpdateTeamDashboardAnalyticsSettingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamDashboardAnalyticsSetting not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackUserSettings(context.Context, *GetSlackUserSettingsRequest) (*GetSlackUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateSlackUserSettings(context.Context, *UpdateSlackUserSettingsRequest) (*UpdateSlackUserSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSlackUserSettings not implemented")
}
func (UnimplementedDashboardServiceServer) GetSlackRepoRoutingRules(context.Context, *GetSlackRepoRoutingRulesRequest) (*GetSlackRepoRoutingRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSlackRepoRoutingRules not implemented")
}
func (UnimplementedDashboardServiceServer) CreateSlackRepoRoutingRule(context.Context, *CreateSlackRepoRoutingRuleRequest) (*CreateSlackRepoRoutingRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSlackRepoRoutingRule not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateSlackRepoRoutingRule(context.Context, *UpdateSlackRepoRoutingRuleRequest) (*UpdateSlackRepoRoutingRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSlackRepoRoutingRule not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteSlackRepoRoutingRule(context.Context, *DeleteSlackRepoRoutingRuleRequest) (*DeleteSlackRepoRoutingRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSlackRepoRoutingRule not implemented")
}
func (UnimplementedDashboardServiceServer) IsOnNewPricing(context.Context, *IsOnNewPricingRequest) (*IsOnNewPricingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsOnNewPricing not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearAuthUrl(context.Context, *GetLinearAuthUrlRequest) (*GetLinearAuthUrlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearAuthUrl not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearStatus(context.Context, *GetLinearStatusRequest) (*GetLinearStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearStatus not implemented")
}
func (UnimplementedDashboardServiceServer) DisconnectLinear(context.Context, *DisconnectLinearRequest) (*DisconnectLinearResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisconnectLinear not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearTeams(context.Context, *GetLinearTeamsRequest) (*GetLinearTeamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearTeams not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearSettings(context.Context, *GetLinearSettingsRequest) (*GetLinearSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearSettings not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateLinearTeamSetting(context.Context, *UpdateLinearTeamSettingRequest) (*UpdateLinearTeamSettingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateLinearTeamSetting not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateLinearProjectSetting(context.Context, *UpdateLinearProjectSettingRequest) (*UpdateLinearProjectSettingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateLinearProjectSetting not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearLabels(context.Context, *GetLinearLabelsRequest) (*GetLinearLabelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearLabels not implemented")
}
func (UnimplementedDashboardServiceServer) GetLinearIssues(context.Context, *GetLinearIssuesRequest) (*GetLinearIssuesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinearIssues not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteBedrockIamRole(context.Context, *DeleteBedrockIamRoleRequest) (*DeleteBedrockIamRoleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteBedrockIamRole not implemented")
}
func (UnimplementedDashboardServiceServer) UnlinkSlackAccess(context.Context, *UnlinkSlackAccessRequest) (*UnlinkSlackAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnlinkSlackAccess not implemented")
}
func (UnimplementedDashboardServiceServer) ListSlackConversations(context.Context, *ListSlackConversationsRequest) (*ListSlackConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSlackConversations not implemented")
}
func (UnimplementedDashboardServiceServer) LogSlackbotAuthConversionFunnel(context.Context, *LogSlackbotAuthConversionFunnelRequest) (*LogSlackbotAuthConversionFunnelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogSlackbotAuthConversionFunnel not implemented")
}
func (UnimplementedDashboardServiceServer) LogClickedConnectSlack(context.Context, *LogClickedConnectSlackRequest) (*LogClickedConnectSlackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogClickedConnectSlack not implemented")
}
func (UnimplementedDashboardServiceServer) CheckUserApiKeyAccess(context.Context, *CheckUserApiKeyAccessRequest) (*CheckUserApiKeyAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckUserApiKeyAccess not implemented")
}
func (UnimplementedDashboardServiceServer) IsAllowedFreeTrialUsage(context.Context, *IsAllowedFreeTrialUsageRequest) (*IsAllowedFreeTrialUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsAllowedFreeTrialUsage not implemented")
}
func (UnimplementedDashboardServiceServer) CompletedLinkSlackAccount(context.Context, *CompletedLinkSlackAccountRequest) (*CompletedLinkSlackAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompletedLinkSlackAccount not implemented")
}
func (UnimplementedDashboardServiceServer) NotifyTeamAdmins(context.Context, *NotifyTeamAdminsRequest) (*NotifyTeamAdminsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NotifyTeamAdmins not implemented")
}
func (UnimplementedDashboardServiceServer) GetAdminNotificationStatus(context.Context, *GetAdminNotificationStatusRequest) (*GetAdminNotificationStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAdminNotificationStatus not implemented")
}
func (UnimplementedDashboardServiceServer) OptOutNewPricing(context.Context, *OptOutNewPricingRequest) (*OptOutNewPricingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method OptOutNewPricing not implemented")
}
func (UnimplementedDashboardServiceServer) SubmitFeedback(context.Context, *SubmitFeedbackRequest) (*SubmitFeedbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitFeedback not implemented")
}
func (UnimplementedDashboardServiceServer) CanStudentReverify(context.Context, *CanStudentReverifyRequest) (*CanStudentReverifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CanStudentReverify not implemented")
}
func (UnimplementedDashboardServiceServer) ClientAction(context.Context, *ClientActionRequest) (*ClientActionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClientAction not implemented")
}
func (UnimplementedDashboardServiceServer) ListUsageAlerts(context.Context, *ListUsageAlertsRequest) (*ListUsageAlertsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUsageAlerts not implemented")
}
func (UnimplementedDashboardServiceServer) CreateUsageAlerts(context.Context, *CreateUsageAlertsRequest) (*CreateUsageAlertsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUsageAlerts not implemented")
}
func (UnimplementedDashboardServiceServer) DeleteUsageAlerts(context.Context, *DeleteUsageAlertsRequest) (*DeleteUsageAlertsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteUsageAlerts not implemented")
}
func (UnimplementedDashboardServiceServer) UpdateUsageAlerts(context.Context, *UpdateUsageAlertsRequest) (*UpdateUsageAlertsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUsageAlerts not implemented")
}
func (UnimplementedDashboardServiceServer) RequestIndividualLimitsOptOut(context.Context, *RequestIndividualLimitsOptOutRequest) (*RequestIndividualLimitsOptOutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestIndividualLimitsOptOut not implemented")
}
func (UnimplementedDashboardServiceServer) mustEmbedUnimplementedDashboardServiceServer() {}
func (UnimplementedDashboardServiceServer) testEmbeddedByValue()                          {}

// UnsafeDashboardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DashboardServiceServer will
// result in compilation errors.
type UnsafeDashboardServiceServer interface {
	mustEmbedUnimplementedDashboardServiceServer()
}

func RegisterDashboardServiceServer(s grpc.ServiceRegistrar, srv DashboardServiceServer) {
	// If the following call panics, it indicates UnimplementedDashboardServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DashboardService_ServiceDesc, srv)
}

func _DashboardService_GetTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeams(ctx, req.(*GetTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMe(ctx, req.(*GetMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetDirectoryGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDirectoryGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetDirectoryGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetDirectoryGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetDirectoryGroups(ctx, req.(*GetDirectoryGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateDirectoryGroupSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDirectoryGroupSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateDirectoryGroupSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateDirectoryGroupSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateDirectoryGroupSettings(ctx, req.(*UpdateDirectoryGroupSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetGroups(ctx, req.(*GetGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetGroupMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetGroupMembers(ctx, req.(*GetGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateGroup(ctx, req.(*UpdateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteGroup(ctx, req.(*DeleteGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_AddGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).AddGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_AddGroupMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).AddGroupMembers(ctx, req.(*AddGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RemoveGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RemoveGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RemoveGroupMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RemoveGroupMembers(ctx, req.(*RemoveGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_BulkAssignGroupMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAssignGroupMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).BulkAssignGroupMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_BulkAssignGroupMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).BulkAssignGroupMembers(ctx, req.(*BulkAssignGroupMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_PreviewAttachGroupToDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreviewAttachGroupToDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).PreviewAttachGroupToDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_PreviewAttachGroupToDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).PreviewAttachGroupToDirectory(ctx, req.(*PreviewAttachGroupToDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DetachGroupFromDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachGroupFromDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DetachGroupFromDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DetachGroupFromDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DetachGroupFromDirectory(ctx, req.(*DetachGroupFromDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetScimConflicts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScimConflictsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetScimConflicts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetScimConflicts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetScimConflicts(ctx, req.(*GetScimConflictsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetActivationCheckoutUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActivationCheckoutUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetActivationCheckoutUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetActivationCheckoutUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetActivationCheckoutUrl(ctx, req.(*GetActivationCheckoutUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamCustomerPortalUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamCustomerPortalUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamCustomerPortalUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamCustomerPortalUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamCustomerPortalUrl(ctx, req.(*GetTeamCustomerPortalUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamMembers(ctx, req.(*GetTeamMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SendTeamInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTeamInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SendTeamInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SendTeamInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SendTeamInvite(ctx, req.(*SendTeamInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamInviteLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamInviteLink(ctx, req.(*GetTeamInviteLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_AcceptInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).AcceptInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_AcceptInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).AcceptInvite(ctx, req.(*AcceptInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeam(ctx, req.(*CreateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetJoinableTeamsByDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJoinableTeamsByDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetJoinableTeamsByDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetJoinableTeamsByDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetJoinableTeamsByDomain(ctx, req.(*GetJoinableTeamsByDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_JoinTeamByDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinTeamByDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).JoinTeamByDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_JoinTeamByDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).JoinTeamByDomain(ctx, req.(*JoinTeamByDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamDomainJoinSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamDomainJoinSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamDomainJoinSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamDomainJoinSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamDomainJoinSetting(ctx, req.(*UpdateTeamDomainJoinSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamMemberDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamMemberDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamMemberDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamMemberDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamMemberDomains(ctx, req.(*GetTeamMemberDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamIdForReactivation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamIdForReactivationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamIdForReactivation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamIdForReactivation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamIdForReactivation(ctx, req.(*GetTeamIdForReactivationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ChangeSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeSeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ChangeSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ChangeSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ChangeSeat(ctx, req.(*ChangeSeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ChangeTeamSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeTeamSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ChangeTeamSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ChangeTeamSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ChangeTeamSubscription(ctx, req.(*ChangeTeamSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ConnectGithubCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectGithubCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ConnectGithubCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ConnectGithubCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ConnectGithubCallback(ctx, req.(*ConnectGithubCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RegisterGithubCursorCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterGithubCursorCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RegisterGithubCursorCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RegisterGithubCursorCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RegisterGithubCursorCode(ctx, req.(*RegisterGithubCursorCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DisconnectGithub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectGithubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DisconnectGithub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DisconnectGithub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DisconnectGithub(ctx, req.(*DisconnectGithubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_PrepareSetupGithubEnterpriseApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareSetupGithubEnterpriseAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).PrepareSetupGithubEnterpriseApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_PrepareSetupGithubEnterpriseApp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).PrepareSetupGithubEnterpriseApp(ctx, req.(*PrepareSetupGithubEnterpriseAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_FinishSetupGithubEnterpriseApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishSetupGithubEnterpriseAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).FinishSetupGithubEnterpriseApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_FinishSetupGithubEnterpriseApp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).FinishSetupGithubEnterpriseApp(ctx, req.(*FinishSetupGithubEnterpriseAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListGithubEnterpriseApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGithubEnterpriseAppsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListGithubEnterpriseApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListGithubEnterpriseApps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListGithubEnterpriseApps(ctx, req.(*ListGithubEnterpriseAppsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteGithubEnterpriseApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGithubEnterpriseAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteGithubEnterpriseApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteGithubEnterpriseApp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteGithubEnterpriseApp(ctx, req.(*DeleteGithubEnterpriseAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetupGitlabEnterpriseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupGitlabEnterpriseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetupGitlabEnterpriseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetupGitlabEnterpriseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetupGitlabEnterpriseInstance(ctx, req.(*SetupGitlabEnterpriseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListGitlabEnterpriseInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGitlabEnterpriseInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListGitlabEnterpriseInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListGitlabEnterpriseInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListGitlabEnterpriseInstances(ctx, req.(*ListGitlabEnterpriseInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteGitlabEnterpriseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGitlabEnterpriseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteGitlabEnterpriseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteGitlabEnterpriseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteGitlabEnterpriseInstance(ctx, req.(*DeleteGitlabEnterpriseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SyncGitlabRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncGitlabReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SyncGitlabRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SyncGitlabRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SyncGitlabRepos(ctx, req.(*SyncGitlabReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateRole(ctx, req.(*UpdateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RemoveMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RemoveMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RemoveMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RemoveMember(ctx, req.(*RemoveMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamUsage(ctx, req.(*GetTeamUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSignUpType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSignUpTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSignUpType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSignUpType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSignUpType(ctx, req.(*GetSignUpTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetHardLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHardLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetHardLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetHardLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetHardLimit(ctx, req.(*GetHardLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetHardLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHardLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetHardLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetHardLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetHardLimit(ctx, req.(*SetHardLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_EnableOnDemandSpend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableOnDemandSpendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).EnableOnDemandSpend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_EnableOnDemandSpend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).EnableOnDemandSpend(ctx, req.(*EnableOnDemandSpendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SendDownloadEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDownloadEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SendDownloadEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SendDownloadEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SendDownloadEmail(ctx, req.(*SendDownloadEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMonthlyInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMonthlyInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMonthlyInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMonthlyInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMonthlyInvoice(ctx, req.(*GetMonthlyInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListInvoiceCycles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoiceCyclesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListInvoiceCycles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListInvoiceCycles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListInvoiceCycles(ctx, req.(*ListInvoiceCyclesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetDailySpendByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDailySpendByCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetDailySpendByCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetDailySpendByCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetDailySpendByCategory(ctx, req.(*GetDailySpendByCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetPricingHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPricingHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetPricingHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetPricingHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetPricingHistory(ctx, req.(*GetPricingHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListBackgroundComposerSecrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackgroundComposerSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListBackgroundComposerSecrets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListBackgroundComposerSecrets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListBackgroundComposerSecrets(ctx, req.(*ListBackgroundComposerSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateBackgroundComposerSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBackgroundComposerSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateBackgroundComposerSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateBackgroundComposerSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateBackgroundComposerSecret(ctx, req.(*CreateBackgroundComposerSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeBackgroundComposerSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeBackgroundComposerSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeBackgroundComposerSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeBackgroundComposerSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeBackgroundComposerSecret(ctx, req.(*RevokeBackgroundComposerSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateBackgroundComposerSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBackgroundComposerSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateBackgroundComposerSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateBackgroundComposerSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateBackgroundComposerSecret(ctx, req.(*UpdateBackgroundComposerSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMcpConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMcpConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMcpConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMcpConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMcpConfig(ctx, req.(*GetMcpConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAvailableMcpServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableMcpServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAvailableMcpServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAvailableMcpServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAvailableMcpServers(ctx, req.(*GetAvailableMcpServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetMcpConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMcpConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetMcpConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetMcpConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetMcpConfig(ctx, req.(*SetMcpConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateUserDefaultMcpSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserDefaultMcpSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateUserDefaultMcpSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateUserDefaultMcpSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateUserDefaultMcpSettings(ctx, req.(*UpdateUserDefaultMcpSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_StoreMcpOAuthToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreMcpOAuthTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).StoreMcpOAuthToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_StoreMcpOAuthToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).StoreMcpOAuthToken(ctx, req.(*StoreMcpOAuthTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ValidateMcpOAuthTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateMcpOAuthTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ValidateMcpOAuthTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ValidateMcpOAuthTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ValidateMcpOAuthTokens(ctx, req.(*ValidateMcpOAuthTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_StoreMcpOAuthPendingState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreMcpOAuthPendingStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).StoreMcpOAuthPendingState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_StoreMcpOAuthPendingState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).StoreMcpOAuthPendingState(ctx, req.(*StoreMcpOAuthPendingStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMcpOAuthPendingState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMcpOAuthPendingStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMcpOAuthPendingState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMcpOAuthPendingState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMcpOAuthPendingState(ctx, req.(*GetMcpOAuthPendingStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamWithFreeTrial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamWithFreeTrialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamWithFreeTrial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamWithFreeTrial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamWithFreeTrial(ctx, req.(*CreateTeamWithFreeTrialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamHasValidPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamHasValidPaymentMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamHasValidPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamHasValidPaymentMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamHasValidPaymentMethod(ctx, req.(*GetTeamHasValidPaymentMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamPrivacyModeForced_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamPrivacyModeForcedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamPrivacyModeForced(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamPrivacyModeForced_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamPrivacyModeForced(ctx, req.(*GetTeamPrivacyModeForcedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SwitchTeamPrivacyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchTeamPrivacyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SwitchTeamPrivacyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SwitchTeamPrivacyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SwitchTeamPrivacyMode(ctx, req.(*SwitchTeamPrivacyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateFastRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFastRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateFastRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateFastRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateFastRequests(ctx, req.(*UpdateFastRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetFastRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFastRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetFastRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetFastRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetFastRequests(ctx, req.(*GetFastRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetDownloadLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDownloadLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetDownloadLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetDownloadLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetDownloadLink(ctx, req.(*GetDownloadLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetCliDownloadUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCliDownloadUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetCliDownloadUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetCliDownloadUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetCliDownloadUrl(ctx, req.(*GetCliDownloadUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSsoConfigurationLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSsoConfigurationLinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSsoConfigurationLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSsoConfigurationLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSsoConfigurationLinks(ctx, req.(*GetSsoConfigurationLinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetScimConfigurationLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScimConfigurationLinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetScimConfigurationLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetScimConfigurationLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetScimConfigurationLinks(ctx, req.(*GetScimConfigurationLinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetAdminOnlyUsagePricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAdminOnlyUsagePricingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetAdminOnlyUsagePricing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetAdminOnlyUsagePricing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetAdminOnlyUsagePricing(ctx, req.(*SetAdminOnlyUsagePricingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetYearlyUpgradeEligibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetYearlyUpgradeEligibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetYearlyUpgradeEligibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetYearlyUpgradeEligibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetYearlyUpgradeEligibility(ctx, req.(*GetYearlyUpgradeEligibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpgradeToYearly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeToYearlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpgradeToYearly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpgradeToYearly_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpgradeToYearly(ctx, req.(*UpgradeToYearlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetEnterpriseCTAEligibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEnterpriseCTAEligibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetEnterpriseCTAEligibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetEnterpriseCTAEligibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetEnterpriseCTAEligibility(ctx, req.(*GetEnterpriseCTAEligibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUsageBasedPremiumRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsageBasedPremiumRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUsageBasedPremiumRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUsageBasedPremiumRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUsageBasedPremiumRequests(ctx, req.(*GetUsageBasedPremiumRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetUsageBasedPremiumRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUsageBasedPremiumRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetUsageBasedPremiumRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetUsageBasedPremiumRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetUsageBasedPremiumRequests(ctx, req.(*SetUsageBasedPremiumRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetReferrals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReferralsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetReferrals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetReferrals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetReferrals(ctx, req.(*GetReferralsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CheckReferralCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckReferralCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CheckReferralCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CheckReferralCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CheckReferralCode(ctx, req.(*CheckReferralCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RedeemGiftCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedeemGiftCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RedeemGiftCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RedeemGiftCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RedeemGiftCode(ctx, req.(*RedeemGiftCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamRepos(ctx, req.(*GetTeamReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamReposOrEmptyIfNotInTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamReposOrEmptyIfNotInTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamReposOrEmptyIfNotInTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamReposOrEmptyIfNotInTeam(ctx, req.(*GetTeamReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamRules(ctx, req.(*GetTeamRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamRule(ctx, req.(*CreateTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamRule(ctx, req.(*UpdateTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteTeamRule(ctx, req.(*DeleteTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamHooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamHooksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamHooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamHooks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamHooks(ctx, req.(*GetTeamHooksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamHook(ctx, req.(*CreateTeamHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamHook(ctx, req.(*UpdateTeamHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteTeamHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteTeamHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteTeamHook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteTeamHook(ctx, req.(*DeleteTeamHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamCommandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamCommands_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamCommands(ctx, req.(*GetTeamCommandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamCommand(ctx, req.(*CreateTeamCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamCommand(ctx, req.(*UpdateTeamCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteTeamCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteTeamCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteTeamCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteTeamCommand(ctx, req.(*DeleteTeamCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugbotTeamRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugbotTeamRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugbotTeamRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugbotTeamRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugbotTeamRules(ctx, req.(*GetBugbotTeamRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateBugbotTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBugbotTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateBugbotTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateBugbotTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateBugbotTeamRule(ctx, req.(*CreateBugbotTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateBugbotTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBugbotTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateBugbotTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateBugbotTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateBugbotTeamRule(ctx, req.(*UpdateBugbotTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteBugbotTeamRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBugbotTeamRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteBugbotTeamRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteBugbotTeamRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteBugbotTeamRule(ctx, req.(*DeleteBugbotTeamRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugbotLearnedRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugbotLearnedRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugbotLearnedRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugbotLearnedRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugbotLearnedRules(ctx, req.(*GetBugbotLearnedRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateBugbotLearnedRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBugbotLearnedRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateBugbotLearnedRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateBugbotLearnedRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateBugbotLearnedRule(ctx, req.(*UpdateBugbotLearnedRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteBugbotLearnedRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBugbotLearnedRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteBugbotLearnedRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteBugbotLearnedRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteBugbotLearnedRule(ctx, req.(*DeleteBugbotLearnedRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamRepo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamRepo(ctx, req.(*CreateTeamRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteTeamRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteTeamRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteTeamRepo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteTeamRepo(ctx, req.(*DeleteTeamRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_AddRepoPattern_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRepoPatternRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).AddRepoPattern(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_AddRepoPattern_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).AddRepoPattern(ctx, req.(*AddRepoPatternRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RemoveRepoPattern_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRepoPatternRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RemoveRepoPattern(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RemoveRepoPattern_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RemoveRepoPattern(ctx, req.(*RemoveRepoPatternRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetTeamRepoType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTeamRepoTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetTeamRepoType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetTeamRepoType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetTeamRepoType(ctx, req.(*SetTeamRepoTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamAdminSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamAdminSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamAdminSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamAdminSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamAdminSettings(ctx, req.(*GetTeamAdminSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamAdminSettingsOrEmptyIfNotInTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamAdminSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamAdminSettingsOrEmptyIfNotInTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamAdminSettingsOrEmptyIfNotInTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamAdminSettingsOrEmptyIfNotInTeam(ctx, req.(*GetTeamAdminSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBaseTeamAdminSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseTeamAdminSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBaseTeamAdminSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBaseTeamAdminSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBaseTeamAdminSettings(ctx, req.(*GetBaseTeamAdminSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamAdminSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamAdminSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamAdminSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamAdminSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamAdminSettings(ctx, req.(*UpdateTeamAdminSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamFreeTrialCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamFreeTrialCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamFreeTrialCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamFreeTrialCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamFreeTrialCode(ctx, req.(*CreateTeamFreeTrialCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamAnalytics(ctx, req.(*GetTeamAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUserAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUserAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUserAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUserAnalytics(ctx, req.(*GetUserAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamRawData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamRawDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamRawData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamRawData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamRawData(ctx, req.(*GetTeamRawDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetClientUsageData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientUsageDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetClientUsageData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetClientUsageData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetClientUsageData(ctx, req.(*GetClientUsageDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetCurrentPeriodUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentPeriodUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetCurrentPeriodUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetCurrentPeriodUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetCurrentPeriodUsage(ctx, req.(*GetCurrentPeriodUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetPlanInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlanInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetPlanInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetPlanInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetPlanInfo(ctx, req.(*GetPlanInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUsageLimitPolicyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsageLimitPolicyStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUsageLimitPolicyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUsageLimitPolicyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUsageLimitPolicyStatus(ctx, req.(*GetUsageLimitPolicyStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAdvancedAnalyticsEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdvancedAnalyticsEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAdvancedAnalyticsEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAdvancedAnalyticsEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAdvancedAnalyticsEnabled(ctx, req.(*GetAdvancedAnalyticsEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTokenUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTokenUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTokenUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTokenUsage(ctx, req.(*GetTokenUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ValidateBedrockIamRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateBedrockIamRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ValidateBedrockIamRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ValidateBedrockIamRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ValidateBedrockIamRole(ctx, req.(*ValidateBedrockIamRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_AddUserToEarlyAccessList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserToEarlyAccessListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).AddUserToEarlyAccessList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_AddUserToEarlyAccessList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).AddUserToEarlyAccessList(ctx, req.(*AddUserToEarlyAccessListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamSpend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamSpendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamSpend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamSpend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamSpend(ctx, req.(*GetTeamSpendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetCurrentBillingCycle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentBillingCycleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetCurrentBillingCycle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetCurrentBillingCycle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetCurrentBillingCycle(ctx, req.(*GetCurrentBillingCycleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMonthlyBillingCycle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMonthlyBillingCycleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMonthlyBillingCycle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMonthlyBillingCycle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMonthlyBillingCycle(ctx, req.(*GetMonthlyBillingCycleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugbotSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugbotSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugbotSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugbotSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugbotSettings(ctx, req.(*GetBugbotSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugbotAnalyticsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugbotAnalyticsV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugbotAnalyticsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugbotAnalyticsV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugbotAnalyticsV2(ctx, req.(*GetBugbotAnalyticsV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugBotPRAnalytics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugBotPRAnalyticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugBotPRAnalytics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugBotPRAnalytics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugBotPRAnalytics(ctx, req.(*GetBugBotPRAnalyticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetGithubInstallations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGithubInstallationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetGithubInstallations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetGithubInstallations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetGithubInstallations(ctx, req.(*GetGithubInstallationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetInstallationRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstallationReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetInstallationRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetInstallationRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetInstallationRepos(ctx, req.(*GetInstallationReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_FetchAllInstallationRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchAllInstallationReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).FetchAllInstallationRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_FetchAllInstallationRepos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).FetchAllInstallationRepos(ctx, req.(*FetchAllInstallationReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetInstallationGithubUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstallationGithubUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetInstallationGithubUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetInstallationGithubUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetInstallationGithubUsers(ctx, req.(*GetInstallationGithubUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamGithubUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamGithubUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamGithubUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamGithubUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamGithubUsers(ctx, req.(*GetTeamGithubUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_AddGithubUsersToTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGithubUsersToTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).AddGithubUsersToTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_AddGithubUsersToTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).AddGithubUsersToTeam(ctx, req.(*AddGithubUsersToTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUserPullRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserPullRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUserPullRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUserPullRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUserPullRequests(ctx, req.(*GetUserPullRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUserReviewRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserReviewRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUserReviewRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUserReviewRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUserReviewRequests(ctx, req.(*GetUserReviewRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateGithubRepoSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGithubRepoSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateGithubRepoSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateGithubRepoSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateGithubRepoSettings(ctx, req.(*UpdateGithubRepoSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateGithubInstallationSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGithubInstallationSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateGithubInstallationSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateGithubInstallationSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateGithubInstallationSettings(ctx, req.(*UpdateGithubInstallationSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateAllGithubRepoSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAllGithubRepoSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateAllGithubRepoSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateAllGithubRepoSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateAllGithubRepoSettings(ctx, req.(*UpdateAllGithubRepoSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateGithubInstallationTeamScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGithubInstallationTeamScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateGithubInstallationTeamScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateGithubInstallationTeamScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateGithubInstallationTeamScope(ctx, req.(*UpdateGithubInstallationTeamScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateSelfGithubAllowlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSelfGithubAllowlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateSelfGithubAllowlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateSelfGithubAllowlist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateSelfGithubAllowlist(ctx, req.(*UpdateSelfGithubAllowlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamBugbotSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamBugbotSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamBugbotSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamBugbotSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamBugbotSettings(ctx, req.(*GetTeamBugbotSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamBugbotSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamBugbotSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamBugbotSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamBugbotSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamBugbotSettings(ctx, req.(*UpdateTeamBugbotSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugbotUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugbotUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugbotUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugbotUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugbotUserSettings(ctx, req.(*GetBugbotUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateBugbotUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBugbotUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateBugbotUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateBugbotUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateBugbotUserSettings(ctx, req.(*UpdateBugbotUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetBugBotProUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBugBotProUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetBugBotProUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetBugBotProUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetBugBotProUserSettings(ctx, req.(*GetBugBotProUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateBugBotProUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBugBotProUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateBugBotProUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateBugBotProUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateBugBotProUserSettings(ctx, req.(*UpdateBugBotProUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RecordBugbotDeeplinkEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordBugbotDeeplinkEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RecordBugbotDeeplinkEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RecordBugbotDeeplinkEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RecordBugbotDeeplinkEvent(ctx, req.(*RecordBugbotDeeplinkEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RecordBugbotDeeplinkEventUnauthenticated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordBugbotDeeplinkEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RecordBugbotDeeplinkEventUnauthenticated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RecordBugbotDeeplinkEventUnauthenticated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RecordBugbotDeeplinkEventUnauthenticated(ctx, req.(*RecordBugbotDeeplinkEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeBugBotLicenses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeBugBotLicensesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeBugBotLicenses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeBugBotLicenses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeBugBotLicenses(ctx, req.(*RevokeBugBotLicensesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeUserBugbotLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeUserBugbotLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeUserBugbotLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeUserBugbotLicense_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeUserBugbotLicense(ctx, req.(*RevokeUserBugbotLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_StartBugbotBackfillLearning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartBugbotBackfillLearningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).StartBugbotBackfillLearning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_StartBugbotBackfillLearning_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).StartBugbotBackfillLearning(ctx, req.(*StartBugbotBackfillLearningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetSlackAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSlackAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetSlackAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetSlackAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetSlackAuth(ctx, req.(*SetSlackAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackTeamSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackTeamSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackTeamSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackTeamSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackTeamSettings(ctx, req.(*GetSlackTeamSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateSlackTeamSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSlackTeamSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateSlackTeamSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateSlackTeamSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateSlackTeamSettings(ctx, req.(*UpdateSlackTeamSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackSettings(ctx, req.(*GetSlackSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackModelOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackModelOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackModelOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackModelOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackModelOptions(ctx, req.(*GetSlackModelOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackInstallUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackInstallUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackInstallUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackInstallUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackInstallUrl(ctx, req.(*GetSlackInstallUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackInstallUrlPublic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicSlackInstallUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackInstallUrlPublic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackInstallUrlPublic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackInstallUrlPublic(ctx, req.(*GetPublicSlackInstallUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetFilteredUsageEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilteredUsageEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetFilteredUsageEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetFilteredUsageEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetFilteredUsageEvents(ctx, req.(*GetFilteredUsageEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAggregatedUsageEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAggregatedUsageEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAggregatedUsageEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAggregatedUsageEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAggregatedUsageEvents(ctx, req.(*GetAggregatedUsageEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAuditLogs(ctx, req.(*GetAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetUserPrivacyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserPrivacyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetUserPrivacyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetUserPrivacyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetUserPrivacyMode(ctx, req.(*GetUserPrivacyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetUserPrivacyMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserPrivacyModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetUserPrivacyMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetUserPrivacyMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetUserPrivacyMode(ctx, req.(*SetUserPrivacyModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_WebAcknowledgeGracePeriodDisclaimer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebAcknowledgeGracePeriodDisclaimerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).WebAcknowledgeGracePeriodDisclaimer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_WebAcknowledgeGracePeriodDisclaimer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).WebAcknowledgeGracePeriodDisclaimer(ctx, req.(*WebAcknowledgeGracePeriodDisclaimerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SkipPrivacyModeGracePeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SkipPrivacyModeGracePeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SkipPrivacyModeGracePeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SkipPrivacyModeGracePeriod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SkipPrivacyModeGracePeriod(ctx, req.(*SkipPrivacyModeGracePeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_NeedsPrivacyModeMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NeedsPrivacyModeMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).NeedsPrivacyModeMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_NeedsPrivacyModeMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).NeedsPrivacyModeMigration(ctx, req.(*NeedsPrivacyModeMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamPrivacyModeMigrationOptOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamPrivacyModeMigrationOptOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamPrivacyModeMigrationOptOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamPrivacyModeMigrationOptOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamPrivacyModeMigrationOptOut(ctx, req.(*UpdateTeamPrivacyModeMigrationOptOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ShareConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ShareConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ShareConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ShareConversation(ctx, req.(*ShareConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSharedConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSharedConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSharedConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSharedConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSharedConversation(ctx, req.(*GetSharedConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetPublicSharedConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicSharedConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetPublicSharedConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetPublicSharedConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetPublicSharedConversation(ctx, req.(*GetPublicSharedConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListSharedConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSharedConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListSharedConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListSharedConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListSharedConversations(ctx, req.(*ListSharedConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteSharedConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSharedConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteSharedConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteSharedConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteSharedConversation(ctx, req.(*DeleteSharedConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateSharedConversationVisibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSharedConversationVisibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateSharedConversationVisibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateSharedConversationVisibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateSharedConversationVisibility(ctx, req.(*UpdateSharedConversationVisibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeTeamInviteLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTeamInviteLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeTeamInviteLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeTeamInviteLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeTeamInviteLink(ctx, req.(*RevokeTeamInviteLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListTeamInviteLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamInviteLinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListTeamInviteLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListTeamInviteLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListTeamInviteLinks(ctx, req.(*ListTeamInviteLinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateUserName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateUserName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateUserName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateUserName(ctx, req.(*UpdateUserNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListInvoices(ctx, req.(*ListInvoicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_IsEligibleForRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsEligibleForRefundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).IsEligibleForRefund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_IsEligibleForRefund_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).IsEligibleForRefund(ctx, req.(*IsEligibleForRefundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetRemainingRefunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRemainingRefundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetRemainingRefunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetRemainingRefunds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetRemainingRefunds(ctx, req.(*GetRemainingRefundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetServiceAccountSpendLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceAccountSpendLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetServiceAccountSpendLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetServiceAccountSpendLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetServiceAccountSpendLimit(ctx, req.(*GetServiceAccountSpendLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetServiceAccountSpendLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetServiceAccountSpendLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetServiceAccountSpendLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetServiceAccountSpendLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetServiceAccountSpendLimit(ctx, req.(*SetServiceAccountSpendLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetUserHardLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserHardLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetUserHardLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetUserHardLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetUserHardLimit(ctx, req.(*SetUserHardLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetUserMonthlyLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserMonthlyLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetUserMonthlyLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetUserMonthlyLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetUserMonthlyLimit(ctx, req.(*SetUserMonthlyLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ToggleMarketingEmailOpt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleMarketingEmailOptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ToggleMarketingEmailOpt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ToggleMarketingEmailOpt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ToggleMarketingEmailOpt(ctx, req.(*ToggleMarketingEmailOptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetMarketingEmailOpt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMarketingEmailOptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetMarketingEmailOpt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetMarketingEmailOpt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetMarketingEmailOpt(ctx, req.(*GetMarketingEmailOptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetGlobalLeaderboardOptIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalLeaderboardOptInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetGlobalLeaderboardOptIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetGlobalLeaderboardOptIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetGlobalLeaderboardOptIn(ctx, req.(*GetGlobalLeaderboardOptInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SetGlobalLeaderboardOptIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGlobalLeaderboardOptInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SetGlobalLeaderboardOptIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SetGlobalLeaderboardOptIn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SetGlobalLeaderboardOptIn(ctx, req.(*SetGlobalLeaderboardOptInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamApiKey(ctx, req.(*CreateTeamApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeTeamApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTeamApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeTeamApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeTeamApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeTeamApiKey(ctx, req.(*RevokeTeamApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListTeamApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamApiKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListTeamApiKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListTeamApiKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListTeamApiKeys(ctx, req.(*ListTeamApiKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateTeamServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamServiceAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateTeamServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateTeamServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateTeamServiceAccount(ctx, req.(*CreateTeamServiceAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListTeamServiceAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamServiceAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListTeamServiceAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListTeamServiceAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListTeamServiceAccounts(ctx, req.(*ListTeamServiceAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteTeamServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamServiceAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteTeamServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteTeamServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteTeamServiceAccount(ctx, req.(*DeleteTeamServiceAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ArchiveTeamServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveTeamServiceAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ArchiveTeamServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ArchiveTeamServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ArchiveTeamServiceAccount(ctx, req.(*ArchiveTeamServiceAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RotateServiceAccountApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateServiceAccountApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RotateServiceAccountApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RotateServiceAccountApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RotateServiceAccountApiKey(ctx, req.(*RotateServiceAccountApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetTeamRepositoriesForServiceAccountScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamRepositoriesForServiceAccountScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetTeamRepositoriesForServiceAccountScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetTeamRepositoriesForServiceAccountScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetTeamRepositoriesForServiceAccountScope(ctx, req.(*GetTeamRepositoriesForServiceAccountScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateServiceAccountRepoScope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateServiceAccountRepoScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateServiceAccountRepoScope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateServiceAccountRepoScope_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateServiceAccountRepoScope(ctx, req.(*UpdateServiceAccountRepoScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateUserApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateUserApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateUserApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateUserApiKey(ctx, req.(*CreateUserApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RevokeUserApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeUserApiKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RevokeUserApiKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RevokeUserApiKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RevokeUserApiKey(ctx, req.(*RevokeUserApiKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListUserApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserApiKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListUserApiKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListUserApiKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListUserApiKeys(ctx, req.(*ListUserApiKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ConfirmGithubInstallation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmGithubInstallationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ConfirmGithubInstallation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ConfirmGithubInstallation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ConfirmGithubInstallation(ctx, req.(*ConfirmGithubInstallationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamName(ctx, req.(*UpdateTeamNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateTeamDashboardAnalyticsSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamDashboardAnalyticsSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateTeamDashboardAnalyticsSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateTeamDashboardAnalyticsSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateTeamDashboardAnalyticsSetting(ctx, req.(*UpdateTeamDashboardAnalyticsSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackUserSettings(ctx, req.(*GetSlackUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateSlackUserSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSlackUserSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateSlackUserSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateSlackUserSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateSlackUserSettings(ctx, req.(*UpdateSlackUserSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetSlackRepoRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlackRepoRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetSlackRepoRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetSlackRepoRoutingRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetSlackRepoRoutingRules(ctx, req.(*GetSlackRepoRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateSlackRepoRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSlackRepoRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateSlackRepoRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateSlackRepoRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateSlackRepoRoutingRule(ctx, req.(*CreateSlackRepoRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateSlackRepoRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSlackRepoRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateSlackRepoRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateSlackRepoRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateSlackRepoRoutingRule(ctx, req.(*UpdateSlackRepoRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteSlackRepoRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSlackRepoRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteSlackRepoRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteSlackRepoRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteSlackRepoRoutingRule(ctx, req.(*DeleteSlackRepoRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_IsOnNewPricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsOnNewPricingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).IsOnNewPricing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_IsOnNewPricing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).IsOnNewPricing(ctx, req.(*IsOnNewPricingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearAuthUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearAuthUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearAuthUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearAuthUrl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearAuthUrl(ctx, req.(*GetLinearAuthUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearStatus(ctx, req.(*GetLinearStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DisconnectLinear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectLinearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DisconnectLinear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DisconnectLinear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DisconnectLinear(ctx, req.(*DisconnectLinearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearTeams(ctx, req.(*GetLinearTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearSettings(ctx, req.(*GetLinearSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateLinearTeamSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLinearTeamSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateLinearTeamSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateLinearTeamSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateLinearTeamSetting(ctx, req.(*UpdateLinearTeamSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateLinearProjectSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLinearProjectSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateLinearProjectSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateLinearProjectSetting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateLinearProjectSetting(ctx, req.(*UpdateLinearProjectSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearLabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearLabels(ctx, req.(*GetLinearLabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetLinearIssues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinearIssuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetLinearIssues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetLinearIssues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetLinearIssues(ctx, req.(*GetLinearIssuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteBedrockIamRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBedrockIamRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteBedrockIamRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteBedrockIamRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteBedrockIamRole(ctx, req.(*DeleteBedrockIamRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UnlinkSlackAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlinkSlackAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UnlinkSlackAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UnlinkSlackAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UnlinkSlackAccess(ctx, req.(*UnlinkSlackAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListSlackConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSlackConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListSlackConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListSlackConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListSlackConversations(ctx, req.(*ListSlackConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_LogSlackbotAuthConversionFunnel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogSlackbotAuthConversionFunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).LogSlackbotAuthConversionFunnel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_LogSlackbotAuthConversionFunnel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).LogSlackbotAuthConversionFunnel(ctx, req.(*LogSlackbotAuthConversionFunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_LogClickedConnectSlack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogClickedConnectSlackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).LogClickedConnectSlack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_LogClickedConnectSlack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).LogClickedConnectSlack(ctx, req.(*LogClickedConnectSlackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CheckUserApiKeyAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserApiKeyAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CheckUserApiKeyAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CheckUserApiKeyAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CheckUserApiKeyAccess(ctx, req.(*CheckUserApiKeyAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_IsAllowedFreeTrialUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsAllowedFreeTrialUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).IsAllowedFreeTrialUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_IsAllowedFreeTrialUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).IsAllowedFreeTrialUsage(ctx, req.(*IsAllowedFreeTrialUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CompletedLinkSlackAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletedLinkSlackAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CompletedLinkSlackAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CompletedLinkSlackAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CompletedLinkSlackAccount(ctx, req.(*CompletedLinkSlackAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_NotifyTeamAdmins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyTeamAdminsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).NotifyTeamAdmins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_NotifyTeamAdmins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).NotifyTeamAdmins(ctx, req.(*NotifyTeamAdminsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_GetAdminNotificationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdminNotificationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).GetAdminNotificationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_GetAdminNotificationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).GetAdminNotificationStatus(ctx, req.(*GetAdminNotificationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_OptOutNewPricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OptOutNewPricingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).OptOutNewPricing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_OptOutNewPricing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).OptOutNewPricing(ctx, req.(*OptOutNewPricingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_SubmitFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).SubmitFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_SubmitFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).SubmitFeedback(ctx, req.(*SubmitFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CanStudentReverify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanStudentReverifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CanStudentReverify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CanStudentReverify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CanStudentReverify(ctx, req.(*CanStudentReverifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ClientAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ClientAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ClientAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ClientAction(ctx, req.(*ClientActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_ListUsageAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsageAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).ListUsageAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_ListUsageAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).ListUsageAlerts(ctx, req.(*ListUsageAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_CreateUsageAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUsageAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).CreateUsageAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_CreateUsageAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).CreateUsageAlerts(ctx, req.(*CreateUsageAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_DeleteUsageAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUsageAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).DeleteUsageAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_DeleteUsageAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).DeleteUsageAlerts(ctx, req.(*DeleteUsageAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_UpdateUsageAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUsageAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).UpdateUsageAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_UpdateUsageAlerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).UpdateUsageAlerts(ctx, req.(*UpdateUsageAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DashboardService_RequestIndividualLimitsOptOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestIndividualLimitsOptOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DashboardServiceServer).RequestIndividualLimitsOptOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DashboardService_RequestIndividualLimitsOptOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DashboardServiceServer).RequestIndividualLimitsOptOut(ctx, req.(*RequestIndividualLimitsOptOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DashboardService_ServiceDesc is the grpc.ServiceDesc for DashboardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DashboardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.DashboardService",
	HandlerType: (*DashboardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTeams",
			Handler:    _DashboardService_GetTeams_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _DashboardService_GetMe_Handler,
		},
		{
			MethodName: "GetDirectoryGroups",
			Handler:    _DashboardService_GetDirectoryGroups_Handler,
		},
		{
			MethodName: "UpdateDirectoryGroupSettings",
			Handler:    _DashboardService_UpdateDirectoryGroupSettings_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _DashboardService_GetGroups_Handler,
		},
		{
			MethodName: "GetGroupMembers",
			Handler:    _DashboardService_GetGroupMembers_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _DashboardService_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _DashboardService_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _DashboardService_DeleteGroup_Handler,
		},
		{
			MethodName: "AddGroupMembers",
			Handler:    _DashboardService_AddGroupMembers_Handler,
		},
		{
			MethodName: "RemoveGroupMembers",
			Handler:    _DashboardService_RemoveGroupMembers_Handler,
		},
		{
			MethodName: "BulkAssignGroupMembers",
			Handler:    _DashboardService_BulkAssignGroupMembers_Handler,
		},
		{
			MethodName: "PreviewAttachGroupToDirectory",
			Handler:    _DashboardService_PreviewAttachGroupToDirectory_Handler,
		},
		{
			MethodName: "DetachGroupFromDirectory",
			Handler:    _DashboardService_DetachGroupFromDirectory_Handler,
		},
		{
			MethodName: "GetScimConflicts",
			Handler:    _DashboardService_GetScimConflicts_Handler,
		},
		{
			MethodName: "GetActivationCheckoutUrl",
			Handler:    _DashboardService_GetActivationCheckoutUrl_Handler,
		},
		{
			MethodName: "GetTeamCustomerPortalUrl",
			Handler:    _DashboardService_GetTeamCustomerPortalUrl_Handler,
		},
		{
			MethodName: "GetTeamMembers",
			Handler:    _DashboardService_GetTeamMembers_Handler,
		},
		{
			MethodName: "SendTeamInvite",
			Handler:    _DashboardService_SendTeamInvite_Handler,
		},
		{
			MethodName: "GetTeamInviteLink",
			Handler:    _DashboardService_GetTeamInviteLink_Handler,
		},
		{
			MethodName: "AcceptInvite",
			Handler:    _DashboardService_AcceptInvite_Handler,
		},
		{
			MethodName: "CreateTeam",
			Handler:    _DashboardService_CreateTeam_Handler,
		},
		{
			MethodName: "GetJoinableTeamsByDomain",
			Handler:    _DashboardService_GetJoinableTeamsByDomain_Handler,
		},
		{
			MethodName: "JoinTeamByDomain",
			Handler:    _DashboardService_JoinTeamByDomain_Handler,
		},
		{
			MethodName: "UpdateTeamDomainJoinSetting",
			Handler:    _DashboardService_UpdateTeamDomainJoinSetting_Handler,
		},
		{
			MethodName: "GetTeamMemberDomains",
			Handler:    _DashboardService_GetTeamMemberDomains_Handler,
		},
		{
			MethodName: "GetTeamIdForReactivation",
			Handler:    _DashboardService_GetTeamIdForReactivation_Handler,
		},
		{
			MethodName: "ChangeSeat",
			Handler:    _DashboardService_ChangeSeat_Handler,
		},
		{
			MethodName: "ChangeTeamSubscription",
			Handler:    _DashboardService_ChangeTeamSubscription_Handler,
		},
		{
			MethodName: "ConnectGithubCallback",
			Handler:    _DashboardService_ConnectGithubCallback_Handler,
		},
		{
			MethodName: "RegisterGithubCursorCode",
			Handler:    _DashboardService_RegisterGithubCursorCode_Handler,
		},
		{
			MethodName: "DisconnectGithub",
			Handler:    _DashboardService_DisconnectGithub_Handler,
		},
		{
			MethodName: "PrepareSetupGithubEnterpriseApp",
			Handler:    _DashboardService_PrepareSetupGithubEnterpriseApp_Handler,
		},
		{
			MethodName: "FinishSetupGithubEnterpriseApp",
			Handler:    _DashboardService_FinishSetupGithubEnterpriseApp_Handler,
		},
		{
			MethodName: "ListGithubEnterpriseApps",
			Handler:    _DashboardService_ListGithubEnterpriseApps_Handler,
		},
		{
			MethodName: "DeleteGithubEnterpriseApp",
			Handler:    _DashboardService_DeleteGithubEnterpriseApp_Handler,
		},
		{
			MethodName: "SetupGitlabEnterpriseInstance",
			Handler:    _DashboardService_SetupGitlabEnterpriseInstance_Handler,
		},
		{
			MethodName: "ListGitlabEnterpriseInstances",
			Handler:    _DashboardService_ListGitlabEnterpriseInstances_Handler,
		},
		{
			MethodName: "DeleteGitlabEnterpriseInstance",
			Handler:    _DashboardService_DeleteGitlabEnterpriseInstance_Handler,
		},
		{
			MethodName: "SyncGitlabRepos",
			Handler:    _DashboardService_SyncGitlabRepos_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _DashboardService_UpdateRole_Handler,
		},
		{
			MethodName: "RemoveMember",
			Handler:    _DashboardService_RemoveMember_Handler,
		},
		{
			MethodName: "GetTeamUsage",
			Handler:    _DashboardService_GetTeamUsage_Handler,
		},
		{
			MethodName: "GetSignUpType",
			Handler:    _DashboardService_GetSignUpType_Handler,
		},
		{
			MethodName: "GetHardLimit",
			Handler:    _DashboardService_GetHardLimit_Handler,
		},
		{
			MethodName: "SetHardLimit",
			Handler:    _DashboardService_SetHardLimit_Handler,
		},
		{
			MethodName: "EnableOnDemandSpend",
			Handler:    _DashboardService_EnableOnDemandSpend_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _DashboardService_DeleteAccount_Handler,
		},
		{
			MethodName: "SendDownloadEmail",
			Handler:    _DashboardService_SendDownloadEmail_Handler,
		},
		{
			MethodName: "GetMonthlyInvoice",
			Handler:    _DashboardService_GetMonthlyInvoice_Handler,
		},
		{
			MethodName: "ListInvoiceCycles",
			Handler:    _DashboardService_ListInvoiceCycles_Handler,
		},
		{
			MethodName: "GetDailySpendByCategory",
			Handler:    _DashboardService_GetDailySpendByCategory_Handler,
		},
		{
			MethodName: "GetPricingHistory",
			Handler:    _DashboardService_GetPricingHistory_Handler,
		},
		{
			MethodName: "ListBackgroundComposerSecrets",
			Handler:    _DashboardService_ListBackgroundComposerSecrets_Handler,
		},
		{
			MethodName: "CreateBackgroundComposerSecret",
			Handler:    _DashboardService_CreateBackgroundComposerSecret_Handler,
		},
		{
			MethodName: "RevokeBackgroundComposerSecret",
			Handler:    _DashboardService_RevokeBackgroundComposerSecret_Handler,
		},
		{
			MethodName: "UpdateBackgroundComposerSecret",
			Handler:    _DashboardService_UpdateBackgroundComposerSecret_Handler,
		},
		{
			MethodName: "GetMcpConfig",
			Handler:    _DashboardService_GetMcpConfig_Handler,
		},
		{
			MethodName: "GetAvailableMcpServers",
			Handler:    _DashboardService_GetAvailableMcpServers_Handler,
		},
		{
			MethodName: "SetMcpConfig",
			Handler:    _DashboardService_SetMcpConfig_Handler,
		},
		{
			MethodName: "UpdateUserDefaultMcpSettings",
			Handler:    _DashboardService_UpdateUserDefaultMcpSettings_Handler,
		},
		{
			MethodName: "StoreMcpOAuthToken",
			Handler:    _DashboardService_StoreMcpOAuthToken_Handler,
		},
		{
			MethodName: "ValidateMcpOAuthTokens",
			Handler:    _DashboardService_ValidateMcpOAuthTokens_Handler,
		},
		{
			MethodName: "StoreMcpOAuthPendingState",
			Handler:    _DashboardService_StoreMcpOAuthPendingState_Handler,
		},
		{
			MethodName: "GetMcpOAuthPendingState",
			Handler:    _DashboardService_GetMcpOAuthPendingState_Handler,
		},
		{
			MethodName: "CreateTeamWithFreeTrial",
			Handler:    _DashboardService_CreateTeamWithFreeTrial_Handler,
		},
		{
			MethodName: "GetTeamHasValidPaymentMethod",
			Handler:    _DashboardService_GetTeamHasValidPaymentMethod_Handler,
		},
		{
			MethodName: "GetTeamPrivacyModeForced",
			Handler:    _DashboardService_GetTeamPrivacyModeForced_Handler,
		},
		{
			MethodName: "SwitchTeamPrivacyMode",
			Handler:    _DashboardService_SwitchTeamPrivacyMode_Handler,
		},
		{
			MethodName: "UpdateFastRequests",
			Handler:    _DashboardService_UpdateFastRequests_Handler,
		},
		{
			MethodName: "GetFastRequests",
			Handler:    _DashboardService_GetFastRequests_Handler,
		},
		{
			MethodName: "GetDownloadLink",
			Handler:    _DashboardService_GetDownloadLink_Handler,
		},
		{
			MethodName: "GetCliDownloadUrl",
			Handler:    _DashboardService_GetCliDownloadUrl_Handler,
		},
		{
			MethodName: "GetSsoConfigurationLinks",
			Handler:    _DashboardService_GetSsoConfigurationLinks_Handler,
		},
		{
			MethodName: "GetScimConfigurationLinks",
			Handler:    _DashboardService_GetScimConfigurationLinks_Handler,
		},
		{
			MethodName: "SetAdminOnlyUsagePricing",
			Handler:    _DashboardService_SetAdminOnlyUsagePricing_Handler,
		},
		{
			MethodName: "GetYearlyUpgradeEligibility",
			Handler:    _DashboardService_GetYearlyUpgradeEligibility_Handler,
		},
		{
			MethodName: "UpgradeToYearly",
			Handler:    _DashboardService_UpgradeToYearly_Handler,
		},
		{
			MethodName: "GetEnterpriseCTAEligibility",
			Handler:    _DashboardService_GetEnterpriseCTAEligibility_Handler,
		},
		{
			MethodName: "GetUsageBasedPremiumRequests",
			Handler:    _DashboardService_GetUsageBasedPremiumRequests_Handler,
		},
		{
			MethodName: "SetUsageBasedPremiumRequests",
			Handler:    _DashboardService_SetUsageBasedPremiumRequests_Handler,
		},
		{
			MethodName: "GetReferrals",
			Handler:    _DashboardService_GetReferrals_Handler,
		},
		{
			MethodName: "CheckReferralCode",
			Handler:    _DashboardService_CheckReferralCode_Handler,
		},
		{
			MethodName: "RedeemGiftCode",
			Handler:    _DashboardService_RedeemGiftCode_Handler,
		},
		{
			MethodName: "GetTeamRepos",
			Handler:    _DashboardService_GetTeamRepos_Handler,
		},
		{
			MethodName: "GetTeamReposOrEmptyIfNotInTeam",
			Handler:    _DashboardService_GetTeamReposOrEmptyIfNotInTeam_Handler,
		},
		{
			MethodName: "GetTeamRules",
			Handler:    _DashboardService_GetTeamRules_Handler,
		},
		{
			MethodName: "CreateTeamRule",
			Handler:    _DashboardService_CreateTeamRule_Handler,
		},
		{
			MethodName: "UpdateTeamRule",
			Handler:    _DashboardService_UpdateTeamRule_Handler,
		},
		{
			MethodName: "DeleteTeamRule",
			Handler:    _DashboardService_DeleteTeamRule_Handler,
		},
		{
			MethodName: "GetTeamHooks",
			Handler:    _DashboardService_GetTeamHooks_Handler,
		},
		{
			MethodName: "CreateTeamHook",
			Handler:    _DashboardService_CreateTeamHook_Handler,
		},
		{
			MethodName: "UpdateTeamHook",
			Handler:    _DashboardService_UpdateTeamHook_Handler,
		},
		{
			MethodName: "DeleteTeamHook",
			Handler:    _DashboardService_DeleteTeamHook_Handler,
		},
		{
			MethodName: "GetTeamCommands",
			Handler:    _DashboardService_GetTeamCommands_Handler,
		},
		{
			MethodName: "CreateTeamCommand",
			Handler:    _DashboardService_CreateTeamCommand_Handler,
		},
		{
			MethodName: "UpdateTeamCommand",
			Handler:    _DashboardService_UpdateTeamCommand_Handler,
		},
		{
			MethodName: "DeleteTeamCommand",
			Handler:    _DashboardService_DeleteTeamCommand_Handler,
		},
		{
			MethodName: "GetBugbotTeamRules",
			Handler:    _DashboardService_GetBugbotTeamRules_Handler,
		},
		{
			MethodName: "CreateBugbotTeamRule",
			Handler:    _DashboardService_CreateBugbotTeamRule_Handler,
		},
		{
			MethodName: "UpdateBugbotTeamRule",
			Handler:    _DashboardService_UpdateBugbotTeamRule_Handler,
		},
		{
			MethodName: "DeleteBugbotTeamRule",
			Handler:    _DashboardService_DeleteBugbotTeamRule_Handler,
		},
		{
			MethodName: "GetBugbotLearnedRules",
			Handler:    _DashboardService_GetBugbotLearnedRules_Handler,
		},
		{
			MethodName: "UpdateBugbotLearnedRule",
			Handler:    _DashboardService_UpdateBugbotLearnedRule_Handler,
		},
		{
			MethodName: "DeleteBugbotLearnedRule",
			Handler:    _DashboardService_DeleteBugbotLearnedRule_Handler,
		},
		{
			MethodName: "CreateTeamRepo",
			Handler:    _DashboardService_CreateTeamRepo_Handler,
		},
		{
			MethodName: "DeleteTeamRepo",
			Handler:    _DashboardService_DeleteTeamRepo_Handler,
		},
		{
			MethodName: "AddRepoPattern",
			Handler:    _DashboardService_AddRepoPattern_Handler,
		},
		{
			MethodName: "RemoveRepoPattern",
			Handler:    _DashboardService_RemoveRepoPattern_Handler,
		},
		{
			MethodName: "SetTeamRepoType",
			Handler:    _DashboardService_SetTeamRepoType_Handler,
		},
		{
			MethodName: "GetTeamAdminSettings",
			Handler:    _DashboardService_GetTeamAdminSettings_Handler,
		},
		{
			MethodName: "GetTeamAdminSettingsOrEmptyIfNotInTeam",
			Handler:    _DashboardService_GetTeamAdminSettingsOrEmptyIfNotInTeam_Handler,
		},
		{
			MethodName: "GetBaseTeamAdminSettings",
			Handler:    _DashboardService_GetBaseTeamAdminSettings_Handler,
		},
		{
			MethodName: "UpdateTeamAdminSettings",
			Handler:    _DashboardService_UpdateTeamAdminSettings_Handler,
		},
		{
			MethodName: "CreateTeamFreeTrialCode",
			Handler:    _DashboardService_CreateTeamFreeTrialCode_Handler,
		},
		{
			MethodName: "GetTeamAnalytics",
			Handler:    _DashboardService_GetTeamAnalytics_Handler,
		},
		{
			MethodName: "GetUserAnalytics",
			Handler:    _DashboardService_GetUserAnalytics_Handler,
		},
		{
			MethodName: "GetTeamRawData",
			Handler:    _DashboardService_GetTeamRawData_Handler,
		},
		{
			MethodName: "GetClientUsageData",
			Handler:    _DashboardService_GetClientUsageData_Handler,
		},
		{
			MethodName: "GetCurrentPeriodUsage",
			Handler:    _DashboardService_GetCurrentPeriodUsage_Handler,
		},
		{
			MethodName: "GetPlanInfo",
			Handler:    _DashboardService_GetPlanInfo_Handler,
		},
		{
			MethodName: "GetUsageLimitPolicyStatus",
			Handler:    _DashboardService_GetUsageLimitPolicyStatus_Handler,
		},
		{
			MethodName: "GetAdvancedAnalyticsEnabled",
			Handler:    _DashboardService_GetAdvancedAnalyticsEnabled_Handler,
		},
		{
			MethodName: "GetTokenUsage",
			Handler:    _DashboardService_GetTokenUsage_Handler,
		},
		{
			MethodName: "ValidateBedrockIamRole",
			Handler:    _DashboardService_ValidateBedrockIamRole_Handler,
		},
		{
			MethodName: "AddUserToEarlyAccessList",
			Handler:    _DashboardService_AddUserToEarlyAccessList_Handler,
		},
		{
			MethodName: "GetTeamSpend",
			Handler:    _DashboardService_GetTeamSpend_Handler,
		},
		{
			MethodName: "GetCurrentBillingCycle",
			Handler:    _DashboardService_GetCurrentBillingCycle_Handler,
		},
		{
			MethodName: "GetMonthlyBillingCycle",
			Handler:    _DashboardService_GetMonthlyBillingCycle_Handler,
		},
		{
			MethodName: "GetBugbotSettings",
			Handler:    _DashboardService_GetBugbotSettings_Handler,
		},
		{
			MethodName: "GetBugbotAnalyticsV2",
			Handler:    _DashboardService_GetBugbotAnalyticsV2_Handler,
		},
		{
			MethodName: "GetBugBotPRAnalytics",
			Handler:    _DashboardService_GetBugBotPRAnalytics_Handler,
		},
		{
			MethodName: "GetGithubInstallations",
			Handler:    _DashboardService_GetGithubInstallations_Handler,
		},
		{
			MethodName: "GetInstallationRepos",
			Handler:    _DashboardService_GetInstallationRepos_Handler,
		},
		{
			MethodName: "FetchAllInstallationRepos",
			Handler:    _DashboardService_FetchAllInstallationRepos_Handler,
		},
		{
			MethodName: "GetInstallationGithubUsers",
			Handler:    _DashboardService_GetInstallationGithubUsers_Handler,
		},
		{
			MethodName: "GetTeamGithubUsers",
			Handler:    _DashboardService_GetTeamGithubUsers_Handler,
		},
		{
			MethodName: "AddGithubUsersToTeam",
			Handler:    _DashboardService_AddGithubUsersToTeam_Handler,
		},
		{
			MethodName: "GetUserPullRequests",
			Handler:    _DashboardService_GetUserPullRequests_Handler,
		},
		{
			MethodName: "GetUserReviewRequests",
			Handler:    _DashboardService_GetUserReviewRequests_Handler,
		},
		{
			MethodName: "UpdateGithubRepoSettings",
			Handler:    _DashboardService_UpdateGithubRepoSettings_Handler,
		},
		{
			MethodName: "UpdateGithubInstallationSettings",
			Handler:    _DashboardService_UpdateGithubInstallationSettings_Handler,
		},
		{
			MethodName: "UpdateAllGithubRepoSettings",
			Handler:    _DashboardService_UpdateAllGithubRepoSettings_Handler,
		},
		{
			MethodName: "UpdateGithubInstallationTeamScope",
			Handler:    _DashboardService_UpdateGithubInstallationTeamScope_Handler,
		},
		{
			MethodName: "UpdateSelfGithubAllowlist",
			Handler:    _DashboardService_UpdateSelfGithubAllowlist_Handler,
		},
		{
			MethodName: "GetTeamBugbotSettings",
			Handler:    _DashboardService_GetTeamBugbotSettings_Handler,
		},
		{
			MethodName: "UpdateTeamBugbotSettings",
			Handler:    _DashboardService_UpdateTeamBugbotSettings_Handler,
		},
		{
			MethodName: "GetBugbotUserSettings",
			Handler:    _DashboardService_GetBugbotUserSettings_Handler,
		},
		{
			MethodName: "UpdateBugbotUserSettings",
			Handler:    _DashboardService_UpdateBugbotUserSettings_Handler,
		},
		{
			MethodName: "GetBugBotProUserSettings",
			Handler:    _DashboardService_GetBugBotProUserSettings_Handler,
		},
		{
			MethodName: "UpdateBugBotProUserSettings",
			Handler:    _DashboardService_UpdateBugBotProUserSettings_Handler,
		},
		{
			MethodName: "RecordBugbotDeeplinkEvent",
			Handler:    _DashboardService_RecordBugbotDeeplinkEvent_Handler,
		},
		{
			MethodName: "RecordBugbotDeeplinkEventUnauthenticated",
			Handler:    _DashboardService_RecordBugbotDeeplinkEventUnauthenticated_Handler,
		},
		{
			MethodName: "RevokeBugBotLicenses",
			Handler:    _DashboardService_RevokeBugBotLicenses_Handler,
		},
		{
			MethodName: "RevokeUserBugbotLicense",
			Handler:    _DashboardService_RevokeUserBugbotLicense_Handler,
		},
		{
			MethodName: "StartBugbotBackfillLearning",
			Handler:    _DashboardService_StartBugbotBackfillLearning_Handler,
		},
		{
			MethodName: "SetSlackAuth",
			Handler:    _DashboardService_SetSlackAuth_Handler,
		},
		{
			MethodName: "GetSlackTeamSettings",
			Handler:    _DashboardService_GetSlackTeamSettings_Handler,
		},
		{
			MethodName: "UpdateSlackTeamSettings",
			Handler:    _DashboardService_UpdateSlackTeamSettings_Handler,
		},
		{
			MethodName: "GetSlackSettings",
			Handler:    _DashboardService_GetSlackSettings_Handler,
		},
		{
			MethodName: "GetSlackModelOptions",
			Handler:    _DashboardService_GetSlackModelOptions_Handler,
		},
		{
			MethodName: "GetSlackInstallUrl",
			Handler:    _DashboardService_GetSlackInstallUrl_Handler,
		},
		{
			MethodName: "GetSlackInstallUrlPublic",
			Handler:    _DashboardService_GetSlackInstallUrlPublic_Handler,
		},
		{
			MethodName: "GetFilteredUsageEvents",
			Handler:    _DashboardService_GetFilteredUsageEvents_Handler,
		},
		{
			MethodName: "GetAggregatedUsageEvents",
			Handler:    _DashboardService_GetAggregatedUsageEvents_Handler,
		},
		{
			MethodName: "GetAuditLogs",
			Handler:    _DashboardService_GetAuditLogs_Handler,
		},
		{
			MethodName: "GetUserPrivacyMode",
			Handler:    _DashboardService_GetUserPrivacyMode_Handler,
		},
		{
			MethodName: "SetUserPrivacyMode",
			Handler:    _DashboardService_SetUserPrivacyMode_Handler,
		},
		{
			MethodName: "WebAcknowledgeGracePeriodDisclaimer",
			Handler:    _DashboardService_WebAcknowledgeGracePeriodDisclaimer_Handler,
		},
		{
			MethodName: "SkipPrivacyModeGracePeriod",
			Handler:    _DashboardService_SkipPrivacyModeGracePeriod_Handler,
		},
		{
			MethodName: "NeedsPrivacyModeMigration",
			Handler:    _DashboardService_NeedsPrivacyModeMigration_Handler,
		},
		{
			MethodName: "UpdateTeamPrivacyModeMigrationOptOut",
			Handler:    _DashboardService_UpdateTeamPrivacyModeMigrationOptOut_Handler,
		},
		{
			MethodName: "ShareConversation",
			Handler:    _DashboardService_ShareConversation_Handler,
		},
		{
			MethodName: "GetSharedConversation",
			Handler:    _DashboardService_GetSharedConversation_Handler,
		},
		{
			MethodName: "GetPublicSharedConversation",
			Handler:    _DashboardService_GetPublicSharedConversation_Handler,
		},
		{
			MethodName: "ListSharedConversations",
			Handler:    _DashboardService_ListSharedConversations_Handler,
		},
		{
			MethodName: "DeleteSharedConversation",
			Handler:    _DashboardService_DeleteSharedConversation_Handler,
		},
		{
			MethodName: "UpdateSharedConversationVisibility",
			Handler:    _DashboardService_UpdateSharedConversationVisibility_Handler,
		},
		{
			MethodName: "RevokeTeamInviteLink",
			Handler:    _DashboardService_RevokeTeamInviteLink_Handler,
		},
		{
			MethodName: "ListTeamInviteLinks",
			Handler:    _DashboardService_ListTeamInviteLinks_Handler,
		},
		{
			MethodName: "UpdateUserName",
			Handler:    _DashboardService_UpdateUserName_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _DashboardService_ListInvoices_Handler,
		},
		{
			MethodName: "IsEligibleForRefund",
			Handler:    _DashboardService_IsEligibleForRefund_Handler,
		},
		{
			MethodName: "GetRemainingRefunds",
			Handler:    _DashboardService_GetRemainingRefunds_Handler,
		},
		{
			MethodName: "GetServiceAccountSpendLimit",
			Handler:    _DashboardService_GetServiceAccountSpendLimit_Handler,
		},
		{
			MethodName: "SetServiceAccountSpendLimit",
			Handler:    _DashboardService_SetServiceAccountSpendLimit_Handler,
		},
		{
			MethodName: "SetUserHardLimit",
			Handler:    _DashboardService_SetUserHardLimit_Handler,
		},
		{
			MethodName: "SetUserMonthlyLimit",
			Handler:    _DashboardService_SetUserMonthlyLimit_Handler,
		},
		{
			MethodName: "ToggleMarketingEmailOpt",
			Handler:    _DashboardService_ToggleMarketingEmailOpt_Handler,
		},
		{
			MethodName: "GetMarketingEmailOpt",
			Handler:    _DashboardService_GetMarketingEmailOpt_Handler,
		},
		{
			MethodName: "GetGlobalLeaderboardOptIn",
			Handler:    _DashboardService_GetGlobalLeaderboardOptIn_Handler,
		},
		{
			MethodName: "SetGlobalLeaderboardOptIn",
			Handler:    _DashboardService_SetGlobalLeaderboardOptIn_Handler,
		},
		{
			MethodName: "CreateTeamApiKey",
			Handler:    _DashboardService_CreateTeamApiKey_Handler,
		},
		{
			MethodName: "RevokeTeamApiKey",
			Handler:    _DashboardService_RevokeTeamApiKey_Handler,
		},
		{
			MethodName: "ListTeamApiKeys",
			Handler:    _DashboardService_ListTeamApiKeys_Handler,
		},
		{
			MethodName: "CreateTeamServiceAccount",
			Handler:    _DashboardService_CreateTeamServiceAccount_Handler,
		},
		{
			MethodName: "ListTeamServiceAccounts",
			Handler:    _DashboardService_ListTeamServiceAccounts_Handler,
		},
		{
			MethodName: "DeleteTeamServiceAccount",
			Handler:    _DashboardService_DeleteTeamServiceAccount_Handler,
		},
		{
			MethodName: "ArchiveTeamServiceAccount",
			Handler:    _DashboardService_ArchiveTeamServiceAccount_Handler,
		},
		{
			MethodName: "RotateServiceAccountApiKey",
			Handler:    _DashboardService_RotateServiceAccountApiKey_Handler,
		},
		{
			MethodName: "GetTeamRepositoriesForServiceAccountScope",
			Handler:    _DashboardService_GetTeamRepositoriesForServiceAccountScope_Handler,
		},
		{
			MethodName: "UpdateServiceAccountRepoScope",
			Handler:    _DashboardService_UpdateServiceAccountRepoScope_Handler,
		},
		{
			MethodName: "CreateUserApiKey",
			Handler:    _DashboardService_CreateUserApiKey_Handler,
		},
		{
			MethodName: "RevokeUserApiKey",
			Handler:    _DashboardService_RevokeUserApiKey_Handler,
		},
		{
			MethodName: "ListUserApiKeys",
			Handler:    _DashboardService_ListUserApiKeys_Handler,
		},
		{
			MethodName: "ConfirmGithubInstallation",
			Handler:    _DashboardService_ConfirmGithubInstallation_Handler,
		},
		{
			MethodName: "UpdateTeamName",
			Handler:    _DashboardService_UpdateTeamName_Handler,
		},
		{
			MethodName: "UpdateTeamDashboardAnalyticsSetting",
			Handler:    _DashboardService_UpdateTeamDashboardAnalyticsSetting_Handler,
		},
		{
			MethodName: "GetSlackUserSettings",
			Handler:    _DashboardService_GetSlackUserSettings_Handler,
		},
		{
			MethodName: "UpdateSlackUserSettings",
			Handler:    _DashboardService_UpdateSlackUserSettings_Handler,
		},
		{
			MethodName: "GetSlackRepoRoutingRules",
			Handler:    _DashboardService_GetSlackRepoRoutingRules_Handler,
		},
		{
			MethodName: "CreateSlackRepoRoutingRule",
			Handler:    _DashboardService_CreateSlackRepoRoutingRule_Handler,
		},
		{
			MethodName: "UpdateSlackRepoRoutingRule",
			Handler:    _DashboardService_UpdateSlackRepoRoutingRule_Handler,
		},
		{
			MethodName: "DeleteSlackRepoRoutingRule",
			Handler:    _DashboardService_DeleteSlackRepoRoutingRule_Handler,
		},
		{
			MethodName: "IsOnNewPricing",
			Handler:    _DashboardService_IsOnNewPricing_Handler,
		},
		{
			MethodName: "GetLinearAuthUrl",
			Handler:    _DashboardService_GetLinearAuthUrl_Handler,
		},
		{
			MethodName: "GetLinearStatus",
			Handler:    _DashboardService_GetLinearStatus_Handler,
		},
		{
			MethodName: "DisconnectLinear",
			Handler:    _DashboardService_DisconnectLinear_Handler,
		},
		{
			MethodName: "GetLinearTeams",
			Handler:    _DashboardService_GetLinearTeams_Handler,
		},
		{
			MethodName: "GetLinearSettings",
			Handler:    _DashboardService_GetLinearSettings_Handler,
		},
		{
			MethodName: "UpdateLinearTeamSetting",
			Handler:    _DashboardService_UpdateLinearTeamSetting_Handler,
		},
		{
			MethodName: "UpdateLinearProjectSetting",
			Handler:    _DashboardService_UpdateLinearProjectSetting_Handler,
		},
		{
			MethodName: "GetLinearLabels",
			Handler:    _DashboardService_GetLinearLabels_Handler,
		},
		{
			MethodName: "GetLinearIssues",
			Handler:    _DashboardService_GetLinearIssues_Handler,
		},
		{
			MethodName: "DeleteBedrockIamRole",
			Handler:    _DashboardService_DeleteBedrockIamRole_Handler,
		},
		{
			MethodName: "UnlinkSlackAccess",
			Handler:    _DashboardService_UnlinkSlackAccess_Handler,
		},
		{
			MethodName: "ListSlackConversations",
			Handler:    _DashboardService_ListSlackConversations_Handler,
		},
		{
			MethodName: "LogSlackbotAuthConversionFunnel",
			Handler:    _DashboardService_LogSlackbotAuthConversionFunnel_Handler,
		},
		{
			MethodName: "LogClickedConnectSlack",
			Handler:    _DashboardService_LogClickedConnectSlack_Handler,
		},
		{
			MethodName: "CheckUserApiKeyAccess",
			Handler:    _DashboardService_CheckUserApiKeyAccess_Handler,
		},
		{
			MethodName: "IsAllowedFreeTrialUsage",
			Handler:    _DashboardService_IsAllowedFreeTrialUsage_Handler,
		},
		{
			MethodName: "CompletedLinkSlackAccount",
			Handler:    _DashboardService_CompletedLinkSlackAccount_Handler,
		},
		{
			MethodName: "NotifyTeamAdmins",
			Handler:    _DashboardService_NotifyTeamAdmins_Handler,
		},
		{
			MethodName: "GetAdminNotificationStatus",
			Handler:    _DashboardService_GetAdminNotificationStatus_Handler,
		},
		{
			MethodName: "OptOutNewPricing",
			Handler:    _DashboardService_OptOutNewPricing_Handler,
		},
		{
			MethodName: "SubmitFeedback",
			Handler:    _DashboardService_SubmitFeedback_Handler,
		},
		{
			MethodName: "CanStudentReverify",
			Handler:    _DashboardService_CanStudentReverify_Handler,
		},
		{
			MethodName: "ClientAction",
			Handler:    _DashboardService_ClientAction_Handler,
		},
		{
			MethodName: "ListUsageAlerts",
			Handler:    _DashboardService_ListUsageAlerts_Handler,
		},
		{
			MethodName: "CreateUsageAlerts",
			Handler:    _DashboardService_CreateUsageAlerts_Handler,
		},
		{
			MethodName: "DeleteUsageAlerts",
			Handler:    _DashboardService_DeleteUsageAlerts_Handler,
		},
		{
			MethodName: "UpdateUsageAlerts",
			Handler:    _DashboardService_UpdateUsageAlerts_Handler,
		},
		{
			MethodName: "RequestIndividualLimitsOptOut",
			Handler:    _DashboardService_RequestIndividualLimitsOptOut_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	DebuggerService_GitFilter_FullMethodName   = "/aiserver.v1.DebuggerService/GitFilter"
	DebuggerService_FileFilter_FullMethodName  = "/aiserver.v1.DebuggerService/FileFilter"
	DebuggerService_BugAnalysis_FullMethodName = "/aiserver.v1.DebuggerService/BugAnalysis"
)

// DebuggerServiceClient is the client API for DebuggerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.DebuggerService (var: mYe)
type DebuggerServiceClient interface {
	GitFilter(ctx context.Context, in *GitFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GitFilterResponse], error)
	FileFilter(ctx context.Context, in *FileFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileFilterResponse], error)
	BugAnalysis(ctx context.Context, in *BugAnalysisRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BugAnalysisResponse], error)
}

type debuggerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDebuggerServiceClient(cc grpc.ClientConnInterface) DebuggerServiceClient {
	return &debuggerServiceClient{cc}
}

func (c *debuggerServiceClient) GitFilter(ctx context.Context, in *GitFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GitFilterResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DebuggerService_ServiceDesc.Streams[0], DebuggerService_GitFilter_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GitFilterRequest, GitFilterResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_GitFilterClient = grpc.ServerStreamingClient[GitFilterResponse]

func (c *debuggerServiceClient) FileFilter(ctx context.Context, in *FileFilterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileFilterResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DebuggerService_ServiceDesc.Streams[1], DebuggerService_FileFilter_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileFilterRequest, FileFilterResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_FileFilterClient = grpc.ServerStreamingClient[FileFilterResponse]

func (c *debuggerServiceClient) BugAnalysis(ctx context.Context, in *BugAnalysisRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BugAnalysisResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DebuggerService_ServiceDesc.Streams[2], DebuggerService_BugAnalysis_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BugAnalysisRequest, BugAnalysisResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_BugAnalysisClient = grpc.ServerStreamingClient[BugAnalysisResponse]

// DebuggerServiceServer is the server API for DebuggerService service.
// All implementations must embed UnimplementedDebuggerServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.DebuggerService (var: mYe)
type DebuggerServiceServer interface {
	GitFilter(*GitFilterRequest, grpc.ServerStreamingServer[GitFilterResponse]) error
	FileFilter(*FileFilterRequest, grpc.ServerStreamingServer[FileFilterResponse]) error
	BugAnalysis(*BugAnalysisRequest, grpc.ServerStreamingServer[BugAnalysisResponse]) error
	mustEmbedUnimplementedDebuggerServiceServer()
}

// UnimplementedDebuggerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDebuggerServiceServer struct{}

func (UnimplementedDebuggerServiceServer) GitFilter(*GitFilterRequest, grpc.ServerStreamingServer[GitFilterResponse]) error {
	return status.Error(codes.Unimplemented, "method GitFilter not implemented")
}
func (UnimplementedDebuggerServiceServer) FileFilter(*FileFilterRequest, grpc.ServerStreamingServer[FileFilterResponse]) error {
	return status.Error(codes.Unimplemented, "method FileFilter not implemented")
}
func (UnimplementedDebuggerServiceServer) BugAnalysis(*BugAnalysisRequest, grpc.ServerStreamingServer[BugAnalysisResponse]) error {
	return status.Error(codes.Unimplemented, "method BugAnalysis not implemented")
}
func (UnimplementedDebuggerServiceServer) mustEmbedUnimplementedDebuggerServiceServer() {}
func (UnimplementedDebuggerServiceServer) testEmbeddedByValue()                         {}

// UnsafeDebuggerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebuggerServiceServer will
// result in compilation errors.
type UnsafeDebuggerServiceServer interface {
	mustEmbedUnimplementedDebuggerServiceServer()
}

func RegisterDebuggerServiceServer(s grpc.ServiceRegistrar, srv DebuggerServiceServer) {
	// If the following call panics, it indicates UnimplementedDebuggerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DebuggerService_ServiceDesc, srv)
}

func _DebuggerService_GitFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GitFilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebuggerServiceServer).GitFilter(m, &grpc.GenericServerStream[GitFilterRequest, GitFilterResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_GitFilterServer = grpc.ServerStreamingServer[GitFilterResponse]

func _DebuggerService_FileFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileFilterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebuggerServiceServer).FileFilter(m, &grpc.GenericServerStream[FileFilterRequest, FileFilterResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_FileFilterServer = grpc.ServerStreamingServer[FileFilterResponse]

func _DebuggerService_BugAnalysis_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BugAnalysisRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebuggerServiceServer).BugAnalysis(m, &grpc.GenericServerStream[BugAnalysisRequest, BugAnalysisResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebuggerService_BugAnalysisServer = grpc.ServerStreamingServer[BugAnalysisResponse]

// DebuggerService_ServiceDesc is the grpc.ServiceDesc for DebuggerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DebuggerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.DebuggerService",
	HandlerType: (*DebuggerServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GitFilter",
			Handler:       _DebuggerService_GitFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FileFilter",
			Handler:       _DebuggerService_FileFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BugAnalysis",
			Handler:       _DebuggerService_BugAnalysis_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	DeeplinkService_CreateDeeplink_FullMethodName  = "/aiserver.v1.DeeplinkService/CreateDeeplink"
	DeeplinkService_GetDeeplinkData_FullMethodName = "/aiserver.v1.DeeplinkService/GetDeeplinkData"
	DeeplinkService_ListDeeplinks_FullMethodName   = "/aiserver.v1.DeeplinkService/ListDeeplinks"
)

// DeeplinkServiceClient is the client API for DeeplinkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.DeeplinkService (var: dYe)
type DeeplinkServiceClient interface {
	CreateDeeplink(ctx context.Context, in *CreateDeeplinkRequest, opts ...grpc.CallOption) (*CreateDeeplinkResponse, error)
	GetDeeplinkData(ctx context.Context, in *GetDeeplinkDataRequest, opts ...grpc.CallOption) (*GetDeeplinkDataResponse, error)
	ListDeeplinks(ctx context.Context, in *ListDeeplinksRequest, opts ...grpc.CallOption) (*ListDeeplinksResponse, error)
}

type deeplinkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeeplinkServiceClient(cc grpc.ClientConnInterface) DeeplinkServiceClient {
	return &deeplinkServiceClient{cc}
}

func (c *deeplinkServiceClient) CreateDeeplink(ctx context.Context, in *CreateDeeplinkRequest, opts ...grpc.CallOption) (*CreateDeeplinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDeeplinkResponse)
	err := c.cc.Invoke(ctx, DeeplinkService_CreateDeeplink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deeplinkServiceClient) GetDeeplinkData(ctx context.Context, in *GetDeeplinkDataRequest, opts ...grpc.CallOption) (*GetDeeplinkDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDeeplinkDataResponse)
	err := c.cc.Invoke(ctx, DeeplinkService_GetDeeplinkData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deeplinkServiceClient) ListDeeplinks(ctx context.Context, in *ListDeeplinksRequest, opts ...grpc.CallOption) (*ListDeeplinksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDeeplinksResponse)
	err := c.cc.Invoke(ctx, DeeplinkService_ListDeeplinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeeplinkServiceServer is the server API for DeeplinkService service.
// All implementations must embed UnimplementedDeeplinkServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.DeeplinkService (var: dYe)
type DeeplinkServiceServer interface {
	CreateDeeplink(context.Context, *CreateDeeplinkRequest) (*CreateDeeplinkResponse, error)
	GetDeeplinkData(context.Context, *GetDeeplinkDataRequest) (*GetDeeplinkDataResponse, error)
	ListDeeplinks(context.Context, *ListDeeplinksRequest) (*ListDeeplinksResponse, error)
	mustEmbedUnimplementedDeeplinkServiceServer()
}

// UnimplementedDeeplinkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeeplinkServiceServer struct{}

func (UnimplementedDeeplinkServiceServer) CreateDeeplink(context.Context, *CreateDeeplinkRequest) (*CreateDeeplinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateDeeplink not implemented")
}
func (UnimplementedDeeplinkServiceServer) GetDeeplinkData(context.Context, *GetDeeplinkDataRequest) (*GetDeeplinkDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDeeplinkData not implemented")
}
func (UnimplementedDeeplinkServiceServer) ListDeeplinks(context.Context, *ListDeeplinksRequest) (*ListDeeplinksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDeeplinks not implemented")
}
func (UnimplementedDeeplinkServiceServer) mustEmbedUnimplementedDeeplinkServiceServer() {}
func (UnimplementedDeeplinkServiceServer) testEmbeddedByValue()                         {}

// UnsafeDeeplinkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeeplinkServiceServer will
// result in compilation errors.
type UnsafeDeeplinkServiceServer interface {
	mustEmbedUnimplementedDeeplinkServiceServer()
}

func RegisterDeeplinkServiceServer(s grpc.ServiceRegistrar, srv DeeplinkServiceServer) {
	// If the following call panics, it indicates UnimplementedDeeplinkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeeplinkService_ServiceDesc, srv)
}

func _DeeplinkService_CreateDeeplink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeeplinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeeplinkServiceServer).CreateDeeplink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeeplinkService_CreateDeeplink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeeplinkServiceServer).CreateDeeplink(ctx, req.(*CreateDeeplinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeeplinkService_GetDeeplinkData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeeplinkDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeeplinkServiceServer).GetDeeplinkData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeeplinkService_GetDeeplinkData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeeplinkServiceServer).GetDeeplinkData(ctx, req.(*GetDeeplinkDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeeplinkService_ListDeeplinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDeeplinksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeeplinkServiceServer).ListDeeplinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeeplinkService_ListDeeplinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeeplinkServiceServer).ListDeeplinks(ctx, req.(*ListDeeplinksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeeplinkService_ServiceDesc is the grpc.ServiceDesc for DeeplinkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeeplinkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.DeeplinkService",
	HandlerType: (*DeeplinkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDeeplink",
			Handler:    _DeeplinkService_CreateDeeplink_Handler,
		},
		{
			MethodName: "GetDeeplinkData",
			Handler:    _DeeplinkService_GetDeeplinkData_Handler,
		},
		{
			MethodName: "ListDeeplinks",
			Handler:    _DeeplinkService_ListDeeplinks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	EnterpriseAdminService_GetManualEnterpriseContract_FullMethodName    = "/aiserver.v1.EnterpriseAdminService/GetManualEnterpriseContract"
	EnterpriseAdminService_ListManualEnterpriseContracts_FullMethodName  = "/aiserver.v1.EnterpriseAdminService/ListManualEnterpriseContracts"
	EnterpriseAdminService_CreateManualEnterpriseContract_FullMethodName = "/aiserver.v1.EnterpriseAdminService/CreateManualEnterpriseContract"
	EnterpriseAdminService_CreateContractExpansion_FullMethodName        = "/aiserver.v1.EnterpriseAdminService/CreateContractExpansion"
	EnterpriseAdminService_UpsertManualEnterpriseContract_FullMethodName = "/aiserver.v1.EnterpriseAdminService/UpsertManualEnterpriseContract"
	EnterpriseAdminService_DeleteManualEnterpriseContract_FullMethodName = "/aiserver.v1.EnterpriseAdminService/DeleteManualEnterpriseContract"
	EnterpriseAdminService_ListEnterpriseContracts_FullMethodName        = "/aiserver.v1.EnterpriseAdminService/ListEnterpriseContracts"
	EnterpriseAdminService_EnableTokenBasedPricing_FullMethodName        = "/aiserver.v1.EnterpriseAdminService/EnableTokenBasedPricing"
	EnterpriseAdminService_GetEnterpriseStatus_FullMethodName            = "/aiserver.v1.EnterpriseAdminService/GetEnterpriseStatus"
	EnterpriseAdminService_StartTokenBasedTrial_FullMethodName           = "/aiserver.v1.EnterpriseAdminService/StartTokenBasedTrial"
)

// EnterpriseAdminServiceClient is the client API for EnterpriseAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.EnterpriseAdminService (var: hYe)
type EnterpriseAdminServiceClient interface {
	GetManualEnterpriseContract(ctx context.Context, in *GetManualEnterpriseContractRequest, opts ...grpc.CallOption) (*GetManualEnterpriseContractResponse, error)
	ListManualEnterpriseContracts(ctx context.Context, in *ListManualEnterpriseContractsRequest, opts ...grpc.CallOption) (*ListManualEnterpriseContractsResponse, error)
	CreateManualEnterpriseContract(ctx context.Context, in *CreateManualEnterpriseContractRequest, opts ...grpc.CallOption) (*CreateManualEnterpriseContractResponse, error)
	CreateContractExpansion(ctx context.Context, in *CreateContractExpansionRequest, opts ...grpc.CallOption) (*CreateContractExpansionResponse, error)
	UpsertManualEnterpriseContract(ctx context.Context, in *UpsertManualEnterpriseContractRequest, opts ...grpc.CallOption) (*UpsertManualEnterpriseContractResponse, error)
	DeleteManualEnterpriseContract(ctx context.Context, in *DeleteManualEnterpriseContractRequest, opts ...grpc.CallOption) (*DeleteManualEnterpriseContractResponse, error)
	ListEnterpriseContracts(ctx context.Context, in *ListEnterpriseContractsRequest, opts ...grpc.CallOption) (*ListEnterpriseContractsResponse, error)
	EnableTokenBasedPricing(ctx context.Context, in *EnableTokenBasedPricingRequest, opts ...grpc.CallOption) (*EnableTokenBasedPricingResponse, error)
	GetEnterpriseStatus(ctx context.Context, in *GetEnterpriseStatusRequest, opts ...grpc.CallOption) (*GetEnterpriseStatusResponse, error)
	StartTokenBasedTrial(ctx context.Context, in *StartTokenBasedTrialRequest, opts ...grpc.CallOption) (*StartTokenBasedTrialResponse, error)
}

type enterpriseAdminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEnterpriseAdminServiceClient(cc grpc.ClientConnInterface) EnterpriseAdminServiceClient {
	return &enterpriseAdminServiceClient{cc}
}

func (c *enterpriseAdminServiceClient) GetManualEnterpriseContract(ctx context.Context, in *GetManualEnterpriseContractRequest, opts ...grpc.CallOption) (*GetManualEnterpriseContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetManualEnterpriseContractResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_GetManualEnterpriseContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) ListManualEnterpriseContracts(ctx context.Context, in *ListManualEnterpriseContractsRequest, opts ...grpc.CallOption) (*ListManualEnterpriseContractsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListManualEnterpriseContractsResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_ListManualEnterpriseContracts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) CreateManualEnterpriseContract(ctx context.Context, in *CreateManualEnterpriseContractRequest, opts ...grpc.CallOption) (*CreateManualEnterpriseContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateManualEnterpriseContractResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_CreateManualEnterpriseContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) CreateContractExpansion(ctx context.Context, in *CreateContractExpansionRequest, opts ...grpc.CallOption) (*CreateContractExpansionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateContractExpansionResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_CreateContractExpansion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) UpsertManualEnterpriseContract(ctx context.Context, in *UpsertManualEnterpriseContractRequest, opts ...grpc.CallOption) (*UpsertManualEnterpriseContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertManualEnterpriseContractResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_UpsertManualEnterpriseContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) DeleteManualEnterpriseContract(ctx context.Context, in *DeleteManualEnterpriseContractRequest, opts ...grpc.CallOption) (*DeleteManualEnterpriseContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteManualEnterpriseContractResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_DeleteManualEnterpriseContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) ListEnterpriseContracts(ctx context.Context, in *ListEnterpriseContractsRequest, opts ...grpc.CallOption) (*ListEnterpriseContractsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEnterpriseContractsResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_ListEnterpriseContracts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) EnableTokenBasedPricing(ctx context.Context, in *EnableTokenBasedPricingRequest, opts ...grpc.CallOption) (*EnableTokenBasedPricingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableTokenBasedPricingResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_EnableTokenBasedPricing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) GetEnterpriseStatus(ctx context.Context, in *GetEnterpriseStatusRequest, opts ...grpc.CallOption) (*GetEnterpriseStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEnterpriseStatusResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_GetEnterpriseStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *enterpriseAdminServiceClient) StartTokenBasedTrial(ctx context.Context, in *StartTokenBasedTrialRequest, opts ...grpc.CallOption) (*StartTokenBasedTrialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartTokenBasedTrialResponse)
	err := c.cc.Invoke(ctx, EnterpriseAdminService_StartTokenBasedTrial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnterpriseAdminServiceServer is the server API for EnterpriseAdminService service.
// All implementations must embed UnimplementedEnterpriseAdminServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.EnterpriseAdminService (var: hYe)
type EnterpriseAdminServiceServer interface {
	GetManualEnterpriseContract(context.Context, *GetManualEnterpriseContractRequest) (*GetManualEnterpriseContractResponse, error)
	ListManualEnterpriseContracts(context.Context, *ListManualEnterpriseContractsRequest) (*ListManualEnterpriseContractsResponse, error)
	CreateManualEnterpriseContract(context.Context, *CreateManualEnterpriseContractRequest) (*CreateManualEnterpriseContractResponse, error)
	CreateContractExpansion(context.Context, *CreateContractExpansionRequest) (*CreateContractExpansionResponse, error)
	UpsertManualEnterpriseContract(context.Context, *UpsertManualEnterpriseContractRequest) (*UpsertManualEnterpriseContractResponse, error)
	DeleteManualEnterpriseContract(context.Context, *DeleteManualEnterpriseContractRequest) (*DeleteManualEnterpriseContractResponse, error)
	ListEnterpriseContracts(context.Context, *ListEnterpriseContractsRequest) (*ListEnterpriseContractsResponse, error)
	EnableTokenBasedPricing(context.Context, *EnableTokenBasedPricingRequest) (*EnableTokenBasedPricingResponse, error)
	GetEnterpriseStatus(context.Context, *GetEnterpriseStatusRequest) (*GetEnterpriseStatusResponse, error)
	StartTokenBasedTrial(context.Context, *StartTokenBasedTrialRequest) (*StartTokenBasedTrialResponse, error)
	mustEmbedUnimplementedEnterpriseAdminServiceServer()
}

// UnimplementedEnterpriseAdminServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEnterpriseAdminServiceServer struct{}

func (UnimplementedEnterpriseAdminServiceServer) GetManualEnterpriseContract(context.Context, *GetManualEnterpriseContractRequest) (*GetManualEnterpriseContractResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetManualEnterpriseContract not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) ListManualEnterpriseContracts(context.Context, *ListManualEnterpriseContractsRequest) (*ListManualEnterpriseContractsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListManualEnterpriseContracts not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) CreateManualEnterpriseContract(context.Context, *CreateManualEnterpriseContractRequest) (*CreateManualEnterpriseContractResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateManualEnterpriseContract not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) CreateContractExpansion(context.Context, *CreateContractExpansionRequest) (*CreateContractExpansionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateContractExpansion not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) UpsertManualEnterpriseContract(context.Context, *UpsertManualEnterpriseContractRequest) (*UpsertManualEnterpriseContractResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertManualEnterpriseContract not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) DeleteManualEnterpriseContract(context.Context, *DeleteManualEnterpriseContractRequest) (*DeleteManualEnterpriseContractResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteManualEnterpriseContract not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) ListEnterpriseContracts(context.Context, *ListEnterpriseContractsRequest) (*ListEnterpriseContractsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEnterpriseContracts not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) EnableTokenBasedPricing(context.Context, *EnableTokenBasedPricingRequest) (*EnableTokenBasedPricingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableTokenBasedPricing not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) GetEnterpriseStatus(context.Context, *GetEnterpriseStatusRequest) (*GetEnterpriseStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEnterpriseStatus not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) StartTokenBasedTrial(context.Context, *StartTokenBasedTrialRequest) (*StartTokenBasedTrialResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartTokenBasedTrial not implemented")
}
func (UnimplementedEnterpriseAdminServiceServer) mustEmbedUnimplementedEnterpriseAdminServiceServer() {
}
func (UnimplementedEnterpriseAdminServiceServer) testEmbeddedByValue() {}

// UnsafeEnterpriseAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnterpriseAdminServiceServer will
// result in compilation errors.
type UnsafeEnterpriseAdminServiceServer interface {
	mustEmbedUnimplementedEnterpriseAdminServiceServer()
}

func RegisterEnterpriseAdminServiceServer(s grpc.ServiceRegistrar, srv EnterpriseAdminServiceServer) {
	// If the following call panics, it indicates UnimplementedEnterpriseAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EnterpriseAdminService_ServiceDesc, srv)
}

func _EnterpriseAdminService_GetManualEnterpriseContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetManualEnterpriseContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).GetManualEnterpriseContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_GetManualEnterpriseContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).GetManualEnterpriseContract(ctx, req.(*GetManualEnterpriseContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_ListManualEnterpriseContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListManualEnterpriseContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).ListManualEnterpriseContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_ListManualEnterpriseContracts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).ListManualEnterpriseContracts(ctx, req.(*ListManualEnterpriseContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_CreateManualEnterpriseContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateManualEnterpriseContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).CreateManualEnterpriseContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_CreateManualEnterpriseContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).CreateManualEnterpriseContract(ctx, req.(*CreateManualEnterpriseContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_CreateContractExpansion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContractExpansionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).CreateContractExpansion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_CreateContractExpansion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).CreateContractExpansion(ctx, req.(*CreateContractExpansionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_UpsertManualEnterpriseContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertManualEnterpriseContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).UpsertManualEnterpriseContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_UpsertManualEnterpriseContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).UpsertManualEnterpriseContract(ctx, req.(*UpsertManualEnterpriseContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_DeleteManualEnterpriseContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteManualEnterpriseContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).DeleteManualEnterpriseContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_DeleteManualEnterpriseContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).DeleteManualEnterpriseContract(ctx, req.(*DeleteManualEnterpriseContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_ListEnterpriseContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEnterpriseContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).ListEnterpriseContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_ListEnterpriseContracts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).ListEnterpriseContracts(ctx, req.(*ListEnterpriseContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_EnableTokenBasedPricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTokenBasedPricingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).EnableTokenBasedPricing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_EnableTokenBasedPricing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).EnableTokenBasedPricing(ctx, req.(*EnableTokenBasedPricingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_GetEnterpriseStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEnterpriseStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).GetEnterpriseStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_GetEnterpriseStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).GetEnterpriseStatus(ctx, req.(*GetEnterpriseStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnterpriseAdminService_StartTokenBasedTrial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTokenBasedTrialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnterpriseAdminServiceServer).StartTokenBasedTrial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnterpriseAdminService_StartTokenBasedTrial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnterpriseAdminServiceServer).StartTokenBasedTrial(ctx, req.(*StartTokenBasedTrialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnterpriseAdminService_ServiceDesc is the grpc.ServiceDesc for EnterpriseAdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnterpriseAdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.EnterpriseAdminService",
	HandlerType: (*EnterpriseAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetManualEnterpriseContract",
			Handler:    _EnterpriseAdminService_GetManualEnterpriseContract_Handler,
		},
		{
			MethodName: "ListManualEnterpriseContracts",
			Handler:    _EnterpriseAdminService_ListManualEnterpriseContracts_Handler,
		},
		{
			MethodName: "CreateManualEnterpriseContract",
			Handler:    _EnterpriseAdminService_CreateManualEnterpriseContract_Handler,
		},
		{
			MethodName: "CreateContractExpansion",
			Handler:    _EnterpriseAdminService_CreateContractExpansion_Handler,
		},
		{
			MethodName: "UpsertManualEnterpriseContract",
			Handler:    _EnterpriseAdminService_UpsertManualEnterpriseContract_Handler,
		},
		{
			MethodName: "DeleteManualEnterpriseContract",
			Handler:    _EnterpriseAdminService_DeleteManualEnterpriseContract_Handler,
		},
		{
			MethodName: "ListEnterpriseContracts",
			Handler:    _EnterpriseAdminService_ListEnterpriseContracts_Handler,
		},
		{
			MethodName: "EnableTokenBasedPricing",
			Handler:    _EnterpriseAdminService_EnableTokenBasedPricing_Handler,
		},
		{
			MethodName: "GetEnterpriseStatus",
			Handler:    _EnterpriseAdminService_GetEnterpriseStatus_Handler,
		},
		{
			MethodName: "StartTokenBasedTrial",
			Handler:    _EnterpriseAdminService_StartTokenBasedTrial_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	EvalTrackingService_CreateEval_FullMethodName              = "/aiserver.v1.EvalTrackingService/CreateEval"
	EvalTrackingService_GetEvalByName_FullMethodName           = "/aiserver.v1.EvalTrackingService/GetEvalByName"
	EvalTrackingService_GetRun_FullMethodName                  = "/aiserver.v1.EvalTrackingService/GetRun"
	EvalTrackingService_CreateRun_FullMethodName               = "/aiserver.v1.EvalTrackingService/CreateRun"
	EvalTrackingService_UpdateRunStatus_FullMethodName         = "/aiserver.v1.EvalTrackingService/UpdateRunStatus"
	EvalTrackingService_SetRunSummary_FullMethodName           = "/aiserver.v1.EvalTrackingService/SetRunSummary"
	EvalTrackingService_LogRunMetrics_FullMethodName           = "/aiserver.v1.EvalTrackingService/LogRunMetrics"
	EvalTrackingService_SetRunParams_FullMethodName            = "/aiserver.v1.EvalTrackingService/SetRunParams"
	EvalTrackingService_SetRunTags_FullMethodName              = "/aiserver.v1.EvalTrackingService/SetRunTags"
	EvalTrackingService_UpsertRunRolloutStatus_FullMethodName  = "/aiserver.v1.EvalTrackingService/UpsertRunRolloutStatus"
	EvalTrackingService_Heartbeat_FullMethodName               = "/aiserver.v1.EvalTrackingService/Heartbeat"
	EvalTrackingService_RequestKill_FullMethodName             = "/aiserver.v1.EvalTrackingService/RequestKill"
	EvalTrackingService_SetRayJobName_FullMethodName           = "/aiserver.v1.EvalTrackingService/SetRayJobName"
	EvalTrackingService_CreateEvalCronJob_FullMethodName       = "/aiserver.v1.EvalTrackingService/CreateEvalCronJob"
	EvalTrackingService_GetEvalCronJobByName_FullMethodName    = "/aiserver.v1.EvalTrackingService/GetEvalCronJobByName"
	EvalTrackingService_ListEvalCronJobs_FullMethodName        = "/aiserver.v1.EvalTrackingService/ListEvalCronJobs"
	EvalTrackingService_DeleteEvalCronJobByName_FullMethodName = "/aiserver.v1.EvalTrackingService/DeleteEvalCronJobByName"
)

// EvalTrackingServiceClient is the client API for EvalTrackingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.EvalTrackingService (var: vYe)
type EvalTrackingServiceClient interface {
	CreateEval(ctx context.Context, in *CreateEvalRequest, opts ...grpc.CallOption) (*CreateEvalResponse, error)
	GetEvalByName(ctx context.Context, in *GetEvalByNameRequest, opts ...grpc.CallOption) (*GetEvalByNameResponse, error)
	GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error)
	CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*CreateRunResponse, error)
	UpdateRunStatus(ctx context.Context, in *UpdateRunStatusRequest, opts ...grpc.CallOption) (*UpdateRunStatusResponse, error)
	SetRunSummary(ctx context.Context, in *SetRunSummaryRequest, opts ...grpc.CallOption) (*SetRunSummaryResponse, error)
	LogRunMetrics(ctx context.Context, in *LogRunMetricsRequest, opts ...grpc.CallOption) (*LogRunMetricsResponse, error)
	SetRunParams(ctx context.Context, in *SetRunParamsRequest, opts ...grpc.CallOption) (*SetRunParamsResponse, error)
	SetRunTags(ctx context.Context, in *SetRunTagsRequest, opts ...grpc.CallOption) (*SetRunTagsResponse, error)
	UpsertRunRolloutStatus(ctx context.Context, in *UpsertRunRolloutStatusRequest, opts ...grpc.CallOption) (*UpsertRunRolloutStatusResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	RequestKill(ctx context.Context, in *RequestKillRequest, opts ...grpc.CallOption) (*RequestKillResponse, error)
	SetRayJobName(ctx context.Context, in *SetRayJobNameRequest, opts ...grpc.CallOption) (*SetRayJobNameResponse, error)
	CreateEvalCronJob(ctx context.Context, in *CreateEvalCronJobRequest, opts ...grpc.CallOption) (*CreateEvalCronJobResponse, error)
	GetEvalCronJobByName(ctx context.Context, in *GetEvalCronJobByNameRequest, opts ...grpc.CallOption) (*GetEvalCronJobByNameResponse, error)
	ListEvalCronJobs(ctx context.Context, in *ListEvalCronJobsRequest, opts ...grpc.CallOption) (*ListEvalCronJobsResponse, error)
	DeleteEvalCronJobByName(ctx context.Context, in *DeleteEvalCronJobByNameRequest, opts ...grpc.CallOption) (*DeleteEvalCronJobByNameResponse, error)
}

type evalTrackingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEvalTrackingServiceClient(cc grpc.ClientConnInterface) EvalTrackingServiceClient {
	return &evalTrackingServiceClient{cc}
}

func (c *evalTrackingServiceClient) CreateEval(ctx context.Context, in *CreateEvalRequest, opts ...grpc.CallOption) (*CreateEvalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateEvalResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_CreateEval_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) GetEvalByName(ctx context.Context, in *GetEvalByNameRequest, opts ...grpc.CallOption) (*GetEvalByNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEvalByNameResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_GetEvalByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) GetRun(ctx context.Context, in *GetRunRequest, opts ...grpc.CallOption) (*GetRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRunResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_GetRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*CreateRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRunResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_CreateRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) UpdateRunStatus(ctx context.Context, in *UpdateRunStatusRequest, opts ...grpc.CallOption) (*UpdateRunStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRunStatusResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_UpdateRunStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) SetRunSummary(ctx context.Context, in *SetRunSummaryRequest, opts ...grpc.CallOption) (*SetRunSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRunSummaryResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_SetRunSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) LogRunMetrics(ctx context.Context, in *LogRunMetricsRequest, opts ...grpc.CallOption) (*LogRunMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogRunMetricsResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_LogRunMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) SetRunParams(ctx context.Context, in *SetRunParamsRequest, opts ...grpc.CallOption) (*SetRunParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRunParamsResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_SetRunParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) SetRunTags(ctx context.Context, in *SetRunTagsRequest, opts ...grpc.CallOption) (*SetRunTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRunTagsResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_SetRunTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) UpsertRunRolloutStatus(ctx context.Context, in *UpsertRunRolloutStatusRequest, opts ...grpc.CallOption) (*UpsertRunRolloutStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertRunRolloutStatusResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_UpsertRunRolloutStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) RequestKill(ctx context.Context, in *RequestKillRequest, opts ...grpc.CallOption) (*RequestKillResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestKillResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_RequestKill_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) SetRayJobName(ctx context.Context, in *SetRayJobNameRequest, opts ...grpc.CallOption) (*SetRayJobNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetRayJobNameResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_SetRayJobName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) CreateEvalCronJob(ctx context.Context, in *CreateEvalCronJobRequest, opts ...grpc.CallOption) (*CreateEvalCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateEvalCronJobResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_CreateEvalCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) GetEvalCronJobByName(ctx context.Context, in *GetEvalCronJobByNameRequest, opts ...grpc.CallOption) (*GetEvalCronJobByNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEvalCronJobByNameResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_GetEvalCronJobByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) ListEvalCronJobs(ctx context.Context, in *ListEvalCronJobsRequest, opts ...grpc.CallOption) (*ListEvalCronJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEvalCronJobsResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_ListEvalCronJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *evalTrackingServiceClient) DeleteEvalCronJobByName(ctx context.Context, in *DeleteEvalCronJobByNameRequest, opts ...grpc.CallOption) (*DeleteEvalCronJobByNameResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteEvalCronJobByNameResponse)
	err := c.cc.Invoke(ctx, EvalTrackingService_DeleteEvalCronJobByName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EvalTrackingServiceServer is the server API for EvalTrackingService service.
// All implementations must embed UnimplementedEvalTrackingServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.EvalTrackingService (var: vYe)
type EvalTrackingServiceServer interface {
	CreateEval(context.Context, *CreateEvalRequest) (*CreateEvalResponse, error)
	GetEvalByName(context.Context, *GetEvalByNameRequest) (*GetEvalByNameResponse, error)
	GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error)
	CreateRun(context.Context, *CreateRunRequest) (*CreateRunResponse, error)
	UpdateRunStatus(context.Context, *UpdateRunStatusRequest) (*UpdateRunStatusResponse, error)
	SetRunSummary(context.Context, *SetRunSummaryRequest) (*SetRunSummaryResponse, error)
	LogRunMetrics(context.Context, *LogRunMetricsRequest) (*LogRunMetricsResponse, error)
	SetRunParams(context.Context, *SetRunParamsRequest) (*SetRunParamsResponse, error)
	SetRunTags(context.Context, *SetRunTagsRequest) (*SetRunTagsResponse, error)
	UpsertRunRolloutStatus(context.Context, *UpsertRunRolloutStatusRequest) (*UpsertRunRolloutStatusResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	RequestKill(context.Context, *RequestKillRequest) (*RequestKillResponse, error)
	SetRayJobName(context.Context, *SetRayJobNameRequest) (*SetRayJobNameResponse, error)
	CreateEvalCronJob(context.Context, *CreateEvalCronJobRequest) (*CreateEvalCronJobResponse, error)
	GetEvalCronJobByName(context.Context, *GetEvalCronJobByNameRequest) (*GetEvalCronJobByNameResponse, error)
	ListEvalCronJobs(context.Context, *ListEvalCronJobsRequest) (*ListEvalCronJobsResponse, error)
	DeleteEvalCronJobByName(context.Context, *DeleteEvalCronJobByNameRequest) (*DeleteEvalCronJobByNameResponse, error)
	mustEmbedUnimplementedEvalTrackingServiceServer()
}

// UnimplementedEvalTrackingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEvalTrackingServiceServer struct{}

func (UnimplementedEvalTrackingServiceServer) CreateEval(context.Context, *CreateEvalRequest) (*CreateEvalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEval not implemented")
}
func (UnimplementedEvalTrackingServiceServer) GetEvalByName(context.Context, *GetEvalByNameRequest) (*GetEvalByNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEvalByName not implemented")
}
func (UnimplementedEvalTrackingServiceServer) GetRun(context.Context, *GetRunRequest) (*GetRunResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRun not implemented")
}
func (UnimplementedEvalTrackingServiceServer) CreateRun(context.Context, *CreateRunRequest) (*CreateRunResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRun not implemented")
}
func (UnimplementedEvalTrackingServiceServer) UpdateRunStatus(context.Context, *UpdateRunStatusRequest) (*UpdateRunStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRunStatus not implemented")
}
func (UnimplementedEvalTrackingServiceServer) SetRunSummary(context.Context, *SetRunSummaryRequest) (*SetRunSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRunSummary not implemented")
}
func (UnimplementedEvalTrackingServiceServer) LogRunMetrics(context.Context, *LogRunMetricsRequest) (*LogRunMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LogRunMetrics not implemented")
}
func (UnimplementedEvalTrackingServiceServer) SetRunParams(context.Context, *SetRunParamsRequest) (*SetRunParamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRunParams not implemented")
}
func (UnimplementedEvalTrackingServiceServer) SetRunTags(context.Context, *SetRunTagsRequest) (*SetRunTagsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRunTags not implemented")
}
func (UnimplementedEvalTrackingServiceServer) UpsertRunRolloutStatus(context.Context, *UpsertRunRolloutStatusRequest) (*UpsertRunRolloutStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertRunRolloutStatus not implemented")
}
func (UnimplementedEvalTrackingServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedEvalTrackingServiceServer) RequestKill(context.Context, *RequestKillRequest) (*RequestKillResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestKill not implemented")
}
func (UnimplementedEvalTrackingServiceServer) SetRayJobName(context.Context, *SetRayJobNameRequest) (*SetRayJobNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRayJobName not implemented")
}
func (UnimplementedEvalTrackingServiceServer) CreateEvalCronJob(context.Context, *CreateEvalCronJobRequest) (*CreateEvalCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEvalCronJob not implemented")
}
func (UnimplementedEvalTrackingServiceServer) GetEvalCronJobByName(context.Context, *GetEvalCronJobByNameRequest) (*GetEvalCronJobByNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEvalCronJobByName not implemented")
}
func (UnimplementedEvalTrackingServiceServer) ListEvalCronJobs(context.Context, *ListEvalCronJobsRequest) (*ListEvalCronJobsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEvalCronJobs not implemented")
}
func (UnimplementedEvalTrackingServiceServer) DeleteEvalCronJobByName(context.Context, *DeleteEvalCronJobByNameRequest) (*DeleteEvalCronJobByNameResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteEvalCronJobByName not implemented")
}
func (UnimplementedEvalTrackingServiceServer) mustEmbedUnimplementedEvalTrackingServiceServer() {}
func (UnimplementedEvalTrackingServiceServer) testEmbeddedByValue()                             {}

// UnsafeEvalTrackingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EvalTrackingServiceServer will
// result in compilation errors.
type UnsafeEvalTrackingServiceServer interface {
	mustEmbedUnimplementedEvalTrackingServiceServer()
}

func RegisterEvalTrackingServiceServer(s grpc.ServiceRegistrar, srv EvalTrackingServiceServer) {
	// If the following call panics, it indicates UnimplementedEvalTrackingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EvalTrackingService_ServiceDesc, srv)
}

func _EvalTrackingService_CreateEval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEvalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).CreateEval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_CreateEval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).CreateEval(ctx, req.(*CreateEvalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_GetEvalByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvalByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).GetEvalByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_GetEvalByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).GetEvalByName(ctx, req.(*GetEvalByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_GetRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).GetRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_GetRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).GetRun(ctx, req.(*GetRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_CreateRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).CreateRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_CreateRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).CreateRun(ctx, req.(*CreateRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_UpdateRunStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRunStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).UpdateRunStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_UpdateRunStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).UpdateRunStatus(ctx, req.(*UpdateRunStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_SetRunSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRunSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).SetRunSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_SetRunSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).SetRunSummary(ctx, req.(*SetRunSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_LogRunMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRunMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).LogRunMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_LogRunMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).LogRunMetrics(ctx, req.(*LogRunMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_SetRunParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRunParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).SetRunParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_SetRunParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).SetRunParams(ctx, req.(*SetRunParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_SetRunTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRunTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).SetRunTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_SetRunTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).SetRunTags(ctx, req.(*SetRunTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_UpsertRunRolloutStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertRunRolloutStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).UpsertRunRolloutStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_UpsertRunRolloutStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).UpsertRunRolloutStatus(ctx, req.(*UpsertRunRolloutStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_RequestKill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestKillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).RequestKill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_RequestKill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).RequestKill(ctx, req.(*RequestKillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_SetRayJobName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRayJobNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).SetRayJobName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_SetRayJobName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).SetRayJobName(ctx, req.(*SetRayJobNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_CreateEvalCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEvalCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).CreateEvalCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_CreateEvalCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).CreateEvalCronJob(ctx, req.(*CreateEvalCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_GetEvalCronJobByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEvalCronJobByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).GetEvalCronJobByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_GetEvalCronJobByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).GetEvalCronJobByName(ctx, req.(*GetEvalCronJobByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_ListEvalCronJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEvalCronJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).ListEvalCronJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_ListEvalCronJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).ListEvalCronJobs(ctx, req.(*ListEvalCronJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EvalTrackingService_DeleteEvalCronJobByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEvalCronJobByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EvalTrackingServiceServer).DeleteEvalCronJobByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EvalTrackingService_DeleteEvalCronJobByName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EvalTrackingServiceServer).DeleteEvalCronJobByName(ctx, req.(*DeleteEvalCronJobByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EvalTrackingService_ServiceDesc is the grpc.ServiceDesc for EvalTrackingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EvalTrackingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.EvalTrackingService",
	HandlerType: (*EvalTrackingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEval",
			Handler:    _EvalTrackingService_CreateEval_Handler,
		},
		{
			MethodName: "GetEvalByName",
			Handler:    _EvalTrackingService_GetEvalByName_Handler,
		},
		{
			MethodName: "GetRun",
			Handler:    _EvalTrackingService_GetRun_Handler,
		},
		{
			MethodName: "CreateRun",
			Handler:    _EvalTrackingService_CreateRun_Handler,
		},
		{
			MethodName: "UpdateRunStatus",
			Handler:    _EvalTrackingService_UpdateRunStatus_Handler,
		},
		{
			MethodName: "SetRunSummary",
			Handler:    _EvalTrackingService_SetRunSummary_Handler,
		},
		{
			MethodName: "LogRunMetrics",
			Handler:    _EvalTrackingService_LogRunMetrics_Handler,
		},
		{
			MethodName: "SetRunParams",
			Handler:    _EvalTrackingService_SetRunParams_Handler,
		},
		{
			MethodName: "SetRunTags",
			Handler:    _EvalTrackingService_SetRunTags_Handler,
		},
		{
			MethodName: "UpsertRunRolloutStatus",
			Handler:    _EvalTrackingService_UpsertRunRolloutStatus_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _EvalTrackingService_Heartbeat_Handler,
		},
		{
			MethodName: "RequestKill",
			Handler:    _EvalTrackingService_RequestKill_Handler,
		},
		{
			MethodName: "SetRayJobName",
			Handler:    _EvalTrackingService_SetRayJobName_Handler,
		},
		{
			MethodName: "CreateEvalCronJob",
			Handler:    _EvalTrackingService_CreateEvalCronJob_Handler,
		},
		{
			MethodName: "GetEvalCronJobByName",
			Handler:    _EvalTrackingService_GetEvalCronJobByName_Handler,
		},
		{
			MethodName: "ListEvalCronJobs",
			Handler:    _EvalTrackingService_ListEvalCronJobs_Handler,
		},
		{
			MethodName: "DeleteEvalCronJobByName",
			Handler:    _EvalTrackingService_DeleteEvalCronJobByName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	FastApplyService_ReportEditFate_FullMethodName = "/aiserver.v1.FastApplyService/ReportEditFate"
	FastApplyService_WarmApply_FullMethodName      = "/aiserver.v1.FastApplyService/WarmApply"
)

// FastApplyServiceClient is the client API for FastApplyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.FastApplyService (var: tze)
type FastApplyServiceClient interface {
	ReportEditFate(ctx context.Context, in *ReportEditFateRequest, opts ...grpc.CallOption) (*ReportEditFateResponse, error)
	WarmApply(ctx context.Context, in *WarmApplyRequest, opts ...grpc.CallOption) (*WarmApplyResponse, error)
}

type fastApplyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFastApplyServiceClient(cc grpc.ClientConnInterface) FastApplyServiceClient {
	return &fastApplyServiceClient{cc}
}

func (c *fastApplyServiceClient) ReportEditFate(ctx context.Context, in *ReportEditFateRequest, opts ...grpc.CallOption) (*ReportEditFateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportEditFateResponse)
	err := c.cc.Invoke(ctx, FastApplyService_ReportEditFate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fastApplyServiceClient) WarmApply(ctx context.Context, in *WarmApplyRequest, opts ...grpc.CallOption) (*WarmApplyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmApplyResponse)
	err := c.cc.Invoke(ctx, FastApplyService_WarmApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FastApplyServiceServer is the server API for FastApplyService service.
// All implementations must embed UnimplementedFastApplyServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.FastApplyService (var: tze)
type FastApplyServiceServer interface {
	ReportEditFate(context.Context, *ReportEditFateRequest) (*ReportEditFateResponse, error)
	WarmApply(context.Context, *WarmApplyRequest) (*WarmApplyResponse, error)
	mustEmbedUnimplementedFastApplyServiceServer()
}

// UnimplementedFastApplyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFastApplyServiceServer struct{}

func (UnimplementedFastApplyServiceServer) ReportEditFate(context.Context, *ReportEditFateRequest) (*ReportEditFateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportEditFate not implemented")
}
func (UnimplementedFastApplyServiceServer) WarmApply(context.Context, *WarmApplyRequest) (*WarmApplyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmApply not implemented")
}
func (UnimplementedFastApplyServiceServer) mustEmbedUnimplementedFastApplyServiceServer() {}
func (UnimplementedFastApplyServiceServer) testEmbeddedByValue()                          {}

// UnsafeFastApplyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FastApplyServiceServer will
// result in compilation errors.
type UnsafeFastApplyServiceServer interface {
	mustEmbedUnimplementedFastApplyServiceServer()
}

func RegisterFastApplyServiceServer(s grpc.ServiceRegistrar, srv FastApplyServiceServer) {
	// If the following call panics, it indicates UnimplementedFastApplyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FastApplyService_ServiceDesc, srv)
}

func _FastApplyService_ReportEditFate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEditFateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FastApplyServiceServer).ReportEditFate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FastApplyService_ReportEditFate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FastApplyServiceServer).ReportEditFate(ctx, req.(*ReportEditFateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FastApplyService_WarmApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WarmApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FastApplyServiceServer).WarmApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FastApplyService_WarmApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FastApplyServiceServer).WarmApply(ctx, req.(*WarmApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FastApplyService_ServiceDesc is the grpc.ServiceDesc for FastApplyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FastApplyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.FastApplyService",
	HandlerType: (*FastApplyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportEditFate",
			Handler:    _FastApplyService_ReportEditFate_Handler,
		},
		{
			MethodName: "WarmApply",
			Handler:    _FastApplyService_WarmApply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	FastSearchService_StartFastSearch_FullMethodName = "/aiserver.v1.FastSearchService/StartFastSearch"
	FastSearchService_FastSearch_FullMethodName      = "/aiserver.v1.FastSearchService/FastSearch"
)

// FastSearchServiceClient is the client API for FastSearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.FastSearchService (var: yYe)
type FastSearchServiceClient interface {
	StartFastSearch(ctx context.Context, in *StartFastSearchRequest, opts ...grpc.CallOption) (*StartFastSearchResponse, error)
	FastSearch(ctx context.Context, in *FastSearchRequest, opts ...grpc.CallOption) (*FastSearchResponse, error)
}

type fastSearchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFastSearchServiceClient(cc grpc.ClientConnInterface) FastSearchServiceClient {
	return &fastSearchServiceClient{cc}
}

func (c *fastSearchServiceClient) StartFastSearch(ctx context.Context, in *StartFastSearchRequest, opts ...grpc.CallOption) (*StartFastSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartFastSearchResponse)
	err := c.cc.Invoke(ctx, FastSearchService_StartFastSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fastSearchServiceClient) FastSearch(ctx context.Context, in *FastSearchRequest, opts ...grpc.CallOption) (*FastSearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastSearchResponse)
	err := c.cc.Invoke(ctx, FastSearchService_FastSearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FastSearchServiceServer is the server API for FastSearchService service.
// All implementations must embed UnimplementedFastSearchServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.FastSearchService (var: yYe)
type FastSearchServiceServer interface {
	StartFastSearch(context.Context, *StartFastSearchRequest) (*StartFastSearchResponse, error)
	FastSearch(context.Context, *FastSearchRequest) (*FastSearchResponse, error)
	mustEmbedUnimplementedFastSearchServiceServer()
}

// UnimplementedFastSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFastSearchServiceServer struct{}

func (UnimplementedFastSearchServiceServer) StartFastSearch(context.Context, *StartFastSearchRequest) (*StartFastSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartFastSearch not implemented")
}
func (UnimplementedFastSearchServiceServer) FastSearch(context.Context, *FastSearchRequest) (*FastSearchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FastSearch not implemented")
}
func (UnimplementedFastSearchServiceServer) mustEmbedUnimplementedFastSearchServiceServer() {}
func (UnimplementedFastSearchServiceServer) testEmbeddedByValue()                           {}

// UnsafeFastSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FastSearchServiceServer will
// result in compilation errors.
type UnsafeFastSearchServiceServer interface {
	mustEmbedUnimplementedFastSearchServiceServer()
}

func RegisterFastSearchServiceServer(s grpc.ServiceRegistrar, srv FastSearchServiceServer) {
	// If the following call panics, it indicates UnimplementedFastSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FastSearchService_ServiceDesc, srv)
}

func _FastSearchService_StartFastSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartFastSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FastSearchServiceServer).StartFastSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FastSearchService_StartFastSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FastSearchServiceServer).StartFastSearch(ctx, req.(*StartFastSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FastSearchService_FastSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FastSearchServiceServer).FastSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FastSearchService_FastSearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FastSearchServiceServer).FastSearch(ctx, req.(*FastSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FastSearchService_ServiceDesc is the grpc.ServiceDesc for FastSearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FastSearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.FastSearchService",
	HandlerType: (*FastSearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartFastSearch",
			Handler:    _FastSearchService_StartFastSearch_Handler,
		},
		{
			MethodName: "FastSearch",
			Handler:    _FastSearchService_FastSearch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	FileSyncService_FSUploadFile_FullMethodName           = "/aiserver.v1.FileSyncService/FSUploadFile"
	FileSyncService_FSSyncFile_FullMethodName             = "/aiserver.v1.FileSyncService/FSSyncFile"
	FileSyncService_FSIsEnabledForUser_FullMethodName     = "/aiserver.v1.FileSyncService/FSIsEnabledForUser"
	FileSyncService_FSConfig_FullMethodName               = "/aiserver.v1.FileSyncService/FSConfig"
	FileSyncService_FSGetFileContents_FullMethodName      = "/aiserver.v1.FileSyncService/FSGetFileContents"
	FileSyncService_FSGetMultiFileContents_FullMethodName = "/aiserver.v1.FileSyncService/FSGetMultiFileContents"
	FileSyncService_FSInternalSyncFile_FullMethodName     = "/aiserver.v1.FileSyncService/FSInternalSyncFile"
	FileSyncService_FSInternalUploadFile_FullMethodName   = "/aiserver.v1.FileSyncService/FSInternalUploadFile"
	FileSyncService_FSInternalHealthCheck_FullMethodName  = "/aiserver.v1.FileSyncService/FSInternalHealthCheck"
)

// FileSyncServiceClient is the client API for FileSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.FileSyncService (var: HVe)
type FileSyncServiceClient interface {
	FSUploadFile(ctx context.Context, in *FSUploadFileRequest, opts ...grpc.CallOption) (*FSUploadFileResponse, error)
	FSSyncFile(ctx context.Context, in *FSSyncFileRequest, opts ...grpc.CallOption) (*FSSyncFileResponse, error)
	FSIsEnabledForUser(ctx context.Context, in *FSIsEnabledForUserRequest, opts ...grpc.CallOption) (*FSIsEnabledForUserResponse, error)
	FSConfig(ctx context.Context, in *FSConfigRequest, opts ...grpc.CallOption) (*FSConfigResponse, error)
	FSGetFileContents(ctx context.Context, in *FSGetFileContentsRequest, opts ...grpc.CallOption) (*FSGetFileContentsResponse, error)
	FSGetMultiFileContents(ctx context.Context, in *FSGetMultiFileContentsRequest, opts ...grpc.CallOption) (*FSGetMultiFileContentsResponse, error)
	FSInternalSyncFile(ctx context.Context, in *FSSyncFileRequest, opts ...grpc.CallOption) (*FSSyncFileResponse, error)
	FSInternalUploadFile(ctx context.Context, in *FSUploadFileRequest, opts ...grpc.CallOption) (*FSUploadFileResponse, error)
	FSInternalHealthCheck(ctx context.Context, in *FSInternalHealthCheckRequest, opts ...grpc.CallOption) (*FSInternalHealthCheckResponse, error)
}

type fileSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileSyncServiceClient(cc grpc.ClientConnInterface) FileSyncServiceClient {
	return &fileSyncServiceClient{cc}
}

func (c *fileSyncServiceClient) FSUploadFile(ctx context.Context, in *FSUploadFileRequest, opts ...grpc.CallOption) (*FSUploadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSUploadFileResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSUploadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSSyncFile(ctx context.Context, in *FSSyncFileRequest, opts ...grpc.CallOption) (*FSSyncFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSSyncFileResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSSyncFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSIsEnabledForUser(ctx context.Context, in *FSIsEnabledForUserRequest, opts ...grpc.CallOption) (*FSIsEnabledForUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSIsEnabledForUserResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSIsEnabledForUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSConfig(ctx context.Context, in *FSConfigRequest, opts ...grpc.CallOption) (*FSConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSConfigResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSGetFileContents(ctx context.Context, in *FSGetFileContentsRequest, opts ...grpc.CallOption) (*FSGetFileContentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSGetFileContentsResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSGetFileContents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSGetMultiFileContents(ctx context.Context, in *FSGetMultiFileContentsRequest, opts ...grpc.CallOption) (*FSGetMultiFileContentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSGetMultiFileContentsResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSGetMultiFileContents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSInternalSyncFile(ctx context.Context, in *FSSyncFileRequest, opts ...grpc.CallOption) (*FSSyncFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSSyncFileResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSInternalSyncFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSInternalUploadFile(ctx context.Context, in *FSUploadFileRequest, opts ...grpc.CallOption) (*FSUploadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSUploadFileResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSInternalUploadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileSyncServiceClient) FSInternalHealthCheck(ctx context.Context, in *FSInternalHealthCheckRequest, opts ...grpc.CallOption) (*FSInternalHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FSInternalHealthCheckResponse)
	err := c.cc.Invoke(ctx, FileSyncService_FSInternalHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileSyncServiceServer is the server API for FileSyncService service.
// All implementations must embed UnimplementedFileSyncServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.FileSyncService (var: HVe)
type FileSyncServiceServer interface {
	FSUploadFile(context.Context, *FSUploadFileRequest) (*FSUploadFileResponse, error)
	FSSyncFile(context.Context, *FSSyncFileRequest) (*FSSyncFileResponse, error)
	FSIsEnabledForUser(context.Context, *FSIsEnabledForUserRequest) (*FSIsEnabledForUserResponse, error)
	FSConfig(context.Context, *FSConfigRequest) (*FSConfigResponse, error)
	FSGetFileContents(context.Context, *FSGetFileContentsRequest) (*FSGetFileContentsResponse, error)
	FSGetMultiFileContents(context.Context, *FSGetMultiFileContentsRequest) (*FSGetMultiFileContentsResponse, error)
	FSInternalSyncFile(context.Context, *FSSyncFileRequest) (*FSSyncFileResponse, error)
	FSInternalUploadFile(context.Context, *FSUploadFileRequest) (*FSUploadFileResponse, error)
	FSInternalHealthCheck(context.Context, *FSInternalHealthCheckRequest) (*FSInternalHealthCheckResponse, error)
	mustEmbedUnimplementedFileSyncServiceServer()
}

// UnimplementedFileSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileSyncServiceServer struct{}

func (UnimplementedFileSyncServiceServer) FSUploadFile(context.Context, *FSUploadFileRequest) (*FSUploadFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSUploadFile not implemented")
}
func (UnimplementedFileSyncServiceServer) FSSyncFile(context.Context, *FSSyncFileRequest) (*FSSyncFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSSyncFile not implemented")
}
func (UnimplementedFileSyncServiceServer) FSIsEnabledForUser(context.Context, *FSIsEnabledForUserRequest) (*FSIsEnabledForUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSIsEnabledForUser not implemented")
}
func (UnimplementedFileSyncServiceServer) FSConfig(context.Context, *FSConfigRequest) (*FSConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSConfig not implemented")
}
func (UnimplementedFileSyncServiceServer) FSGetFileContents(context.Context, *FSGetFileContentsRequest) (*FSGetFileContentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSGetFileContents not implemented")
}
func (UnimplementedFileSyncServiceServer) FSGetMultiFileContents(context.Context, *FSGetMultiFileContentsRequest) (*FSGetMultiFileContentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSGetMultiFileContents not implemented")
}
func (UnimplementedFileSyncServiceServer) FSInternalSyncFile(context.Context, *FSSyncFileRequest) (*FSSyncFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSInternalSyncFile not implemented")
}
func (UnimplementedFileSyncServiceServer) FSInternalUploadFile(context.Context, *FSUploadFileRequest) (*FSUploadFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSInternalUploadFile not implemented")
}
func (UnimplementedFileSyncServiceServer) FSInternalHealthCheck(context.Context, *FSInternalHealthCheckRequest) (*FSInternalHealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FSInternalHealthCheck not implemented")
}
func (UnimplementedFileSyncServiceServer) mustEmbedUnimplementedFileSyncServiceServer() {}
func (UnimplementedFileSyncServiceServer) testEmbeddedByValue()                         {}

// UnsafeFileSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileSyncServiceServer will
// result in compilation errors.
type UnsafeFileSyncServiceServer interface {
	mustEmbedUnimplementedFileSyncServiceServer()
}

func RegisterFileSyncServiceServer(s grpc.ServiceRegistrar, srv FileSyncServiceServer) {
	// If the following call panics, it indicates UnimplementedFileSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileSyncService_ServiceDesc, srv)
}

func _FileSyncService_FSUploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSUploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSUploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSUploadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSUploadFile(ctx, req.(*FSUploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSSyncFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSSyncFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSSyncFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSSyncFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSSyncFile(ctx, req.(*FSSyncFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSIsEnabledForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSIsEnabledForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSIsEnabledForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSIsEnabledForUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSIsEnabledForUser(ctx, req.(*FSIsEnabledForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSConfig(ctx, req.(*FSConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSGetFileContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSGetFileContentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSGetFileContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSGetFileContents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSGetFileContents(ctx, req.(*FSGetFileContentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSGetMultiFileContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSGetMultiFileContentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSGetMultiFileContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSGetMultiFileContents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSGetMultiFileContents(ctx, req.(*FSGetMultiFileContentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSInternalSyncFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSSyncFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSInternalSyncFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSInternalSyncFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSInternalSyncFile(ctx, req.(*FSSyncFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSInternalUploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSUploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSInternalUploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSInternalUploadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSInternalUploadFile(ctx, req.(*FSUploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileSyncService_FSInternalHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FSInternalHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileSyncServiceServer).FSInternalHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileSyncService_FSInternalHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileSyncServiceServer).FSInternalHealthCheck(ctx, req.(*FSInternalHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileSyncService_ServiceDesc is the grpc.ServiceDesc for FileSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.FileSyncService",
	HandlerType: (*FileSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FSUploadFile",
			Handler:    _FileSyncService_FSUploadFile_Handler,
		},
		{
			MethodName: "FSSyncFile",
			Handler:    _FileSyncService_FSSyncFile_Handler,
		},
		{
			MethodName: "FSIsEnabledForUser",
			Handler:    _FileSyncService_FSIsEnabledForUser_Handler,
		},
		{
			MethodName: "FSConfig",
			Handler:    _FileSyncService_FSConfig_Handler,
		},
		{
			MethodName: "FSGetFileContents",
			Handler:    _FileSyncService_FSGetFileContents_Handler,
		},
		{
			MethodName: "FSGetMultiFileContents",
			Handler:    _FileSyncService_FSGetMultiFileContents_Handler,
		},
		{
			MethodName: "FSInternalSyncFile",
			Handler:    _FileSyncService_FSInternalSyncFile_Handler,
		},
		{
			MethodName: "FSInternalUploadFile",
			Handler:    _FileSyncService_FSInternalUploadFile_Handler,
		},
		{
			MethodName: "FSInternalHealthCheck",
			Handler:    _FileSyncService_FSInternalHealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	GitGraphService_InitGitGraph_FullMethodName                     = "/aiserver.v1.GitGraphService/InitGitGraph"
	GitGraphService_InitGitGraphChallenge_FullMethodName            = "/aiserver.v1.GitGraphService/InitGitGraphChallenge"
	GitGraphService_BatchedUploadCommitsIntoGitGraph_FullMethodName = "/aiserver.v1.GitGraphService/BatchedUploadCommitsIntoGitGraph"
	GitGraphService_GetPendingCommits_FullMethodName                = "/aiserver.v1.GitGraphService/GetPendingCommits"
	GitGraphService_MarkPendingCommits_FullMethodName               = "/aiserver.v1.GitGraphService/MarkPendingCommits"
	GitGraphService_GetGitGraphRelatedFiles_FullMethodName          = "/aiserver.v1.GitGraphService/GetGitGraphRelatedFiles"
	GitGraphService_GetGitGraphStatus_FullMethodName                = "/aiserver.v1.GitGraphService/GetGitGraphStatus"
	GitGraphService_DeleteGitGraph_FullMethodName                   = "/aiserver.v1.GitGraphService/DeleteGitGraph"
	GitGraphService_IsGitGraphEnabled_FullMethodName                = "/aiserver.v1.GitGraphService/IsGitGraphEnabled"
)

// GitGraphServiceClient is the client API for GitGraphService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.GitGraphService (var: TYe)
type GitGraphServiceClient interface {
	InitGitGraph(ctx context.Context, in *InitGitGraphRequest, opts ...grpc.CallOption) (*InitGitGraphResponse, error)
	InitGitGraphChallenge(ctx context.Context, in *InitGitGraphChallengeRequest, opts ...grpc.CallOption) (*InitGitGraphChallengeResponse, error)
	BatchedUploadCommitsIntoGitGraph(ctx context.Context, in *BatchedUploadCommitsIntoGitGraphRequest, opts ...grpc.CallOption) (*BatchedUploadCommitsIntoGitGraphResponse, error)
	GetPendingCommits(ctx context.Context, in *GetPendingCommitsRequest, opts ...grpc.CallOption) (*GetPendingCommitsResponse, error)
	MarkPendingCommits(ctx context.Context, in *MarkPendingCommitsRequest, opts ...grpc.CallOption) (*MarkPendingCommitsResponse, error)
	GetGitGraphRelatedFiles(ctx context.Context, in *GetGitGraphRelatedFilesRequest, opts ...grpc.CallOption) (*GetGitGraphRelatedFilesResponse, error)
	GetGitGraphStatus(ctx context.Context, in *GetGitGraphStatusRequest, opts ...grpc.CallOption) (*GetGitGraphStatusResponse, error)
	DeleteGitGraph(ctx context.Context, in *DeleteGitGraphRequest, opts ...grpc.CallOption) (*DeleteGitGraphResponse, error)
	IsGitGraphEnabled(ctx context.Context, in *IsGitGraphEnabledRequest, opts ...grpc.CallOption) (*IsGitGraphEnabledResponse, error)
}

type gitGraphServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGitGraphServiceClient(cc grpc.ClientConnInterface) GitGraphServiceClient {
	return &gitGraphServiceClient{cc}
}

func (c *gitGraphServiceClient) InitGitGraph(ctx context.Context, in *InitGitGraphRequest, opts ...grpc.CallOption) (*InitGitGraphResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitGitGraphResponse)
	err := c.cc.Invoke(ctx, GitGraphService_InitGitGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) InitGitGraphChallenge(ctx context.Context, in *InitGitGraphChallengeRequest, opts ...grpc.CallOption) (*InitGitGraphChallengeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitGitGraphChallengeResponse)
	err := c.cc.Invoke(ctx, GitGraphService_InitGitGraphChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) BatchedUploadCommitsIntoGitGraph(ctx context.Context, in *BatchedUploadCommitsIntoGitGraphRequest, opts ...grpc.CallOption) (*BatchedUploadCommitsIntoGitGraphResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchedUploadCommitsIntoGitGraphResponse)
	err := c.cc.Invoke(ctx, GitGraphService_BatchedUploadCommitsIntoGitGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) GetPendingCommits(ctx context.Context, in *GetPendingCommitsRequest, opts ...grpc.CallOption) (*GetPendingCommitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPendingCommitsResponse)
	err := c.cc.Invoke(ctx, GitGraphService_GetPendingCommits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) MarkPendingCommits(ctx context.Context, in *MarkPendingCommitsRequest, opts ...grpc.CallOption) (*MarkPendingCommitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkPendingCommitsResponse)
	err := c.cc.Invoke(ctx, GitGraphService_MarkPendingCommits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) GetGitGraphRelatedFiles(ctx context.Context, in *GetGitGraphRelatedFilesRequest, opts ...grpc.CallOption) (*GetGitGraphRelatedFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGitGraphRelatedFilesResponse)
	err := c.cc.Invoke(ctx, GitGraphService_GetGitGraphRelatedFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) GetGitGraphStatus(ctx context.Context, in *GetGitGraphStatusRequest, opts ...grpc.CallOption) (*GetGitGraphStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGitGraphStatusResponse)
	err := c.cc.Invoke(ctx, GitGraphService_GetGitGraphStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) DeleteGitGraph(ctx context.Context, in *DeleteGitGraphRequest, opts ...grpc.CallOption) (*DeleteGitGraphResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteGitGraphResponse)
	err := c.cc.Invoke(ctx, GitGraphService_DeleteGitGraph_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitGraphServiceClient) IsGitGraphEnabled(ctx context.Context, in *IsGitGraphEnabledRequest, opts ...grpc.CallOption) (*IsGitGraphEnabledResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsGitGraphEnabledResponse)
	err := c.cc.Invoke(ctx, GitGraphService_IsGitGraphEnabled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GitGraphServiceServer is the server API for GitGraphService service.
// All implementations must embed UnimplementedGitGraphServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.GitGraphService (var: TYe)
type GitGraphServiceServer interface {
	InitGitGraph(context.Context, *InitGitGraphRequest) (*InitGitGraphResponse, error)
	InitGitGraphChallenge(context.Context, *InitGitGraphChallengeRequest) (*InitGitGraphChallengeResponse, error)
	BatchedUploadCommitsIntoGitGraph(context.Context, *BatchedUploadCommitsIntoGitGraphRequest) (*BatchedUploadCommitsIntoGitGraphResponse, error)
	GetPendingCommits(context.Context, *GetPendingCommitsRequest) (*GetPendingCommitsResponse, error)
	MarkPendingCommits(context.Context, *MarkPendingCommitsRequest) (*MarkPendingCommitsResponse, error)
	GetGitGraphRelatedFiles(context.Context, *GetGitGraphRelatedFilesRequest) (*GetGitGraphRelatedFilesResponse, error)
	GetGitGraphStatus(context.Context, *GetGitGraphStatusRequest) (*GetGitGraphStatusResponse, error)
	DeleteGitGraph(context.Context, *DeleteGitGraphRequest) (*DeleteGitGraphResponse, error)
	IsGitGraphEnabled(context.Context, *IsGitGraphEnabledRequest) (*IsGitGraphEnabledResponse, error)
	mustEmbedUnimplementedGitGraphServiceServer()
}

// UnimplementedGitGraphServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGitGraphServiceServer struct{}

func (UnimplementedGitGraphServiceServer) InitGitGraph(context.Context, *InitGitGraphRequest) (*InitGitGraphResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitGitGraph not implemented")
}
func (UnimplementedGitGraphServiceServer) InitGitGraphChallenge(context.Context, *InitGitGraphChallengeRequest) (*InitGitGraphChallengeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitGitGraphChallenge not implemented")
}
func (UnimplementedGitGraphServiceServer) BatchedUploadCommitsIntoGitGraph(context.Context, *BatchedUploadCommitsIntoGitGraphRequest) (*BatchedUploadCommitsIntoGitGraphResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchedUploadCommitsIntoGitGraph not implemented")
}
func (UnimplementedGitGraphServiceServer) GetPendingCommits(context.Context, *GetPendingCommitsRequest) (*GetPendingCommitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPendingCommits not implemented")
}
func (UnimplementedGitGraphServiceServer) MarkPendingCommits(context.Context, *MarkPendingCommitsRequest) (*MarkPendingCommitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkPendingCommits not implemented")
}
func (UnimplementedGitGraphServiceServer) GetGitGraphRelatedFiles(context.Context, *GetGitGraphRelatedFilesRequest) (*GetGitGraphRelatedFilesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGitGraphRelatedFiles not implemented")
}
func (UnimplementedGitGraphServiceServer) GetGitGraphStatus(context.Context, *GetGitGraphStatusRequest) (*GetGitGraphStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGitGraphStatus not implemented")
}
func (UnimplementedGitGraphServiceServer) DeleteGitGraph(context.Context, *DeleteGitGraphRequest) (*DeleteGitGraphResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteGitGraph not implemented")
}
func (UnimplementedGitGraphServiceServer) IsGitGraphEnabled(context.Context, *IsGitGraphEnabledRequest) (*IsGitGraphEnabledResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsGitGraphEnabled not implemented")
}
func (UnimplementedGitGraphServiceServer) mustEmbedUnimplementedGitGraphServiceServer() {}
func (UnimplementedGitGraphServiceServer) testEmbeddedByValue()                         {}

// UnsafeGitGraphServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GitGraphServiceServer will
// result in compilation errors.
type UnsafeGitGraphServiceServer interface {
	mustEmbedUnimplementedGitGraphServiceServer()
}

func RegisterGitGraphServiceServer(s grpc.ServiceRegistrar, srv GitGraphServiceServer) {
	// If the following call panics, it indicates UnimplementedGitGraphServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GitGraphService_ServiceDesc, srv)
}

func _GitGraphService_InitGitGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitGitGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).InitGitGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_InitGitGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).InitGitGraph(ctx, req.(*InitGitGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_InitGitGraphChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitGitGraphChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).InitGitGraphChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_InitGitGraphChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).InitGitGraphChallenge(ctx, req.(*InitGitGraphChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_BatchedUploadCommitsIntoGitGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchedUploadCommitsIntoGitGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).BatchedUploadCommitsIntoGitGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_BatchedUploadCommitsIntoGitGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).BatchedUploadCommitsIntoGitGraph(ctx, req.(*BatchedUploadCommitsIntoGitGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_GetPendingCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPendingCommitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).GetPendingCommits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_GetPendingCommits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).GetPendingCommits(ctx, req.(*GetPendingCommitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_MarkPendingCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkPendingCommitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).MarkPendingCommits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_MarkPendingCommits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).MarkPendingCommits(ctx, req.(*MarkPendingCommitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_GetGitGraphRelatedFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGitGraphRelatedFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).GetGitGraphRelatedFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_GetGitGraphRelatedFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).GetGitGraphRelatedFiles(ctx, req.(*GetGitGraphRelatedFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_GetGitGraphStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGitGraphStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).GetGitGraphStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_GetGitGraphStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).GetGitGraphStatus(ctx, req.(*GetGitGraphStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_DeleteGitGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGitGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).DeleteGitGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_DeleteGitGraph_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).DeleteGitGraph(ctx, req.(*DeleteGitGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitGraphService_IsGitGraphEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsGitGraphEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitGraphServiceServer).IsGitGraphEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitGraphService_IsGitGraphEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitGraphServiceServer).IsGitGraphEnabled(ctx, req.(*IsGitGraphEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GitGraphService_ServiceDesc is the grpc.ServiceDesc for GitGraphService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GitGraphService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.GitGraphService",
	HandlerType: (*GitGraphServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitGitGraph",
			Handler:    _GitGraphService_InitGitGraph_Handler,
		},
		{
			MethodName: "InitGitGraphChallenge",
			Handler:    _GitGraphService_InitGitGraphChallenge_Handler,
		},
		{
			MethodName: "BatchedUploadCommitsIntoGitGraph",
			Handler:    _GitGraphService_BatchedUploadCommitsIntoGitGraph_Handler,
		},
		{
			MethodName: "GetPendingCommits",
			Handler:    _GitGraphService_GetPendingCommits_Handler,
		},
		{
			MethodName: "MarkPendingCommits",
			Handler:    _GitGraphService_MarkPendingCommits_Handler,
		},
		{
			MethodName: "GetGitGraphRelatedFiles",
			Handler:    _GitGraphService_GetGitGraphRelatedFiles_Handler,
		},
		{
			MethodName: "GetGitGraphStatus",
			Handler:    _GitGraphService_GetGitGraphStatus_Handler,
		},
		{
			MethodName: "DeleteGitGraph",
			Handler:    _GitGraphService_DeleteGitGraph_Handler,
		},
		{
			MethodName: "IsGitGraphEnabled",
			Handler:    _GitGraphService_IsGitGraphEnabled_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	GitIndexService_RepoHistoryInitHandshake_FullMethodName = "/aiserver.v1.GitIndexService/RepoHistoryInitHandshake"
	GitIndexService_RepoHistorySyncOne_FullMethodName       = "/aiserver.v1.GitIndexService/RepoHistorySyncOne"
	GitIndexService_RepoHistorySyncComplete_FullMethodName  = "/aiserver.v1.GitIndexService/RepoHistorySyncComplete"
	GitIndexService_RemoveRepoHistory_FullMethodName        = "/aiserver.v1.GitIndexService/RemoveRepoHistory"
	GitIndexService_SearchPRHistory_FullMethodName          = "/aiserver.v1.GitIndexService/SearchPRHistory"
	GitIndexService_GetPRIndexingStatus_FullMethodName      = "/aiserver.v1.GitIndexService/GetPRIndexingStatus"
)

// GitIndexServiceClient is the client API for GitIndexService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.GitIndexService (var: cWe)
type GitIndexServiceClient interface {
	RepoHistoryInitHandshake(ctx context.Context, in *RepoHistoryInitHandshakeRequest, opts ...grpc.CallOption) (*RepoHistoryInitHandshakeResponse, error)
	RepoHistorySyncOne(ctx context.Context, in *RepoHistorySyncOneRequest, opts ...grpc.CallOption) (*RepoHistorySyncOneResponse, error)
	RepoHistorySyncComplete(ctx context.Context, in *RepoHistorySyncCompleteRequest, opts ...grpc.CallOption) (*RepoHistorySyncCompleteResponse, error)
	RemoveRepoHistory(ctx context.Context, in *RemoveRepoHistoryRequest, opts ...grpc.CallOption) (*RemoveRepoHistoryResponse, error)
	SearchPRHistory(ctx context.Context, in *SearchPRHistoryRequest, opts ...grpc.CallOption) (*SearchPRHistoryResponse, error)
	GetPRIndexingStatus(ctx context.Context, in *GetPRIndexingStatusRequest, opts ...grpc.CallOption) (*GetPRIndexingStatusResponse, error)
}

type gitIndexServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGitIndexServiceClient(cc grpc.ClientConnInterface) GitIndexServiceClient {
	return &gitIndexServiceClient{cc}
}

func (c *gitIndexServiceClient) RepoHistoryInitHandshake(ctx context.Context, in *RepoHistoryInitHandshakeRequest, opts ...grpc.CallOption) (*RepoHistoryInitHandshakeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepoHistoryInitHandshakeResponse)
	err := c.cc.Invoke(ctx, GitIndexService_RepoHistoryInitHandshake_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitIndexServiceClient) RepoHistorySyncOne(ctx context.Context, in *RepoHistorySyncOneRequest, opts ...grpc.CallOption) (*RepoHistorySyncOneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepoHistorySyncOneResponse)
	err := c.cc.Invoke(ctx, GitIndexService_RepoHistorySyncOne_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitIndexServiceClient) RepoHistorySyncComplete(ctx context.Context, in *RepoHistorySyncCompleteRequest, opts ...grpc.CallOption) (*RepoHistorySyncCompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepoHistorySyncCompleteResponse)
	err := c.cc.Invoke(ctx, GitIndexService_RepoHistorySyncComplete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitIndexServiceClient) RemoveRepoHistory(ctx context.Context, in *RemoveRepoHistoryRequest, opts ...grpc.CallOption) (*RemoveRepoHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveRepoHistoryResponse)
	err := c.cc.Invoke(ctx, GitIndexService_RemoveRepoHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitIndexServiceClient) SearchPRHistory(ctx context.Context, in *SearchPRHistoryRequest, opts ...grpc.CallOption) (*SearchPRHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchPRHistoryResponse)
	err := c.cc.Invoke(ctx, GitIndexService_SearchPRHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitIndexServiceClient) GetPRIndexingStatus(ctx context.Context, in *GetPRIndexingStatusRequest, opts ...grpc.CallOption) (*GetPRIndexingStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPRIndexingStatusResponse)
	err := c.cc.Invoke(ctx, GitIndexService_GetPRIndexingStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GitIndexServiceServer is the server API for GitIndexService service.
// All implementations must embed UnimplementedGitIndexServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.GitIndexService (var: cWe)
type GitIndexServiceServer interface {
	RepoHistoryInitHandshake(context.Context, *RepoHistoryInitHandshakeRequest) (*RepoHistoryInitHandshakeResponse, error)
	RepoHistorySyncOne(context.Context, *RepoHistorySyncOneRequest) (*RepoHistorySyncOneResponse, error)
	RepoHistorySyncComplete(context.Context, *RepoHistorySyncCompleteRequest) (*RepoHistorySyncCompleteResponse, error)
	RemoveRepoHistory(context.Context, *RemoveRepoHistoryRequest) (*RemoveRepoHistoryResponse, error)
	SearchPRHistory(context.Context, *SearchPRHistoryRequest) (*SearchPRHistoryResponse, error)
	GetPRIndexingStatus(context.Context, *GetPRIndexingStatusRequest) (*GetPRIndexingStatusResponse, error)
	mustEmbedUnimplementedGitIndexServiceServer()
}

// UnimplementedGitIndexServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGitIndexServiceServer struct{}

func (UnimplementedGitIndexServiceServer) RepoHistoryInitHandshake(context.Context, *RepoHistoryInitHandshakeRequest) (*RepoHistoryInitHandshakeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RepoHistoryInitHandshake not implemented")
}
func (UnimplementedGitIndexServiceServer) RepoHistorySyncOne(context.Context, *RepoHistorySyncOneRequest) (*RepoHistorySyncOneResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RepoHistorySyncOne not implemented")
}
func (UnimplementedGitIndexServiceServer) RepoHistorySyncComplete(context.Context, *RepoHistorySyncCompleteRequest) (*RepoHistorySyncCompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RepoHistorySyncComplete not implemented")
}
func (UnimplementedGitIndexServiceServer) RemoveRepoHistory(context.Context, *RemoveRepoHistoryRequest) (*RemoveRepoHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRepoHistory not implemented")
}
func (UnimplementedGitIndexServiceServer) SearchPRHistory(context.Context, *SearchPRHistoryRequest) (*SearchPRHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchPRHistory not implemented")
}
func (UnimplementedGitIndexServiceServer) GetPRIndexingStatus(context.Context, *GetPRIndexingStatusRequest) (*GetPRIndexingStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPRIndexingStatus not implemented")
}
func (UnimplementedGitIndexServiceServer) mustEmbedUnimplementedGitIndexServiceServer() {}
func (UnimplementedGitIndexServiceServer) testEmbeddedByValue()                         {}

// UnsafeGitIndexServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GitIndexServiceServer will
// result in compilation errors.
type UnsafeGitIndexServiceServer interface {
	mustEmbedUnimplementedGitIndexServiceServer()
}

func RegisterGitIndexServiceServer(s grpc.ServiceRegistrar, srv GitIndexServiceServer) {
	// If the following call panics, it indicates UnimplementedGitIndexServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GitIndexService_ServiceDesc, srv)
}

func _GitIndexService_RepoHistoryInitHandshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoHistoryInitHandshakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).RepoHistoryInitHandshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_RepoHistoryInitHandshake_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).RepoHistoryInitHandshake(ctx, req.(*RepoHistoryInitHandshakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitIndexService_RepoHistorySyncOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoHistorySyncOneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).RepoHistorySyncOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_RepoHistorySyncOne_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).RepoHistorySyncOne(ctx, req.(*RepoHistorySyncOneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitIndexService_RepoHistorySyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoHistorySyncCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).RepoHistorySyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_RepoHistorySyncComplete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).RepoHistorySyncComplete(ctx, req.(*RepoHistorySyncCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitIndexService_RemoveRepoHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRepoHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).RemoveRepoHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_RemoveRepoHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).RemoveRepoHistory(ctx, req.(*RemoveRepoHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitIndexService_SearchPRHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchPRHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).SearchPRHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_SearchPRHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).SearchPRHistory(ctx, req.(*SearchPRHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GitIndexService_GetPRIndexingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPRIndexingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitIndexServiceServer).GetPRIndexingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GitIndexService_GetPRIndexingStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitIndexServiceServer).GetPRIndexingStatus(ctx, req.(*GetPRIndexingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GitIndexService_ServiceDesc is the grpc.ServiceDesc for GitIndexService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GitIndexService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.GitIndexService",
	HandlerType: (*GitIndexServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RepoHistoryInitHandshake",
			Handler:    _GitIndexService_RepoHistoryInitHandshake_Handler,
		},
		{
			MethodName: "RepoHistorySyncOne",
			Handler:    _GitIndexService_RepoHistorySyncOne_Handler,
		},
		{
			MethodName: "RepoHistorySyncComplete",
			Handler:    _GitIndexService_RepoHistorySyncComplete_Handler,
		},
		{
			MethodName: "RemoveRepoHistory",
			Handler:    _GitIndexService_RemoveRepoHistory_Handler,
		},
		{
			MethodName: "SearchPRHistory",
			Handler:    _GitIndexService_SearchPRHistory_Handler,
		},
		{
			MethodName: "GetPRIndexingStatus",
			Handler:    _GitIndexService_GetPRIndexingStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	HallucinatedFunctionsService_V0ChainRun_FullMethodName           = "/aiserver.v1.HallucinatedFunctionsService/V0ChainRun"
	HallucinatedFunctionsService_Opus2ChainPlan_FullMethodName       = "/aiserver.v1.HallucinatedFunctionsService/Opus2ChainPlan"
	HallucinatedFunctionsService_Opus2ChainApplyPlan_FullMethodName  = "/aiserver.v1.HallucinatedFunctionsService/Opus2ChainApplyPlan"
	HallucinatedFunctionsService_Opus2ChainReflect_FullMethodName    = "/aiserver.v1.HallucinatedFunctionsService/Opus2ChainReflect"
	HallucinatedFunctionsService_SortUsefulTypesNaive_FullMethodName = "/aiserver.v1.HallucinatedFunctionsService/SortUsefulTypesNaive"
)

// HallucinatedFunctionsServiceClient is the client API for HallucinatedFunctionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.HallucinatedFunctionsService (var: CYe)
type HallucinatedFunctionsServiceClient interface {
	V0ChainRun(ctx context.Context, in *V0ChainRunRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[V0ChainRunResponse], error)
	Opus2ChainPlan(ctx context.Context, in *Opus2ChainPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainPlanResponse], error)
	Opus2ChainApplyPlan(ctx context.Context, in *Opus2ChainApplyPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainApplyPlanResponse], error)
	Opus2ChainReflect(ctx context.Context, in *Opus2ChainReflectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainReflectResponse], error)
	SortUsefulTypesNaive(ctx context.Context, in *SortUsefulTypesNaiveRequest, opts ...grpc.CallOption) (*SortUsefulTypesNaiveResponse, error)
}

type hallucinatedFunctionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHallucinatedFunctionsServiceClient(cc grpc.ClientConnInterface) HallucinatedFunctionsServiceClient {
	return &hallucinatedFunctionsServiceClient{cc}
}

func (c *hallucinatedFunctionsServiceClient) V0ChainRun(ctx context.Context, in *V0ChainRunRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[V0ChainRunResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HallucinatedFunctionsService_ServiceDesc.Streams[0], HallucinatedFunctionsService_V0ChainRun_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[V0ChainRunRequest, V0ChainRunResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_V0ChainRunClient = grpc.ServerStreamingClient[V0ChainRunResponse]

func (c *hallucinatedFunctionsServiceClient) Opus2ChainPlan(ctx context.Context, in *Opus2ChainPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainPlanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HallucinatedFunctionsService_ServiceDesc.Streams[1], HallucinatedFunctionsService_Opus2ChainPlan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Opus2ChainPlanRequest, Opus2ChainPlanResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainPlanClient = grpc.ServerStreamingClient[Opus2ChainPlanResponse]

func (c *hallucinatedFunctionsServiceClient) Opus2ChainApplyPlan(ctx context.Context, in *Opus2ChainApplyPlanRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainApplyPlanResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HallucinatedFunctionsService_ServiceDesc.Streams[2], HallucinatedFunctionsService_Opus2ChainApplyPlan_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Opus2ChainApplyPlanRequest, Opus2ChainApplyPlanResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainApplyPlanClient = grpc.ServerStreamingClient[Opus2ChainApplyPlanResponse]

func (c *hallucinatedFunctionsServiceClient) Opus2ChainReflect(ctx context.Context, in *Opus2ChainReflectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Opus2ChainReflectResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HallucinatedFunctionsService_ServiceDesc.Streams[3], HallucinatedFunctionsService_Opus2ChainReflect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Opus2ChainReflectRequest, Opus2ChainReflectResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainReflectClient = grpc.ServerStreamingClient[Opus2ChainReflectResponse]

func (c *hallucinatedFunctionsServiceClient) SortUsefulTypesNaive(ctx context.Context, in *SortUsefulTypesNaiveRequest, opts ...grpc.CallOption) (*SortUsefulTypesNaiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SortUsefulTypesNaiveResponse)
	err := c.cc.Invoke(ctx, HallucinatedFunctionsService_SortUsefulTypesNaive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HallucinatedFunctionsServiceServer is the server API for HallucinatedFunctionsService service.
// All implementations must embed UnimplementedHallucinatedFunctionsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.HallucinatedFunctionsService (var: CYe)
type HallucinatedFunctionsServiceServer interface {
	V0ChainRun(*V0ChainRunRequest, grpc.ServerStreamingServer[V0ChainRunResponse]) error
	Opus2ChainPlan(*Opus2ChainPlanRequest, grpc.ServerStreamingServer[Opus2ChainPlanResponse]) error
	Opus2ChainApplyPlan(*Opus2ChainApplyPlanRequest, grpc.ServerStreamingServer[Opus2ChainApplyPlanResponse]) error
	Opus2ChainReflect(*Opus2ChainReflectRequest, grpc.ServerStreamingServer[Opus2ChainReflectResponse]) error
	SortUsefulTypesNaive(context.Context, *SortUsefulTypesNaiveRequest) (*SortUsefulTypesNaiveResponse, error)
	mustEmbedUnimplementedHallucinatedFunctionsServiceServer()
}

// UnimplementedHallucinatedFunctionsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHallucinatedFunctionsServiceServer struct{}

func (UnimplementedHallucinatedFunctionsServiceServer) V0ChainRun(*V0ChainRunRequest, grpc.ServerStreamingServer[V0ChainRunResponse]) error {
	return status.Error(codes.Unimplemented, "method V0ChainRun not implemented")
}
func (UnimplementedHallucinatedFunctionsServiceServer) Opus2ChainPlan(*Opus2ChainPlanRequest, grpc.ServerStreamingServer[Opus2ChainPlanResponse]) error {
	return status.Error(codes.Unimplemented, "method Opus2ChainPlan not implemented")
}
func (UnimplementedHallucinatedFunctionsServiceServer) Opus2ChainApplyPlan(*Opus2ChainApplyPlanRequest, grpc.ServerStreamingServer[Opus2ChainApplyPlanResponse]) error {
	return status.Error(codes.Unimplemented, "method Opus2ChainApplyPlan not implemented")
}
func (UnimplementedHallucinatedFunctionsServiceServer) Opus2ChainReflect(*Opus2ChainReflectRequest, grpc.ServerStreamingServer[Opus2ChainReflectResponse]) error {
	return status.Error(codes.Unimplemented, "method Opus2ChainReflect not implemented")
}
func (UnimplementedHallucinatedFunctionsServiceServer) SortUsefulTypesNaive(context.Context, *SortUsefulTypesNaiveRequest) (*SortUsefulTypesNaiveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SortUsefulTypesNaive not implemented")
}
func (UnimplementedHallucinatedFunctionsServiceServer) mustEmbedUnimplementedHallucinatedFunctionsServiceServer() {
}
func (UnimplementedHallucinatedFunctionsServiceServer) testEmbeddedByValue() {}

// UnsafeHallucinatedFunctionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HallucinatedFunctionsServiceServer will
// result in compilation errors.
type UnsafeHallucinatedFunctionsServiceServer interface {
	mustEmbedUnimplementedHallucinatedFunctionsServiceServer()
}

func RegisterHallucinatedFunctionsServiceServer(s grpc.ServiceRegistrar, srv HallucinatedFunctionsServiceServer) {
	// If the following call panics, it indicates UnimplementedHallucinatedFunctionsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HallucinatedFunctionsService_ServiceDesc, srv)
}

func _HallucinatedFunctionsService_V0ChainRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(V0ChainRunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HallucinatedFunctionsServiceServer).V0ChainRun(m, &grpc.GenericServerStream[V0ChainRunRequest, V0ChainRunResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_V0ChainRunServer = grpc.ServerStreamingServer[V0ChainRunResponse]

func _HallucinatedFunctionsService_Opus2ChainPlan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Opus2ChainPlanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HallucinatedFunctionsServiceServer).Opus2ChainPlan(m, &grpc.GenericServerStream[Opus2ChainPlanRequest, Opus2ChainPlanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainPlanServer = grpc.ServerStreamingServer[Opus2ChainPlanResponse]

func _HallucinatedFunctionsService_Opus2ChainApplyPlan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Opus2ChainApplyPlanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HallucinatedFunctionsServiceServer).Opus2ChainApplyPlan(m, &grpc.GenericServerStream[Opus2ChainApplyPlanRequest, Opus2ChainApplyPlanResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainApplyPlanServer = grpc.ServerStreamingServer[Opus2ChainApplyPlanResponse]

func _HallucinatedFunctionsService_Opus2ChainReflect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Opus2ChainReflectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HallucinatedFunctionsServiceServer).Opus2ChainReflect(m, &grpc.GenericServerStream[Opus2ChainReflectRequest, Opus2ChainReflectResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HallucinatedFunctionsService_Opus2ChainReflectServer = grpc.ServerStreamingServer[Opus2ChainReflectResponse]

func _HallucinatedFunctionsService_SortUsefulTypesNaive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SortUsefulTypesNaiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HallucinatedFunctionsServiceServer).SortUsefulTypesNaive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HallucinatedFunctionsService_SortUsefulTypesNaive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HallucinatedFunctionsServiceServer).SortUsefulTypesNaive(ctx, req.(*SortUsefulTypesNaiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HallucinatedFunctionsService_ServiceDesc is the grpc.ServiceDesc for HallucinatedFunctionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HallucinatedFunctionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.HallucinatedFunctionsService",
	HandlerType: (*HallucinatedFunctionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SortUsefulTypesNaive",
			Handler:    _HallucinatedFunctionsService_SortUsefulTypesNaive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "V0ChainRun",
			Handler:       _HallucinatedFunctionsService_V0ChainRun_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Opus2ChainPlan",
			Handler:       _HallucinatedFunctionsService_Opus2ChainPlan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Opus2ChainApplyPlan",
			Handler:       _HallucinatedFunctionsService_Opus2ChainApplyPlan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Opus2ChainReflect",
			Handler:       _HallucinatedFunctionsService_Opus2ChainReflect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	HealthService_Ping_FullMethodName           = "/aiserver.v1.HealthService/Ping"
	HealthService_Unary_FullMethodName          = "/aiserver.v1.HealthService/Unary"
	HealthService_Stream_FullMethodName         = "/aiserver.v1.HealthService/Stream"
	HealthService_StreamSSE_FullMethodName      = "/aiserver.v1.HealthService/StreamSSE"
	HealthService_StreamBidi_FullMethodName     = "/aiserver.v1.HealthService/StreamBidi"
	HealthService_StreamBidiSSE_FullMethodName  = "/aiserver.v1.HealthService/StreamBidiSSE"
	HealthService_StreamBidiPoll_FullMethodName = "/aiserver.v1.HealthService/StreamBidiPoll"
)

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.HealthService (var: IYe)
type HealthServiceClient interface {
	Ping(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	Unary(ctx context.Context, in *HealthEmptyRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	Stream(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error)
	StreamSSE(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error)
	StreamBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HealthRequest, HealthResponse], error)
	StreamBidiSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error)
	StreamBidiPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Ping(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, HealthService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) Unary(ctx context.Context, in *HealthEmptyRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, HealthService_Unary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthServiceClient) Stream(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[0], HealthService_Stream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HealthRequest, HealthResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamClient = grpc.ServerStreamingClient[HealthResponse]

func (c *healthServiceClient) StreamSSE(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[1], HealthService_StreamSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HealthRequest, HealthResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamSSEClient = grpc.ServerStreamingClient[HealthResponse]

func (c *healthServiceClient) StreamBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[HealthRequest, HealthResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[2], HealthService_StreamBidi_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[HealthRequest, HealthResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiClient = grpc.BidiStreamingClient[HealthRequest, HealthResponse]

func (c *healthServiceClient) StreamBidiSSE(ctx context.Context, in *BidiRequestId, opts ...grpc.CallOption) (grpc.ServerStreamingClient[HealthResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[3], HealthService_StreamBidiSSE_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiRequestId, HealthResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiSSEClient = grpc.ServerStreamingClient[HealthResponse]

func (c *healthServiceClient) StreamBidiPoll(ctx context.Context, in *BidiPollRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BidiPollResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HealthService_ServiceDesc.Streams[4], HealthService_StreamBidiPoll_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BidiPollRequest, BidiPollResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiPollClient = grpc.ServerStreamingClient[BidiPollResponse]

// HealthServiceServer is the server API for HealthService service.
// All implementations must embed UnimplementedHealthServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.HealthService (var: IYe)
type HealthServiceServer interface {
	Ping(context.Context, *HealthRequest) (*HealthResponse, error)
	Unary(context.Context, *HealthEmptyRequest) (*HealthResponse, error)
	Stream(*HealthRequest, grpc.ServerStreamingServer[HealthResponse]) error
	StreamSSE(*HealthRequest, grpc.ServerStreamingServer[HealthResponse]) error
	StreamBidi(grpc.BidiStreamingServer[HealthRequest, HealthResponse]) error
	StreamBidiSSE(*BidiRequestId, grpc.ServerStreamingServer[HealthResponse]) error
	StreamBidiPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error
	mustEmbedUnimplementedHealthServiceServer()
}

// UnimplementedHealthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthServiceServer struct{}

func (UnimplementedHealthServiceServer) Ping(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedHealthServiceServer) Unary(context.Context, *HealthEmptyRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unary not implemented")
}
func (UnimplementedHealthServiceServer) Stream(*HealthRequest, grpc.ServerStreamingServer[HealthResponse]) error {
	return status.Error(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedHealthServiceServer) StreamSSE(*HealthRequest, grpc.ServerStreamingServer[HealthResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamSSE not implemented")
}
func (UnimplementedHealthServiceServer) StreamBidi(grpc.BidiStreamingServer[HealthRequest, HealthResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBidi not implemented")
}
func (UnimplementedHealthServiceServer) StreamBidiSSE(*BidiRequestId, grpc.ServerStreamingServer[HealthResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBidiSSE not implemented")
}
func (UnimplementedHealthServiceServer) StreamBidiPoll(*BidiPollRequest, grpc.ServerStreamingServer[BidiPollResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBidiPoll not implemented")
}
func (UnimplementedHealthServiceServer) mustEmbedUnimplementedHealthServiceServer() {}
func (UnimplementedHealthServiceServer) testEmbeddedByValue()                       {}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Ping(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_Unary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthEmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Unary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthService_Unary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Unary(ctx, req.(*HealthEmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HealthRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).Stream(m, &grpc.GenericServerStream[HealthRequest, HealthResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamServer = grpc.ServerStreamingServer[HealthResponse]

func _HealthService_StreamSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HealthRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).StreamSSE(m, &grpc.GenericServerStream[HealthRequest, HealthResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamSSEServer = grpc.ServerStreamingServer[HealthResponse]

func _HealthService_StreamBidi_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HealthServiceServer).StreamBidi(&grpc.GenericServerStream[HealthRequest, HealthResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiServer = grpc.BidiStreamingServer[HealthRequest, HealthResponse]

func _HealthService_StreamBidiSSE_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiRequestId)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).StreamBidiSSE(m, &grpc.GenericServerStream[BidiRequestId, HealthResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiSSEServer = grpc.ServerStreamingServer[HealthResponse]

func _HealthService_StreamBidiPoll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BidiPollRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HealthServiceServer).StreamBidiPoll(m, &grpc.GenericServerStream[BidiPollRequest, BidiPollResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HealthService_StreamBidiPollServer = grpc.ServerStreamingServer[BidiPollResponse]

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _HealthService_Ping_Handler,
		},
		{
			MethodName: "Unary",
			Handler:    _HealthService_Unary_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _HealthService_Stream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSSE",
			Handler:       _HealthService_StreamSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBidi",
			Handler:       _HealthService_StreamBidi_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamBidiSSE",
			Handler:       _HealthService_StreamBidiSSE_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBidiPoll",
			Handler:       _HealthService_StreamBidiPoll_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	InAppAdService_HasSeenAd_FullMethodName        = "/aiserver.v1.InAppAdService/HasSeenAd"
	InAppAdService_MarkAdAsSeen_FullMethodName     = "/aiserver.v1.InAppAdService/MarkAdAsSeen"
	InAppAdService_ResetUserAdViews_FullMethodName = "/aiserver.v1.InAppAdService/ResetUserAdViews"
)

// InAppAdServiceClient is the client API for InAppAdService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.InAppAdService (var: JYe)
type InAppAdServiceClient interface {
	HasSeenAd(ctx context.Context, in *HasSeenAdRequest, opts ...grpc.CallOption) (*HasSeenAdResponse, error)
	MarkAdAsSeen(ctx context.Context, in *MarkAdAsSeenRequest, opts ...grpc.CallOption) (*MarkAdAsSeenResponse, error)
	ResetUserAdViews(ctx context.Context, in *ResetUserAdViewsRequest, opts ...grpc.CallOption) (*ResetUserAdViewsResponse, error)
}

type inAppAdServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInAppAdServiceClient(cc grpc.ClientConnInterface) InAppAdServiceClient {
	return &inAppAdServiceClient{cc}
}

func (c *inAppAdServiceClient) HasSeenAd(ctx context.Context, in *HasSeenAdRequest, opts ...grpc.CallOption) (*HasSeenAdResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HasSeenAdResponse)
	err := c.cc.Invoke(ctx, InAppAdService_HasSeenAd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inAppAdServiceClient) MarkAdAsSeen(ctx context.Context, in *MarkAdAsSeenRequest, opts ...grpc.CallOption) (*MarkAdAsSeenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkAdAsSeenResponse)
	err := c.cc.Invoke(ctx, InAppAdService_MarkAdAsSeen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inAppAdServiceClient) ResetUserAdViews(ctx context.Context, in *ResetUserAdViewsRequest, opts ...grpc.CallOption) (*ResetUserAdViewsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetUserAdViewsResponse)
	err := c.cc.Invoke(ctx, InAppAdService_ResetUserAdViews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InAppAdServiceServer is the server API for InAppAdService service.
// All implementations must embed UnimplementedInAppAdServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.InAppAdService (var: JYe)
type InAppAdServiceServer interface {
	HasSeenAd(context.Context, *HasSeenAdRequest) (*HasSeenAdResponse, error)
	MarkAdAsSeen(context.Context, *MarkAdAsSeenRequest) (*MarkAdAsSeenResponse, error)
	ResetUserAdViews(context.Context, *ResetUserAdViewsRequest) (*ResetUserAdViewsResponse, error)
	mustEmbedUnimplementedInAppAdServiceServer()
}

// UnimplementedInAppAdServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInAppAdServiceServer struct{}

func (UnimplementedInAppAdServiceServer) HasSeenAd(context.Context, *HasSeenAdRequest) (*HasSeenAdResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HasSeenAd not implemented")
}
func (UnimplementedInAppAdServiceServer) MarkAdAsSeen(context.Context, *MarkAdAsSeenRequest) (*MarkAdAsSeenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkAdAsSeen not implemented")
}
func (UnimplementedInAppAdServiceServer) ResetUserAdViews(context.Context, *ResetUserAdViewsRequest) (*ResetUserAdViewsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetUserAdViews not implemented")
}
func (UnimplementedInAppAdServiceServer) mustEmbedUnimplementedInAppAdServiceServer() {}
func (UnimplementedInAppAdServiceServer) testEmbeddedByValue()                        {}

// UnsafeInAppAdServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InAppAdServiceServer will
// result in compilation errors.
type UnsafeInAppAdServiceServer interface {
	mustEmbedUnimplementedInAppAdServiceServer()
}

func RegisterInAppAdServiceServer(s grpc.ServiceRegistrar, srv InAppAdServiceServer) {
	// If the following call panics, it indicates UnimplementedInAppAdServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InAppAdService_ServiceDesc, srv)
}

func _InAppAdService_HasSeenAd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasSeenAdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InAppAdServiceServer).HasSeenAd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InAppAdService_HasSeenAd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InAppAdServiceServer).HasSeenAd(ctx, req.(*HasSeenAdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InAppAdService_MarkAdAsSeen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAdAsSeenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InAppAdServiceServer).MarkAdAsSeen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InAppAdService_MarkAdAsSeen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InAppAdServiceServer).MarkAdAsSeen(ctx, req.(*MarkAdAsSeenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InAppAdService_ResetUserAdViews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetUserAdViewsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InAppAdServiceServer).ResetUserAdViews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InAppAdService_ResetUserAdViews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InAppAdServiceServer).ResetUserAdViews(ctx, req.(*ResetUserAdViewsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InAppAdService_ServiceDesc is the grpc.ServiceDesc for InAppAdService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InAppAdService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.InAppAdService",
	HandlerType: (*InAppAdServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HasSeenAd",
			Handler:    _InAppAdService_HasSeenAd_Handler,
		},
		{
			MethodName: "MarkAdAsSeen",
			Handler:    _InAppAdService_MarkAdAsSeen_Handler,
		},
		{
			MethodName: "ResetUserAdViews",
			Handler:    _InAppAdService_ResetUserAdViews_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	InferenceService_Stream_FullMethodName                            = "/aiserver.v1.InferenceService/Stream"
	InferenceService_RecordAgentFollowupClassification_FullMethodName = "/aiserver.v1.InferenceService/RecordAgentFollowupClassification"
)

// InferenceServiceClient is the client API for InferenceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.InferenceService (var: BYe)
type InferenceServiceClient interface {
	Stream(ctx context.Context, in *InferenceStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InferenceStreamResponse], error)
	RecordAgentFollowupClassification(ctx context.Context, in *AgentFollowupCategorizationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type inferenceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInferenceServiceClient(cc grpc.ClientConnInterface) InferenceServiceClient {
	return &inferenceServiceClient{cc}
}

func (c *inferenceServiceClient) Stream(ctx context.Context, in *InferenceStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InferenceStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &InferenceService_ServiceDesc.Streams[0], InferenceService_Stream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InferenceStreamRequest, InferenceStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InferenceService_StreamClient = grpc.ServerStreamingClient[InferenceStreamResponse]

func (c *inferenceServiceClient) RecordAgentFollowupClassification(ctx context.Context, in *AgentFollowupCategorizationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, InferenceService_RecordAgentFollowupClassification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InferenceServiceServer is the server API for InferenceService service.
// All implementations must embed UnimplementedInferenceServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.InferenceService (var: BYe)
type InferenceServiceServer interface {
	Stream(*InferenceStreamRequest, grpc.ServerStreamingServer[InferenceStreamResponse]) error
	RecordAgentFollowupClassification(context.Context, *AgentFollowupCategorizationRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInferenceServiceServer()
}

// UnimplementedInferenceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInferenceServiceServer struct{}

func (UnimplementedInferenceServiceServer) Stream(*InferenceStreamRequest, grpc.ServerStreamingServer[InferenceStreamResponse]) error {
	return status.Error(codes.Unimplemented, "method Stream not implemented")
}
func (UnimplementedInferenceServiceServer) RecordAgentFollowupClassification(context.Context, *AgentFollowupCategorizationRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordAgentFollowupClassification not implemented")
}
func (UnimplementedInferenceServiceServer) mustEmbedUnimplementedInferenceServiceServer() {}
func (UnimplementedInferenceServiceServer) testEmbeddedByValue()                          {}

// UnsafeInferenceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InferenceServiceServer will
// result in compilation errors.
type UnsafeInferenceServiceServer interface {
	mustEmbedUnimplementedInferenceServiceServer()
}

func RegisterInferenceServiceServer(s grpc.ServiceRegistrar, srv InferenceServiceServer) {
	// If the following call panics, it indicates UnimplementedInferenceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InferenceService_ServiceDesc, srv)
}

func _InferenceService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InferenceStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InferenceServiceServer).Stream(m, &grpc.GenericServerStream[InferenceStreamRequest, InferenceStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InferenceService_StreamServer = grpc.ServerStreamingServer[InferenceStreamResponse]

func _InferenceService_RecordAgentFollowupClassification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentFollowupCategorizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferenceServiceServer).RecordAgentFollowupClassification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InferenceService_RecordAgentFollowupClassification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferenceServiceServer).RecordAgentFollowupClassification(ctx, req.(*AgentFollowupCategorizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InferenceService_ServiceDesc is the grpc.ServiceDesc for InferenceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InferenceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.InferenceService",
	HandlerType: (*InferenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecordAgentFollowupClassification",
			Handler:    _InferenceService_RecordAgentFollowupClassification_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _InferenceService_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	LinterService_LintFile_FullMethodName         = "/aiserver.v1.LinterService/LintFile"
	LinterService_LintChunk_FullMethodName        = "/aiserver.v1.LinterService/LintChunk"
	LinterService_LintFimChunk_FullMethodName     = "/aiserver.v1.LinterService/LintFimChunk"
	LinterService_LintExplanation_FullMethodName  = "/aiserver.v1.LinterService/LintExplanation"
	LinterService_LintExplanation2_FullMethodName = "/aiserver.v1.LinterService/LintExplanation2"
)

// LinterServiceClient is the client API for LinterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.LinterService (var: nze)
type LinterServiceClient interface {
	LintFile(ctx context.Context, in *LintFileRequest, opts ...grpc.CallOption) (*LintFileResponse, error)
	LintChunk(ctx context.Context, in *LintChunkRequest, opts ...grpc.CallOption) (*LintChunkResponse, error)
	LintFimChunk(ctx context.Context, in *LintFimChunkRequest, opts ...grpc.CallOption) (*LintFimChunkResponse, error)
	LintExplanation(ctx context.Context, in *LintExplanationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LintExplanationResponse], error)
	LintExplanation2(ctx context.Context, in *LintExplanationRequest, opts ...grpc.CallOption) (*LintExplanationResponse2, error)
}

type linterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLinterServiceClient(cc grpc.ClientConnInterface) LinterServiceClient {
	return &linterServiceClient{cc}
}

func (c *linterServiceClient) LintFile(ctx context.Context, in *LintFileRequest, opts ...grpc.CallOption) (*LintFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LintFileResponse)
	err := c.cc.Invoke(ctx, LinterService_LintFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linterServiceClient) LintChunk(ctx context.Context, in *LintChunkRequest, opts ...grpc.CallOption) (*LintChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LintChunkResponse)
	err := c.cc.Invoke(ctx, LinterService_LintChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linterServiceClient) LintFimChunk(ctx context.Context, in *LintFimChunkRequest, opts ...grpc.CallOption) (*LintFimChunkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LintFimChunkResponse)
	err := c.cc.Invoke(ctx, LinterService_LintFimChunk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linterServiceClient) LintExplanation(ctx context.Context, in *LintExplanationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LintExplanationResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LinterService_ServiceDesc.Streams[0], LinterService_LintExplanation_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LintExplanationRequest, LintExplanationResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LinterService_LintExplanationClient = grpc.ServerStreamingClient[LintExplanationResponse]

func (c *linterServiceClient) LintExplanation2(ctx context.Context, in *LintExplanationRequest, opts ...grpc.CallOption) (*LintExplanationResponse2, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LintExplanationResponse2)
	err := c.cc.Invoke(ctx, LinterService_LintExplanation2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LinterServiceServer is the server API for LinterService service.
// All implementations must embed UnimplementedLinterServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.LinterService (var: nze)
type LinterServiceServer interface {
	LintFile(context.Context, *LintFileRequest) (*LintFileResponse, error)
	LintChunk(context.Context, *LintChunkRequest) (*LintChunkResponse, error)
	LintFimChunk(context.Context, *LintFimChunkRequest) (*LintFimChunkResponse, error)
	LintExplanation(*LintExplanationRequest, grpc.ServerStreamingServer[LintExplanationResponse]) error
	LintExplanation2(context.Context, *LintExplanationRequest) (*LintExplanationResponse2, error)
	mustEmbedUnimplementedLinterServiceServer()
}

// UnimplementedLinterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLinterServiceServer struct{}

func (UnimplementedLinterServiceServer) LintFile(context.Context, *LintFileRequest) (*LintFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LintFile not implemented")
}
func (UnimplementedLinterServiceServer) LintChunk(context.Context, *LintChunkRequest) (*LintChunkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LintChunk not implemented")
}
func (UnimplementedLinterServiceServer) LintFimChunk(context.Context, *LintFimChunkRequest) (*LintFimChunkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LintFimChunk not implemented")
}
func (UnimplementedLinterServiceServer) LintExplanation(*LintExplanationRequest, grpc.ServerStreamingServer[LintExplanationResponse]) error {
	return status.Error(codes.Unimplemented, "method LintExplanation not implemented")
}
func (UnimplementedLinterServiceServer) LintExplanation2(context.Context, *LintExplanationRequest) (*LintExplanationResponse2, error) {
	return nil, status.Error(codes.Unimplemented, "method LintExplanation2 not implemented")
}
func (UnimplementedLinterServiceServer) mustEmbedUnimplementedLinterServiceServer() {}
func (UnimplementedLinterServiceServer) testEmbeddedByValue()                       {}

// UnsafeLinterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LinterServiceServer will
// result in compilation errors.
type UnsafeLinterServiceServer interface {
	mustEmbedUnimplementedLinterServiceServer()
}

func RegisterLinterServiceServer(s grpc.ServiceRegistrar, srv LinterServiceServer) {
	// If the following call panics, it indicates UnimplementedLinterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LinterService_ServiceDesc, srv)
}

func _LinterService_LintFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LintFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinterServiceServer).LintFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinterService_LintFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinterServiceServer).LintFile(ctx, req.(*LintFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinterService_LintChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LintChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinterServiceServer).LintChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinterService_LintChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinterServiceServer).LintChunk(ctx, req.(*LintChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinterService_LintFimChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LintFimChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinterServiceServer).LintFimChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinterService_LintFimChunk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinterServiceServer).LintFimChunk(ctx, req.(*LintFimChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinterService_LintExplanation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LintExplanationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LinterServiceServer).LintExplanation(m, &grpc.GenericServerStream[LintExplanationRequest, LintExplanationResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LinterService_LintExplanationServer = grpc.ServerStreamingServer[LintExplanationResponse]

func _LinterService_LintExplanation2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LintExplanationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinterServiceServer).LintExplanation2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinterService_LintExplanation2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinterServiceServer).LintExplanation2(ctx, req.(*LintExplanationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LinterService_ServiceDesc is the grpc.ServiceDesc for LinterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LinterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.LinterService",
	HandlerType: (*LinterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LintFile",
			Handler:    _LinterService_LintFile_Handler,
		},
		{
			MethodName: "LintChunk",
			Handler:    _LinterService_LintChunk_Handler,
		},
		{
			MethodName: "LintFimChunk",
			Handler:    _LinterService_LintFimChunk_Handler,
		},
		{
			MethodName: "LintExplanation2",
			Handler:    _LinterService_LintExplanation2_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LintExplanation",
			Handler:       _LinterService_LintExplanation_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	MCPRegistryService_GetKnownServers_FullMethodName = "/aiserver.v1.MCPRegistryService/GetKnownServers"
)

// MCPRegistryServiceClient is the client API for MCPRegistryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.MCPRegistryService (var: DYe)
type MCPRegistryServiceClient interface {
	GetKnownServers(ctx context.Context, in *GetKnownServersRequest, opts ...grpc.CallOption) (*GetKnownServersResponse, error)
}

type mCPRegistryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMCPRegistryServiceClient(cc grpc.ClientConnInterface) MCPRegistryServiceClient {
	return &mCPRegistryServiceClient{cc}
}

func (c *mCPRegistryServiceClient) GetKnownServers(ctx context.Context, in *GetKnownServersRequest, opts ...grpc.CallOption) (*GetKnownServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKnownServersResponse)
	err := c.cc.Invoke(ctx, MCPRegistryService_GetKnownServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MCPRegistryServiceServer is the server API for MCPRegistryService service.
// All implementations must embed UnimplementedMCPRegistryServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.MCPRegistryService (var: DYe)
type MCPRegistryServiceServer interface {
	GetKnownServers(context.Context, *GetKnownServersRequest) (*GetKnownServersResponse, error)
	mustEmbedUnimplementedMCPRegistryServiceServer()
}

// UnimplementedMCPRegistryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMCPRegistryServiceServer struct{}

func (UnimplementedMCPRegistryServiceServer) GetKnownServers(context.Context, *GetKnownServersRequest) (*GetKnownServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetKnownServers not implemented")
}
func (UnimplementedMCPRegistryServiceServer) mustEmbedUnimplementedMCPRegistryServiceServer() {}
func (UnimplementedMCPRegistryServiceServer) testEmbeddedByValue()                            {}

// UnsafeMCPRegistryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MCPRegistryServiceServer will
// result in compilation errors.
type UnsafeMCPRegistryServiceServer interface {
	mustEmbedUnimplementedMCPRegistryServiceServer()
}

func RegisterMCPRegistryServiceServer(s grpc.ServiceRegistrar, srv MCPRegistryServiceServer) {
	// If the following call panics, it indicates UnimplementedMCPRegistryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MCPRegistryService_ServiceDesc, srv)
}

func _MCPRegistryService_GetKnownServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKnownServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPRegistryServiceServer).GetKnownServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPRegistryService_GetKnownServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPRegistryServiceServer).GetKnownServers(ctx, req.(*GetKnownServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MCPRegistryService_ServiceDesc is the grpc.ServiceDesc for MCPRegistryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MCPRegistryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.MCPRegistryService",
	HandlerType: (*MCPRegistryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKnownServers",
			Handler:    _MCPRegistryService_GetKnownServers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	MarketplaceService_CreateMarketplaceExtensionPublisher_FullMethodName = "/aiserver.v1.MarketplaceService/CreateMarketplaceExtensionPublisher"
)

// MarketplaceServiceClient is the client API for MarketplaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.MarketplaceService (var: qYe)
type MarketplaceServiceClient interface {
	CreateMarketplaceExtensionPublisher(ctx context.Context, in *CreateMarketplaceExtensionPublisherRequest, opts ...grpc.CallOption) (*CreateMarketplaceExtensionPublisherResponse, error)
}

type marketplaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMarketplaceServiceClient(cc grpc.ClientConnInterface) MarketplaceServiceClient {
	return &marketplaceServiceClient{cc}
}

func (c *marketplaceServiceClient) CreateMarketplaceExtensionPublisher(ctx context.Context, in *CreateMarketplaceExtensionPublisherRequest, opts ...grpc.CallOption) (*CreateMarketplaceExtensionPublisherResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMarketplaceExtensionPublisherResponse)
	err := c.cc.Invoke(ctx, MarketplaceService_CreateMarketplaceExtensionPublisher_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarketplaceServiceServer is the server API for MarketplaceService service.
// All implementations must embed UnimplementedMarketplaceServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.MarketplaceService (var: qYe)
type MarketplaceServiceServer interface {
	CreateMarketplaceExtensionPublisher(context.Context, *CreateMarketplaceExtensionPublisherRequest) (*CreateMarketplaceExtensionPublisherResponse, error)
	mustEmbedUnimplementedMarketplaceServiceServer()
}

// UnimplementedMarketplaceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMarketplaceServiceServer struct{}

func (UnimplementedMarketplaceServiceServer) CreateMarketplaceExtensionPublisher(context.Context, *CreateMarketplaceExtensionPublisherRequest) (*CreateMarketplaceExtensionPublisherResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateMarketplaceExtensionPublisher not implemented")
}
func (UnimplementedMarketplaceServiceServer) mustEmbedUnimplementedMarketplaceServiceServer() {}
func (UnimplementedMarketplaceServiceServer) testEmbeddedByValue()                            {}

// UnsafeMarketplaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarketplaceServiceServer will
// result in compilation errors.
type UnsafeMarketplaceServiceServer interface {
	mustEmbedUnimplementedMarketplaceServiceServer()
}

func RegisterMarketplaceServiceServer(s grpc.ServiceRegistrar, srv MarketplaceServiceServer) {
	// If the following call panics, it indicates UnimplementedMarketplaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MarketplaceService_ServiceDesc, srv)
}

func _MarketplaceService_CreateMarketplaceExtensionPublisher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMarketplaceExtensionPublisherRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarketplaceServiceServer).CreateMarketplaceExtensionPublisher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MarketplaceService_CreateMarketplaceExtensionPublisher_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarketplaceServiceServer).CreateMarketplaceExtensionPublisher(ctx, req.(*CreateMarketplaceExtensionPublisherRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MarketplaceService_ServiceDesc is the grpc.ServiceDesc for MarketplaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MarketplaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.MarketplaceService",
	HandlerType: (*MarketplaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMarketplaceExtensionPublisher",
			Handler:    _MarketplaceService_CreateMarketplaceExtensionPublisher_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	MetricsService_ReportIncrement_FullMethodName    = "/aiserver.v1.MetricsService/ReportIncrement"
	MetricsService_ReportDecrement_FullMethodName    = "/aiserver.v1.MetricsService/ReportDecrement"
	MetricsService_ReportDistribution_FullMethodName = "/aiserver.v1.MetricsService/ReportDistribution"
	MetricsService_ReportGauge_FullMethodName        = "/aiserver.v1.MetricsService/ReportGauge"
)

// MetricsServiceClient is the client API for MetricsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.MetricsService (var: ize)
type MetricsServiceClient interface {
	ReportIncrement(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error)
	ReportDecrement(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error)
	ReportDistribution(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error)
	ReportGauge(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error)
}

type metricsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMetricsServiceClient(cc grpc.ClientConnInterface) MetricsServiceClient {
	return &metricsServiceClient{cc}
}

func (c *metricsServiceClient) ReportIncrement(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportMetricsResponse)
	err := c.cc.Invoke(ctx, MetricsService_ReportIncrement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsServiceClient) ReportDecrement(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportMetricsResponse)
	err := c.cc.Invoke(ctx, MetricsService_ReportDecrement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsServiceClient) ReportDistribution(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportMetricsResponse)
	err := c.cc.Invoke(ctx, MetricsService_ReportDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metricsServiceClient) ReportGauge(ctx context.Context, in *ReportMetricsRequest, opts ...grpc.CallOption) (*ReportMetricsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportMetricsResponse)
	err := c.cc.Invoke(ctx, MetricsService_ReportGauge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsServiceServer is the server API for MetricsService service.
// All implementations must embed UnimplementedMetricsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.MetricsService (var: ize)
type MetricsServiceServer interface {
	ReportIncrement(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error)
	ReportDecrement(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error)
	ReportDistribution(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error)
	ReportGauge(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error)
	mustEmbedUnimplementedMetricsServiceServer()
}

// UnimplementedMetricsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMetricsServiceServer struct{}

func (UnimplementedMetricsServiceServer) ReportIncrement(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportIncrement not implemented")
}
func (UnimplementedMetricsServiceServer) ReportDecrement(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportDecrement not implemented")
}
func (UnimplementedMetricsServiceServer) ReportDistribution(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportDistribution not implemented")
}
func (UnimplementedMetricsServiceServer) ReportGauge(context.Context, *ReportMetricsRequest) (*ReportMetricsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportGauge not implemented")
}
func (UnimplementedMetricsServiceServer) mustEmbedUnimplementedMetricsServiceServer() {}
func (UnimplementedMetricsServiceServer) testEmbeddedByValue()                        {}

// UnsafeMetricsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetricsServiceServer will
// result in compilation errors.
type UnsafeMetricsServiceServer interface {
	mustEmbedUnimplementedMetricsServiceServer()
}

func RegisterMetricsServiceServer(s grpc.ServiceRegistrar, srv MetricsServiceServer) {
	// If the following call panics, it indicates UnimplementedMetricsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MetricsService_ServiceDesc, srv)
}

func _MetricsService_ReportIncrement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServiceServer).ReportIncrement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetricsService_ReportIncrement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServiceServer).ReportIncrement(ctx, req.(*ReportMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsService_ReportDecrement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServiceServer).ReportDecrement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetricsService_ReportDecrement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServiceServer).ReportDecrement(ctx, req.(*ReportMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsService_ReportDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServiceServer).ReportDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetricsService_ReportDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServiceServer).ReportDistribution(ctx, req.(*ReportMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetricsService_ReportGauge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsServiceServer).ReportGauge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetricsService_ReportGauge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsServiceServer).ReportGauge(ctx, req.(*ReportMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetricsService_ServiceDesc is the grpc.ServiceDesc for MetricsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetricsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.MetricsService",
	HandlerType: (*MetricsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportIncrement",
			Handler:    _MetricsService_ReportIncrement_Handler,
		},
		{
			MethodName: "ReportDecrement",
			Handler:    _MetricsService_ReportDecrement_Handler,
		},
		{
			MethodName: "ReportDistribution",
			Handler:    _MetricsService_ReportDistribution_Handler,
		},
		{
			MethodName: "ReportGauge",
			Handler:    _MetricsService_ReportGauge_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	NetworkService_GetPublicIp_FullMethodName = "/aiserver.v1.NetworkService/GetPublicIp"
	NetworkService_IsConnected_FullMethodName = "/aiserver.v1.NetworkService/IsConnected"
)

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.NetworkService (var: FYe)
type NetworkServiceClient interface {
	GetPublicIp(ctx context.Context, in *GetPublicIpRequest, opts ...grpc.CallOption) (*GetPublicIpResponse, error)
	IsConnected(ctx context.Context, in *IsConnectedRequest, opts ...grpc.CallOption) (*IsConnectedResponse, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) GetPublicIp(ctx context.Context, in *GetPublicIpRequest, opts ...grpc.CallOption) (*GetPublicIpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPublicIpResponse)
	err := c.cc.Invoke(ctx, NetworkService_GetPublicIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) IsConnected(ctx context.Context, in *IsConnectedRequest, opts ...grpc.CallOption) (*IsConnectedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsConnectedResponse)
	err := c.cc.Invoke(ctx, NetworkService_IsConnected_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.NetworkService (var: FYe)
type NetworkServiceServer interface {
	GetPublicIp(context.Context, *GetPublicIpRequest) (*GetPublicIpResponse, error)
	IsConnected(context.Context, *IsConnectedRequest) (*IsConnectedResponse, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetworkServiceServer struct{}

func (UnimplementedNetworkServiceServer) GetPublicIp(context.Context, *GetPublicIpRequest) (*GetPublicIpResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPublicIp not implemented")
}
func (UnimplementedNetworkServiceServer) IsConnected(context.Context, *IsConnectedRequest) (*IsConnectedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IsConnected not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}
func (UnimplementedNetworkServiceServer) testEmbeddedByValue()                        {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	// If the following call panics, it indicates UnimplementedNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_GetPublicIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).GetPublicIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_GetPublicIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).GetPublicIp(ctx, req.(*GetPublicIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_IsConnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsConnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).IsConnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_IsConnected_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).IsConnected(ctx, req.(*IsConnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPublicIp",
			Handler:    _NetworkService_GetPublicIp_Handler,
		},
		{
			MethodName: "IsConnected",
			Handler:    _NetworkService_IsConnected_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	OnlineMetricsService_ReportAgentSnapshot_FullMethodName = "/aiserver.v1.OnlineMetricsService/ReportAgentSnapshot"
)

// OnlineMetricsServiceClient is the client API for OnlineMetricsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.OnlineMetricsService (var: OYe)
type OnlineMetricsServiceClient interface {
	ReportAgentSnapshot(ctx context.Context, in *ReportAgentSnapshotRequest, opts ...grpc.CallOption) (*ReportAgentSnapshotResponse, error)
}

type onlineMetricsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOnlineMetricsServiceClient(cc grpc.ClientConnInterface) OnlineMetricsServiceClient {
	return &onlineMetricsServiceClient{cc}
}

func (c *onlineMetricsServiceClient) ReportAgentSnapshot(ctx context.Context, in *ReportAgentSnapshotRequest, opts ...grpc.CallOption) (*ReportAgentSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportAgentSnapshotResponse)
	err := c.cc.Invoke(ctx, OnlineMetricsService_ReportAgentSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnlineMetricsServiceServer is the server API for OnlineMetricsService service.
// All implementations must embed UnimplementedOnlineMetricsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.OnlineMetricsService (var: OYe)
type OnlineMetricsServiceServer interface {
	ReportAgentSnapshot(context.Context, *ReportAgentSnapshotRequest) (*ReportAgentSnapshotResponse, error)
	mustEmbedUnimplementedOnlineMetricsServiceServer()
}

// UnimplementedOnlineMetricsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOnlineMetricsServiceServer struct{}

func (UnimplementedOnlineMetricsServiceServer) ReportAgentSnapshot(context.Context, *ReportAgentSnapshotRequest) (*ReportAgentSnapshotResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportAgentSnapshot not implemented")
}
func (UnimplementedOnlineMetricsServiceServer) mustEmbedUnimplementedOnlineMetricsServiceServer() {}
func (UnimplementedOnlineMetricsServiceServer) testEmbeddedByValue()                              {}

// UnsafeOnlineMetricsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OnlineMetricsServiceServer will
// result in compilation errors.
type UnsafeOnlineMetricsServiceServer interface {
	mustEmbedUnimplementedOnlineMetricsServiceServer()
}

func RegisterOnlineMetricsServiceServer(s grpc.ServiceRegistrar, srv OnlineMetricsServiceServer) {
	// If the following call panics, it indicates UnimplementedOnlineMetricsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OnlineMetricsService_ServiceDesc, srv)
}

func _OnlineMetricsService_ReportAgentSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnlineMetricsServiceServer).ReportAgentSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OnlineMetricsService_ReportAgentSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnlineMetricsServiceServer).ReportAgentSnapshot(ctx, req.(*ReportAgentSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OnlineMetricsService_ServiceDesc is the grpc.ServiceDesc for OnlineMetricsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OnlineMetricsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.OnlineMetricsService",
	HandlerType: (*OnlineMetricsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportAgentSnapshot",
			Handler:    _OnlineMetricsService_ReportAgentSnapshot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	PerformanceEventService_SubmitPerformanceEvents_FullMethodName = "/aiserver.v1.PerformanceEventService/SubmitPerformanceEvents"
)

// PerformanceEventServiceClient is the client API for PerformanceEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.PerformanceEventService (var: rze)
type PerformanceEventServiceClient interface {
	SubmitPerformanceEvents(ctx context.Context, in *SubmitPerformanceEventsRequest, opts ...grpc.CallOption) (*SubmitPerformanceEventsResponse, error)
}

type performanceEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPerformanceEventServiceClient(cc grpc.ClientConnInterface) PerformanceEventServiceClient {
	return &performanceEventServiceClient{cc}
}

func (c *performanceEventServiceClient) SubmitPerformanceEvents(ctx context.Context, in *SubmitPerformanceEventsRequest, opts ...grpc.CallOption) (*SubmitPerformanceEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitPerformanceEventsResponse)
	err := c.cc.Invoke(ctx, PerformanceEventService_SubmitPerformanceEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PerformanceEventServiceServer is the server API for PerformanceEventService service.
// All implementations must embed UnimplementedPerformanceEventServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.PerformanceEventService (var: rze)
type PerformanceEventServiceServer interface {
	SubmitPerformanceEvents(context.Context, *SubmitPerformanceEventsRequest) (*SubmitPerformanceEventsResponse, error)
	mustEmbedUnimplementedPerformanceEventServiceServer()
}

// UnimplementedPerformanceEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPerformanceEventServiceServer struct{}

func (UnimplementedPerformanceEventServiceServer) SubmitPerformanceEvents(context.Context, *SubmitPerformanceEventsRequest) (*SubmitPerformanceEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitPerformanceEvents not implemented")
}
func (UnimplementedPerformanceEventServiceServer) mustEmbedUnimplementedPerformanceEventServiceServer() {
}
func (UnimplementedPerformanceEventServiceServer) testEmbeddedByValue() {}

// UnsafePerformanceEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PerformanceEventServiceServer will
// result in compilation errors.
type UnsafePerformanceEventServiceServer interface {
	mustEmbedUnimplementedPerformanceEventServiceServer()
}

func RegisterPerformanceEventServiceServer(s grpc.ServiceRegistrar, srv PerformanceEventServiceServer) {
	// If the following call panics, it indicates UnimplementedPerformanceEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PerformanceEventService_ServiceDesc, srv)
}

func _PerformanceEventService_SubmitPerformanceEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitPerformanceEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PerformanceEventServiceServer).SubmitPerformanceEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PerformanceEventService_SubmitPerformanceEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PerformanceEventServiceServer).SubmitPerformanceEvents(ctx, req.(*SubmitPerformanceEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PerformanceEventService_ServiceDesc is the grpc.ServiceDesc for PerformanceEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PerformanceEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.PerformanceEventService",
	HandlerType: (*PerformanceEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitPerformanceEvents",
			Handler:    _PerformanceEventService_SubmitPerformanceEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ProfilingService_SubmitProfile_FullMethodName = "/aiserver.v1.ProfilingService/SubmitProfile"
)

// ProfilingServiceClient is the client API for ProfilingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ProfilingService (var: aze)
type ProfilingServiceClient interface {
	SubmitProfile(ctx context.Context, in *SubmitProfileRequest, opts ...grpc.CallOption) (*SubmitProfileResponse, error)
}

type profilingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProfilingServiceClient(cc grpc.ClientConnInterface) ProfilingServiceClient {
	return &profilingServiceClient{cc}
}

func (c *profilingServiceClient) SubmitProfile(ctx context.Context, in *SubmitProfileRequest, opts ...grpc.CallOption) (*SubmitProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitProfileResponse)
	err := c.cc.Invoke(ctx, ProfilingService_SubmitProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProfilingServiceServer is the server API for ProfilingService service.
// All implementations must embed UnimplementedProfilingServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ProfilingService (var: aze)
type ProfilingServiceServer interface {
	SubmitProfile(context.Context, *SubmitProfileRequest) (*SubmitProfileResponse, error)
	mustEmbedUnimplementedProfilingServiceServer()
}

// UnimplementedProfilingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProfilingServiceServer struct{}

func (UnimplementedProfilingServiceServer) SubmitProfile(context.Context, *SubmitProfileRequest) (*SubmitProfileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitProfile not implemented")
}
func (UnimplementedProfilingServiceServer) mustEmbedUnimplementedProfilingServiceServer() {}
func (UnimplementedProfilingServiceServer) testEmbeddedByValue()                          {}

// UnsafeProfilingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProfilingServiceServer will
// result in compilation errors.
type UnsafeProfilingServiceServer interface {
	mustEmbedUnimplementedProfilingServiceServer()
}

func RegisterProfilingServiceServer(s grpc.ServiceRegistrar, srv ProfilingServiceServer) {
	// If the following call panics, it indicates UnimplementedProfilingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProfilingService_ServiceDesc, srv)
}

func _ProfilingService_SubmitProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilingServiceServer).SubmitProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfilingService_SubmitProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilingServiceServer).SubmitProfile(ctx, req.(*SubmitProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProfilingService_ServiceDesc is the grpc.ServiceDesc for ProfilingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProfilingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ProfilingService",
	HandlerType: (*ProfilingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitProfile",
			Handler:    _ProfilingService_SubmitProfile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ReplayChatService_StreamReplayChat_FullMethodName = "/aiserver.v1.ReplayChatService/StreamReplayChat"
)

// ReplayChatServiceClient is the client API for ReplayChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ReplayChatService (var: GVe)
type ReplayChatServiceClient interface {
	StreamReplayChat(ctx context.Context, in *StreamReplayChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error)
}

type replayChatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplayChatServiceClient(cc grpc.ClientConnInterface) ReplayChatServiceClient {
	return &replayChatServiceClient{cc}
}

func (c *replayChatServiceClient) StreamReplayChat(ctx context.Context, in *StreamReplayChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReplayChatService_ServiceDesc.Streams[0], ReplayChatService_StreamReplayChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamReplayChatRequest, StreamUnifiedChatResponseWithTools]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplayChatService_StreamReplayChatClient = grpc.ServerStreamingClient[StreamUnifiedChatResponseWithTools]

// ReplayChatServiceServer is the server API for ReplayChatService service.
// All implementations must embed UnimplementedReplayChatServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ReplayChatService (var: GVe)
type ReplayChatServiceServer interface {
	StreamReplayChat(*StreamReplayChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error
	mustEmbedUnimplementedReplayChatServiceServer()
}

// UnimplementedReplayChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplayChatServiceServer struct{}

func (UnimplementedReplayChatServiceServer) StreamReplayChat(*StreamReplayChatRequest, grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]) error {
	return status.Error(codes.Unimplemented, "method StreamReplayChat not implemented")
}
func (UnimplementedReplayChatServiceServer) mustEmbedUnimplementedReplayChatServiceServer() {}
func (UnimplementedReplayChatServiceServer) testEmbeddedByValue()                           {}

// UnsafeReplayChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplayChatServiceServer will
// result in compilation errors.
type UnsafeReplayChatServiceServer interface {
	mustEmbedUnimplementedReplayChatServiceServer()
}

func RegisterReplayChatServiceServer(s grpc.ServiceRegistrar, srv ReplayChatServiceServer) {
	// If the following call panics, it indicates UnimplementedReplayChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplayChatService_ServiceDesc, srv)
}

func _ReplayChatService_StreamReplayChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamReplayChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplayChatServiceServer).StreamReplayChat(m, &grpc.GenericServerStream[StreamReplayChatRequest, StreamUnifiedChatResponseWithTools]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplayChatService_StreamReplayChatServer = grpc.ServerStreamingServer[StreamUnifiedChatResponseWithTools]

// ReplayChatService_ServiceDesc is the grpc.ServiceDesc for ReplayChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplayChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ReplayChatService",
	HandlerType: (*ReplayChatServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamReplayChat",
			Handler:       _ReplayChatService_StreamReplayChat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	RepositoryService_FastRepoInitHandshake_FullMethodName          = "/aiserver.v1.RepositoryService/FastRepoInitHandshake"
	RepositoryService_SyncMerkleSubtree_FullMethodName              = "/aiserver.v1.RepositoryService/SyncMerkleSubtree"
	RepositoryService_FastUpdateFile_FullMethodName                 = "/aiserver.v1.RepositoryService/FastUpdateFile"
	RepositoryService_SearchRepositoryV2_FullMethodName             = "/aiserver.v1.RepositoryService/SearchRepositoryV2"
	RepositoryService_RemoveRepositoryV2_FullMethodName             = "/aiserver.v1.RepositoryService/RemoveRepositoryV2"
	RepositoryService_FastRepoInitHandshakeV2_FullMethodName        = "/aiserver.v1.RepositoryService/FastRepoInitHandshakeV2"
	RepositoryService_SyncMerkleSubtreeV2_FullMethodName            = "/aiserver.v1.RepositoryService/SyncMerkleSubtreeV2"
	RepositoryService_FastUpdateFileV2_FullMethodName               = "/aiserver.v1.RepositoryService/FastUpdateFileV2"
	RepositoryService_FastRepoSyncComplete_FullMethodName           = "/aiserver.v1.RepositoryService/FastRepoSyncComplete"
	RepositoryService_SemSearchFast_FullMethodName                  = "/aiserver.v1.RepositoryService/SemSearchFast"
	RepositoryService_SemSearch_FullMethodName                      = "/aiserver.v1.RepositoryService/SemSearch"
	RepositoryService_EnsureIndexCreated_FullMethodName             = "/aiserver.v1.RepositoryService/EnsureIndexCreated"
	RepositoryService_GetHighLevelFolderDescription_FullMethodName  = "/aiserver.v1.RepositoryService/GetHighLevelFolderDescription"
	RepositoryService_GetEmbeddings_FullMethodName                  = "/aiserver.v1.RepositoryService/GetEmbeddings"
	RepositoryService_GetUploadLimits_FullMethodName                = "/aiserver.v1.RepositoryService/GetUploadLimits"
	RepositoryService_GetNumFilesToSend_FullMethodName              = "/aiserver.v1.RepositoryService/GetNumFilesToSend"
	RepositoryService_GetAvailableChunkingStrategies_FullMethodName = "/aiserver.v1.RepositoryService/GetAvailableChunkingStrategies"
	RepositoryService_GetLineNumberClassifications_FullMethodName   = "/aiserver.v1.RepositoryService/GetLineNumberClassifications"
	RepositoryService_GetCopyStatus_FullMethodName                  = "/aiserver.v1.RepositoryService/GetCopyStatus"
)

// RepositoryServiceClient is the client API for RepositoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.RepositoryService (var: oWe)
type RepositoryServiceClient interface {
	FastRepoInitHandshake(ctx context.Context, in *FastRepoInitHandshakeRequest, opts ...grpc.CallOption) (*FastRepoInitHandshakeResponse, error)
	SyncMerkleSubtree(ctx context.Context, in *SyncMerkleSubtreeRequest, opts ...grpc.CallOption) (*SyncMerkleSubtreeResponse, error)
	FastUpdateFile(ctx context.Context, in *FastUpdateFileRequest, opts ...grpc.CallOption) (*FastUpdateFileResponse, error)
	SearchRepositoryV2(ctx context.Context, in *SearchRepositoryRequest, opts ...grpc.CallOption) (*SearchRepositoryResponse, error)
	RemoveRepositoryV2(ctx context.Context, in *RemoveRepositoryRequest, opts ...grpc.CallOption) (*RemoveRepositoryResponse, error)
	FastRepoInitHandshakeV2(ctx context.Context, in *FastRepoInitHandshakeV2Request, opts ...grpc.CallOption) (*FastRepoInitHandshakeV2Response, error)
	SyncMerkleSubtreeV2(ctx context.Context, in *SyncMerkleSubtreeV2Request, opts ...grpc.CallOption) (*SyncMerkleSubtreeV2Response, error)
	FastUpdateFileV2(ctx context.Context, in *FastUpdateFileV2Request, opts ...grpc.CallOption) (*FastUpdateFileV2Response, error)
	FastRepoSyncComplete(ctx context.Context, in *FastRepoSyncCompleteRequest, opts ...grpc.CallOption) (*FastRepoSyncCompleteResponse, error)
	SemSearchFast(ctx context.Context, in *SemSearchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SemSearchResponse], error)
	SemSearch(ctx context.Context, in *SemSearchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SemSearchResponse], error)
	EnsureIndexCreated(ctx context.Context, in *EnsureIndexCreatedRequest, opts ...grpc.CallOption) (*EnsureIndexCreatedResponse, error)
	GetHighLevelFolderDescription(ctx context.Context, in *GetHighLevelFolderDescriptionRequest, opts ...grpc.CallOption) (*GetHighLevelFolderDescriptionResponse, error)
	GetEmbeddings(ctx context.Context, in *GetEmbeddingsRequest, opts ...grpc.CallOption) (*GetEmbeddingsResponse, error)
	GetUploadLimits(ctx context.Context, in *GetUploadLimitsRequest, opts ...grpc.CallOption) (*GetUploadLimitsResponse, error)
	GetNumFilesToSend(ctx context.Context, in *GetNumFilesToSendRequest, opts ...grpc.CallOption) (*GetNumFilesToSendResponse, error)
	GetAvailableChunkingStrategies(ctx context.Context, in *GetAvailableChunkingStrategiesRequest, opts ...grpc.CallOption) (*GetAvailableChunkingStrategiesResponse, error)
	GetLineNumberClassifications(ctx context.Context, in *GetLineNumberClassificationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetLineNumberClassificationsResponse], error)
	GetCopyStatus(ctx context.Context, in *GetCopyStatusRequest, opts ...grpc.CallOption) (*GetCopyStatusResponse, error)
}

type repositoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRepositoryServiceClient(cc grpc.ClientConnInterface) RepositoryServiceClient {
	return &repositoryServiceClient{cc}
}

func (c *repositoryServiceClient) FastRepoInitHandshake(ctx context.Context, in *FastRepoInitHandshakeRequest, opts ...grpc.CallOption) (*FastRepoInitHandshakeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastRepoInitHandshakeResponse)
	err := c.cc.Invoke(ctx, RepositoryService_FastRepoInitHandshake_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) SyncMerkleSubtree(ctx context.Context, in *SyncMerkleSubtreeRequest, opts ...grpc.CallOption) (*SyncMerkleSubtreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncMerkleSubtreeResponse)
	err := c.cc.Invoke(ctx, RepositoryService_SyncMerkleSubtree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) FastUpdateFile(ctx context.Context, in *FastUpdateFileRequest, opts ...grpc.CallOption) (*FastUpdateFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastUpdateFileResponse)
	err := c.cc.Invoke(ctx, RepositoryService_FastUpdateFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) SearchRepositoryV2(ctx context.Context, in *SearchRepositoryRequest, opts ...grpc.CallOption) (*SearchRepositoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchRepositoryResponse)
	err := c.cc.Invoke(ctx, RepositoryService_SearchRepositoryV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) RemoveRepositoryV2(ctx context.Context, in *RemoveRepositoryRequest, opts ...grpc.CallOption) (*RemoveRepositoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveRepositoryResponse)
	err := c.cc.Invoke(ctx, RepositoryService_RemoveRepositoryV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) FastRepoInitHandshakeV2(ctx context.Context, in *FastRepoInitHandshakeV2Request, opts ...grpc.CallOption) (*FastRepoInitHandshakeV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastRepoInitHandshakeV2Response)
	err := c.cc.Invoke(ctx, RepositoryService_FastRepoInitHandshakeV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) SyncMerkleSubtreeV2(ctx context.Context, in *SyncMerkleSubtreeV2Request, opts ...grpc.CallOption) (*SyncMerkleSubtreeV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncMerkleSubtreeV2Response)
	err := c.cc.Invoke(ctx, RepositoryService_SyncMerkleSubtreeV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) FastUpdateFileV2(ctx context.Context, in *FastUpdateFileV2Request, opts ...grpc.CallOption) (*FastUpdateFileV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastUpdateFileV2Response)
	err := c.cc.Invoke(ctx, RepositoryService_FastUpdateFileV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) FastRepoSyncComplete(ctx context.Context, in *FastRepoSyncCompleteRequest, opts ...grpc.CallOption) (*FastRepoSyncCompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FastRepoSyncCompleteResponse)
	err := c.cc.Invoke(ctx, RepositoryService_FastRepoSyncComplete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) SemSearchFast(ctx context.Context, in *SemSearchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SemSearchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RepositoryService_ServiceDesc.Streams[0], RepositoryService_SemSearchFast_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SemSearchRequest, SemSearchResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_SemSearchFastClient = grpc.ServerStreamingClient[SemSearchResponse]

func (c *repositoryServiceClient) SemSearch(ctx context.Context, in *SemSearchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SemSearchResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RepositoryService_ServiceDesc.Streams[1], RepositoryService_SemSearch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SemSearchRequest, SemSearchResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_SemSearchClient = grpc.ServerStreamingClient[SemSearchResponse]

func (c *repositoryServiceClient) EnsureIndexCreated(ctx context.Context, in *EnsureIndexCreatedRequest, opts ...grpc.CallOption) (*EnsureIndexCreatedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureIndexCreatedResponse)
	err := c.cc.Invoke(ctx, RepositoryService_EnsureIndexCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetHighLevelFolderDescription(ctx context.Context, in *GetHighLevelFolderDescriptionRequest, opts ...grpc.CallOption) (*GetHighLevelFolderDescriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHighLevelFolderDescriptionResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetHighLevelFolderDescription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetEmbeddings(ctx context.Context, in *GetEmbeddingsRequest, opts ...grpc.CallOption) (*GetEmbeddingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEmbeddingsResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetEmbeddings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetUploadLimits(ctx context.Context, in *GetUploadLimitsRequest, opts ...grpc.CallOption) (*GetUploadLimitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUploadLimitsResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetUploadLimits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetNumFilesToSend(ctx context.Context, in *GetNumFilesToSendRequest, opts ...grpc.CallOption) (*GetNumFilesToSendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNumFilesToSendResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetNumFilesToSend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetAvailableChunkingStrategies(ctx context.Context, in *GetAvailableChunkingStrategiesRequest, opts ...grpc.CallOption) (*GetAvailableChunkingStrategiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAvailableChunkingStrategiesResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetAvailableChunkingStrategies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryServiceClient) GetLineNumberClassifications(ctx context.Context, in *GetLineNumberClassificationsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GetLineNumberClassificationsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RepositoryService_ServiceDesc.Streams[2], RepositoryService_GetLineNumberClassifications_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetLineNumberClassificationsRequest, GetLineNumberClassificationsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_GetLineNumberClassificationsClient = grpc.ServerStreamingClient[GetLineNumberClassificationsResponse]

func (c *repositoryServiceClient) GetCopyStatus(ctx context.Context, in *GetCopyStatusRequest, opts ...grpc.CallOption) (*GetCopyStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCopyStatusResponse)
	err := c.cc.Invoke(ctx, RepositoryService_GetCopyStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RepositoryServiceServer is the server API for RepositoryService service.
// All implementations must embed UnimplementedRepositoryServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.RepositoryService (var: oWe)
type RepositoryServiceServer interface {
	FastRepoInitHandshake(context.Context, *FastRepoInitHandshakeRequest) (*FastRepoInitHandshakeResponse, error)
	SyncMerkleSubtree(context.Context, *SyncMerkleSubtreeRequest) (*SyncMerkleSubtreeResponse, error)
	FastUpdateFile(context.Context, *FastUpdateFileRequest) (*FastUpdateFileResponse, error)
	SearchRepositoryV2(context.Context, *SearchRepositoryRequest) (*SearchRepositoryResponse, error)
	RemoveRepositoryV2(context.Context, *RemoveRepositoryRequest) (*RemoveRepositoryResponse, error)
	FastRepoInitHandshakeV2(context.Context, *FastRepoInitHandshakeV2Request) (*FastRepoInitHandshakeV2Response, error)
	SyncMerkleSubtreeV2(context.Context, *SyncMerkleSubtreeV2Request) (*SyncMerkleSubtreeV2Response, error)
	FastUpdateFileV2(context.Context, *FastUpdateFileV2Request) (*FastUpdateFileV2Response, error)
	FastRepoSyncComplete(context.Context, *FastRepoSyncCompleteRequest) (*FastRepoSyncCompleteResponse, error)
	SemSearchFast(*SemSearchRequest, grpc.ServerStreamingServer[SemSearchResponse]) error
	SemSearch(*SemSearchRequest, grpc.ServerStreamingServer[SemSearchResponse]) error
	EnsureIndexCreated(context.Context, *EnsureIndexCreatedRequest) (*EnsureIndexCreatedResponse, error)
	GetHighLevelFolderDescription(context.Context, *GetHighLevelFolderDescriptionRequest) (*GetHighLevelFolderDescriptionResponse, error)
	GetEmbeddings(context.Context, *GetEmbeddingsRequest) (*GetEmbeddingsResponse, error)
	GetUploadLimits(context.Context, *GetUploadLimitsRequest) (*GetUploadLimitsResponse, error)
	GetNumFilesToSend(context.Context, *GetNumFilesToSendRequest) (*GetNumFilesToSendResponse, error)
	GetAvailableChunkingStrategies(context.Context, *GetAvailableChunkingStrategiesRequest) (*GetAvailableChunkingStrategiesResponse, error)
	GetLineNumberClassifications(*GetLineNumberClassificationsRequest, grpc.ServerStreamingServer[GetLineNumberClassificationsResponse]) error
	GetCopyStatus(context.Context, *GetCopyStatusRequest) (*GetCopyStatusResponse, error)
	mustEmbedUnimplementedRepositoryServiceServer()
}

// UnimplementedRepositoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRepositoryServiceServer struct{}

func (UnimplementedRepositoryServiceServer) FastRepoInitHandshake(context.Context, *FastRepoInitHandshakeRequest) (*FastRepoInitHandshakeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FastRepoInitHandshake not implemented")
}
func (UnimplementedRepositoryServiceServer) SyncMerkleSubtree(context.Context, *SyncMerkleSubtreeRequest) (*SyncMerkleSubtreeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMerkleSubtree not implemented")
}
func (UnimplementedRepositoryServiceServer) FastUpdateFile(context.Context, *FastUpdateFileRequest) (*FastUpdateFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FastUpdateFile not implemented")
}
func (UnimplementedRepositoryServiceServer) SearchRepositoryV2(context.Context, *SearchRepositoryRequest) (*SearchRepositoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchRepositoryV2 not implemented")
}
func (UnimplementedRepositoryServiceServer) RemoveRepositoryV2(context.Context, *RemoveRepositoryRequest) (*RemoveRepositoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRepositoryV2 not implemented")
}
func (UnimplementedRepositoryServiceServer) FastRepoInitHandshakeV2(context.Context, *FastRepoInitHandshakeV2Request) (*FastRepoInitHandshakeV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method FastRepoInitHandshakeV2 not implemented")
}
func (UnimplementedRepositoryServiceServer) SyncMerkleSubtreeV2(context.Context, *SyncMerkleSubtreeV2Request) (*SyncMerkleSubtreeV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMerkleSubtreeV2 not implemented")
}
func (UnimplementedRepositoryServiceServer) FastUpdateFileV2(context.Context, *FastUpdateFileV2Request) (*FastUpdateFileV2Response, error) {
	return nil, status.Error(codes.Unimplemented, "method FastUpdateFileV2 not implemented")
}
func (UnimplementedRepositoryServiceServer) FastRepoSyncComplete(context.Context, *FastRepoSyncCompleteRequest) (*FastRepoSyncCompleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FastRepoSyncComplete not implemented")
}
func (UnimplementedRepositoryServiceServer) SemSearchFast(*SemSearchRequest, grpc.ServerStreamingServer[SemSearchResponse]) error {
	return status.Error(codes.Unimplemented, "method SemSearchFast not implemented")
}
func (UnimplementedRepositoryServiceServer) SemSearch(*SemSearchRequest, grpc.ServerStreamingServer[SemSearchResponse]) error {
	return status.Error(codes.Unimplemented, "method SemSearch not implemented")
}
func (UnimplementedRepositoryServiceServer) EnsureIndexCreated(context.Context, *EnsureIndexCreatedRequest) (*EnsureIndexCreatedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnsureIndexCreated not implemented")
}
func (UnimplementedRepositoryServiceServer) GetHighLevelFolderDescription(context.Context, *GetHighLevelFolderDescriptionRequest) (*GetHighLevelFolderDescriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHighLevelFolderDescription not implemented")
}
func (UnimplementedRepositoryServiceServer) GetEmbeddings(context.Context, *GetEmbeddingsRequest) (*GetEmbeddingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEmbeddings not implemented")
}
func (UnimplementedRepositoryServiceServer) GetUploadLimits(context.Context, *GetUploadLimitsRequest) (*GetUploadLimitsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUploadLimits not implemented")
}
func (UnimplementedRepositoryServiceServer) GetNumFilesToSend(context.Context, *GetNumFilesToSendRequest) (*GetNumFilesToSendResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNumFilesToSend not implemented")
}
func (UnimplementedRepositoryServiceServer) GetAvailableChunkingStrategies(context.Context, *GetAvailableChunkingStrategiesRequest) (*GetAvailableChunkingStrategiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailableChunkingStrategies not implemented")
}
func (UnimplementedRepositoryServiceServer) GetLineNumberClassifications(*GetLineNumberClassificationsRequest, grpc.ServerStreamingServer[GetLineNumberClassificationsResponse]) error {
	return status.Error(codes.Unimplemented, "method GetLineNumberClassifications not implemented")
}
func (UnimplementedRepositoryServiceServer) GetCopyStatus(context.Context, *GetCopyStatusRequest) (*GetCopyStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCopyStatus not implemented")
}
func (UnimplementedRepositoryServiceServer) mustEmbedUnimplementedRepositoryServiceServer() {}
func (UnimplementedRepositoryServiceServer) testEmbeddedByValue()                           {}

// UnsafeRepositoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RepositoryServiceServer will
// result in compilation errors.
type UnsafeRepositoryServiceServer interface {
	mustEmbedUnimplementedRepositoryServiceServer()
}

func RegisterRepositoryServiceServer(s grpc.ServiceRegistrar, srv RepositoryServiceServer) {
	// If the following call panics, it indicates UnimplementedRepositoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RepositoryService_ServiceDesc, srv)
}

func _RepositoryService_FastRepoInitHandshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastRepoInitHandshakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).FastRepoInitHandshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_FastRepoInitHandshake_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).FastRepoInitHandshake(ctx, req.(*FastRepoInitHandshakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_SyncMerkleSubtree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMerkleSubtreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).SyncMerkleSubtree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_SyncMerkleSubtree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).SyncMerkleSubtree(ctx, req.(*SyncMerkleSubtreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_FastUpdateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastUpdateFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).FastUpdateFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_FastUpdateFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).FastUpdateFile(ctx, req.(*FastUpdateFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_SearchRepositoryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).SearchRepositoryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_SearchRepositoryV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).SearchRepositoryV2(ctx, req.(*SearchRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_RemoveRepositoryV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).RemoveRepositoryV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_RemoveRepositoryV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).RemoveRepositoryV2(ctx, req.(*RemoveRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_FastRepoInitHandshakeV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastRepoInitHandshakeV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).FastRepoInitHandshakeV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_FastRepoInitHandshakeV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).FastRepoInitHandshakeV2(ctx, req.(*FastRepoInitHandshakeV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_SyncMerkleSubtreeV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMerkleSubtreeV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).SyncMerkleSubtreeV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_SyncMerkleSubtreeV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).SyncMerkleSubtreeV2(ctx, req.(*SyncMerkleSubtreeV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_FastUpdateFileV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastUpdateFileV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).FastUpdateFileV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_FastUpdateFileV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).FastUpdateFileV2(ctx, req.(*FastUpdateFileV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_FastRepoSyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FastRepoSyncCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).FastRepoSyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_FastRepoSyncComplete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).FastRepoSyncComplete(ctx, req.(*FastRepoSyncCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_SemSearchFast_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SemSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RepositoryServiceServer).SemSearchFast(m, &grpc.GenericServerStream[SemSearchRequest, SemSearchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_SemSearchFastServer = grpc.ServerStreamingServer[SemSearchResponse]

func _RepositoryService_SemSearch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SemSearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RepositoryServiceServer).SemSearch(m, &grpc.GenericServerStream[SemSearchRequest, SemSearchResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_SemSearchServer = grpc.ServerStreamingServer[SemSearchResponse]

func _RepositoryService_EnsureIndexCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureIndexCreatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).EnsureIndexCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_EnsureIndexCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).EnsureIndexCreated(ctx, req.(*EnsureIndexCreatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetHighLevelFolderDescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHighLevelFolderDescriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetHighLevelFolderDescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetHighLevelFolderDescription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetHighLevelFolderDescription(ctx, req.(*GetHighLevelFolderDescriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetEmbeddings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmbeddingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetEmbeddings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetEmbeddings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetEmbeddings(ctx, req.(*GetEmbeddingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetUploadLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUploadLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetUploadLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetUploadLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetUploadLimits(ctx, req.(*GetUploadLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetNumFilesToSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNumFilesToSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetNumFilesToSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetNumFilesToSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetNumFilesToSend(ctx, req.(*GetNumFilesToSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetAvailableChunkingStrategies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableChunkingStrategiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetAvailableChunkingStrategies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetAvailableChunkingStrategies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetAvailableChunkingStrategies(ctx, req.(*GetAvailableChunkingStrategiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RepositoryService_GetLineNumberClassifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLineNumberClassificationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RepositoryServiceServer).GetLineNumberClassifications(m, &grpc.GenericServerStream[GetLineNumberClassificationsRequest, GetLineNumberClassificationsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RepositoryService_GetLineNumberClassificationsServer = grpc.ServerStreamingServer[GetLineNumberClassificationsResponse]

func _RepositoryService_GetCopyStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCopyStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServiceServer).GetCopyStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RepositoryService_GetCopyStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServiceServer).GetCopyStatus(ctx, req.(*GetCopyStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RepositoryService_ServiceDesc is the grpc.ServiceDesc for RepositoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RepositoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.RepositoryService",
	HandlerType: (*RepositoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FastRepoInitHandshake",
			Handler:    _RepositoryService_FastRepoInitHandshake_Handler,
		},
		{
			MethodName: "SyncMerkleSubtree",
			Handler:    _RepositoryService_SyncMerkleSubtree_Handler,
		},
		{
			MethodName: "FastUpdateFile",
			Handler:    _RepositoryService_FastUpdateFile_Handler,
		},
		{
			MethodName: "SearchRepositoryV2",
			Handler:    _RepositoryService_SearchRepositoryV2_Handler,
		},
		{
			MethodName: "RemoveRepositoryV2",
			Handler:    _RepositoryService_RemoveRepositoryV2_Handler,
		},
		{
			MethodName: "FastRepoInitHandshakeV2",
			Handler:    _RepositoryService_FastRepoInitHandshakeV2_Handler,
		},
		{
			MethodName: "SyncMerkleSubtreeV2",
			Handler:    _RepositoryService_SyncMerkleSubtreeV2_Handler,
		},
		{
			MethodName: "FastUpdateFileV2",
			Handler:    _RepositoryService_FastUpdateFileV2_Handler,
		},
		{
			MethodName: "FastRepoSyncComplete",
			Handler:    _RepositoryService_FastRepoSyncComplete_Handler,
		},
		{
			MethodName: "EnsureIndexCreated",
			Handler:    _RepositoryService_EnsureIndexCreated_Handler,
		},
		{
			MethodName: "GetHighLevelFolderDescription",
			Handler:    _RepositoryService_GetHighLevelFolderDescription_Handler,
		},
		{
			MethodName: "GetEmbeddings",
			Handler:    _RepositoryService_GetEmbeddings_Handler,
		},
		{
			MethodName: "GetUploadLimits",
			Handler:    _RepositoryService_GetUploadLimits_Handler,
		},
		{
			MethodName: "GetNumFilesToSend",
			Handler:    _RepositoryService_GetNumFilesToSend_Handler,
		},
		{
			MethodName: "GetAvailableChunkingStrategies",
			Handler:    _RepositoryService_GetAvailableChunkingStrategies_Handler,
		},
		{
			MethodName: "GetCopyStatus",
			Handler:    _RepositoryService_GetCopyStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SemSearchFast",
			Handler:       _RepositoryService_SemSearchFast_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SemSearch",
			Handler:       _RepositoryService_SemSearch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLineNumberClassifications",
			Handler:       _RepositoryService_GetLineNumberClassifications_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	RequestReplayService_Health_FullMethodName        = "/aiserver.v1.RequestReplayService/Health"
	RequestReplayService_RecordRequest_FullMethodName = "/aiserver.v1.RequestReplayService/RecordRequest"
	RequestReplayService_ReplayRequest_FullMethodName = "/aiserver.v1.RequestReplayService/ReplayRequest"
)

// RequestReplayServiceClient is the client API for RequestReplayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.RequestReplayService (var: UYe)
type RequestReplayServiceClient interface {
	Health(ctx context.Context, in *RequestReplayHealthRequest, opts ...grpc.CallOption) (*RequestReplayHealthResponse, error)
	RecordRequest(ctx context.Context, in *RecordRequestRequest, opts ...grpc.CallOption) (*RecordRequestResponse, error)
	ReplayRequest(ctx context.Context, in *ReplayRequestRequest, opts ...grpc.CallOption) (*ReplayRequestResponse, error)
}

type requestReplayServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRequestReplayServiceClient(cc grpc.ClientConnInterface) RequestReplayServiceClient {
	return &requestReplayServiceClient{cc}
}

func (c *requestReplayServiceClient) Health(ctx context.Context, in *RequestReplayHealthRequest, opts ...grpc.CallOption) (*RequestReplayHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestReplayHealthResponse)
	err := c.cc.Invoke(ctx, RequestReplayService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *requestReplayServiceClient) RecordRequest(ctx context.Context, in *RecordRequestRequest, opts ...grpc.CallOption) (*RecordRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordRequestResponse)
	err := c.cc.Invoke(ctx, RequestReplayService_RecordRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *requestReplayServiceClient) ReplayRequest(ctx context.Context, in *ReplayRequestRequest, opts ...grpc.CallOption) (*ReplayRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplayRequestResponse)
	err := c.cc.Invoke(ctx, RequestReplayService_ReplayRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RequestReplayServiceServer is the server API for RequestReplayService service.
// All implementations must embed UnimplementedRequestReplayServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.RequestReplayService (var: UYe)
type RequestReplayServiceServer interface {
	Health(context.Context, *RequestReplayHealthRequest) (*RequestReplayHealthResponse, error)
	RecordRequest(context.Context, *RecordRequestRequest) (*RecordRequestResponse, error)
	ReplayRequest(context.Context, *ReplayRequestRequest) (*ReplayRequestResponse, error)
	mustEmbedUnimplementedRequestReplayServiceServer()
}

// UnimplementedRequestReplayServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRequestReplayServiceServer struct{}

func (UnimplementedRequestReplayServiceServer) Health(context.Context, *RequestReplayHealthRequest) (*RequestReplayHealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedRequestReplayServiceServer) RecordRequest(context.Context, *RecordRequestRequest) (*RecordRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordRequest not implemented")
}
func (UnimplementedRequestReplayServiceServer) ReplayRequest(context.Context, *ReplayRequestRequest) (*ReplayRequestResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplayRequest not implemented")
}
func (UnimplementedRequestReplayServiceServer) mustEmbedUnimplementedRequestReplayServiceServer() {}
func (UnimplementedRequestReplayServiceServer) testEmbeddedByValue()                              {}

// UnsafeRequestReplayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RequestReplayServiceServer will
// result in compilation errors.
type UnsafeRequestReplayServiceServer interface {
	mustEmbedUnimplementedRequestReplayServiceServer()
}

func RegisterRequestReplayServiceServer(s grpc.ServiceRegistrar, srv RequestReplayServiceServer) {
	// If the following call panics, it indicates UnimplementedRequestReplayServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RequestReplayService_ServiceDesc, srv)
}

func _RequestReplayService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReplayHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RequestReplayServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RequestReplayService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RequestReplayServiceServer).Health(ctx, req.(*RequestReplayHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RequestReplayService_RecordRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RequestReplayServiceServer).RecordRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RequestReplayService_RecordRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RequestReplayServiceServer).RecordRequest(ctx, req.(*RecordRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RequestReplayService_ReplayRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RequestReplayServiceServer).ReplayRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RequestReplayService_ReplayRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RequestReplayServiceServer).ReplayRequest(ctx, req.(*ReplayRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RequestReplayService_ServiceDesc is the grpc.ServiceDesc for RequestReplayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RequestReplayService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.RequestReplayService",
	HandlerType: (*RequestReplayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Health",
			Handler:    _RequestReplayService_Health_Handler,
		},
		{
			MethodName: "RecordRequest",
			Handler:    _RequestReplayService_RecordRequest_Handler,
		},
		{
			MethodName: "ReplayRequest",
			Handler:    _RequestReplayService_ReplayRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ReviewService_StreamReview_FullMethodName       = "/aiserver.v1.ReviewService/StreamReview"
	ReviewService_StreamReviewChat_FullMethodName   = "/aiserver.v1.ReviewService/StreamReviewChat"
	ReviewService_StreamSlowReview_FullMethodName   = "/aiserver.v1.ReviewService/StreamSlowReview"
	ReviewService_BugConfig_FullMethodName          = "/aiserver.v1.ReviewService/BugConfig"
	ReviewService_StreamBugBotLinter_FullMethodName = "/aiserver.v1.ReviewService/StreamBugBotLinter"
	ReviewService_StreamBugFinding_FullMethodName   = "/aiserver.v1.ReviewService/StreamBugFinding"
)

// ReviewServiceClient is the client API for ReviewService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ReviewService (var: WYe)
type ReviewServiceClient interface {
	StreamReview(ctx context.Context, in *ReviewRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponseV2], error)
	StreamReviewChat(ctx context.Context, in *ReviewChatRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewChatResponseV2], error)
	StreamSlowReview(ctx context.Context, in *ReviewRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponseV2], error)
	BugConfig(ctx context.Context, in *BugConfigRequest, opts ...grpc.CallOption) (*BugConfigResponse, error)
	StreamBugBotLinter(ctx context.Context, in *StreamBugBotLinterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotLinterResponse], error)
	StreamBugFinding(ctx context.Context, in *StreamBugFindingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugFindingResponse], error)
}

type reviewServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReviewServiceClient(cc grpc.ClientConnInterface) ReviewServiceClient {
	return &reviewServiceClient{cc}
}

func (c *reviewServiceClient) StreamReview(ctx context.Context, in *ReviewRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponseV2], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReviewService_ServiceDesc.Streams[0], ReviewService_StreamReview_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReviewRequestV2, ReviewResponseV2]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamReviewClient = grpc.ServerStreamingClient[ReviewResponseV2]

func (c *reviewServiceClient) StreamReviewChat(ctx context.Context, in *ReviewChatRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewChatResponseV2], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReviewService_ServiceDesc.Streams[1], ReviewService_StreamReviewChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReviewChatRequestV2, ReviewChatResponseV2]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamReviewChatClient = grpc.ServerStreamingClient[ReviewChatResponseV2]

func (c *reviewServiceClient) StreamSlowReview(ctx context.Context, in *ReviewRequestV2, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReviewResponseV2], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReviewService_ServiceDesc.Streams[2], ReviewService_StreamSlowReview_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReviewRequestV2, ReviewResponseV2]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamSlowReviewClient = grpc.ServerStreamingClient[ReviewResponseV2]

func (c *reviewServiceClient) BugConfig(ctx context.Context, in *BugConfigRequest, opts ...grpc.CallOption) (*BugConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BugConfigResponse)
	err := c.cc.Invoke(ctx, ReviewService_BugConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) StreamBugBotLinter(ctx context.Context, in *StreamBugBotLinterRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugBotLinterResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReviewService_ServiceDesc.Streams[3], ReviewService_StreamBugBotLinter_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamBugBotLinterRequest, StreamBugBotLinterResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamBugBotLinterClient = grpc.ServerStreamingClient[StreamBugBotLinterResponse]

func (c *reviewServiceClient) StreamBugFinding(ctx context.Context, in *StreamBugFindingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamBugFindingResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReviewService_ServiceDesc.Streams[4], ReviewService_StreamBugFinding_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamBugFindingRequest, StreamBugFindingResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamBugFindingClient = grpc.ServerStreamingClient[StreamBugFindingResponse]

// ReviewServiceServer is the server API for ReviewService service.
// All implementations must embed UnimplementedReviewServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ReviewService (var: WYe)
type ReviewServiceServer interface {
	StreamReview(*ReviewRequestV2, grpc.ServerStreamingServer[ReviewResponseV2]) error
	StreamReviewChat(*ReviewChatRequestV2, grpc.ServerStreamingServer[ReviewChatResponseV2]) error
	StreamSlowReview(*ReviewRequestV2, grpc.ServerStreamingServer[ReviewResponseV2]) error
	BugConfig(context.Context, *BugConfigRequest) (*BugConfigResponse, error)
	StreamBugBotLinter(*StreamBugBotLinterRequest, grpc.ServerStreamingServer[StreamBugBotLinterResponse]) error
	StreamBugFinding(*StreamBugFindingRequest, grpc.ServerStreamingServer[StreamBugFindingResponse]) error
	mustEmbedUnimplementedReviewServiceServer()
}

// UnimplementedReviewServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReviewServiceServer struct{}

func (UnimplementedReviewServiceServer) StreamReview(*ReviewRequestV2, grpc.ServerStreamingServer[ReviewResponseV2]) error {
	return status.Error(codes.Unimplemented, "method StreamReview not implemented")
}
func (UnimplementedReviewServiceServer) StreamReviewChat(*ReviewChatRequestV2, grpc.ServerStreamingServer[ReviewChatResponseV2]) error {
	return status.Error(codes.Unimplemented, "method StreamReviewChat not implemented")
}
func (UnimplementedReviewServiceServer) StreamSlowReview(*ReviewRequestV2, grpc.ServerStreamingServer[ReviewResponseV2]) error {
	return status.Error(codes.Unimplemented, "method StreamSlowReview not implemented")
}
func (UnimplementedReviewServiceServer) BugConfig(context.Context, *BugConfigRequest) (*BugConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BugConfig not implemented")
}
func (UnimplementedReviewServiceServer) StreamBugBotLinter(*StreamBugBotLinterRequest, grpc.ServerStreamingServer[StreamBugBotLinterResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBugBotLinter not implemented")
}
func (UnimplementedReviewServiceServer) StreamBugFinding(*StreamBugFindingRequest, grpc.ServerStreamingServer[StreamBugFindingResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamBugFinding not implemented")
}
func (UnimplementedReviewServiceServer) mustEmbedUnimplementedReviewServiceServer() {}
func (UnimplementedReviewServiceServer) testEmbeddedByValue()                       {}

// UnsafeReviewServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReviewServiceServer will
// result in compilation errors.
type UnsafeReviewServiceServer interface {
	mustEmbedUnimplementedReviewServiceServer()
}

func RegisterReviewServiceServer(s grpc.ServiceRegistrar, srv ReviewServiceServer) {
	// If the following call panics, it indicates UnimplementedReviewServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReviewService_ServiceDesc, srv)
}

func _ReviewService_StreamReview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReviewRequestV2)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReviewServiceServer).StreamReview(m, &grpc.GenericServerStream[ReviewRequestV2, ReviewResponseV2]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamReviewServer = grpc.ServerStreamingServer[ReviewResponseV2]

func _ReviewService_StreamReviewChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReviewChatRequestV2)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReviewServiceServer).StreamReviewChat(m, &grpc.GenericServerStream[ReviewChatRequestV2, ReviewChatResponseV2]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamReviewChatServer = grpc.ServerStreamingServer[ReviewChatResponseV2]

func _ReviewService_StreamSlowReview_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReviewRequestV2)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReviewServiceServer).StreamSlowReview(m, &grpc.GenericServerStream[ReviewRequestV2, ReviewResponseV2]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamSlowReviewServer = grpc.ServerStreamingServer[ReviewResponseV2]

func _ReviewService_BugConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BugConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).BugConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_BugConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).BugConfig(ctx, req.(*BugConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_StreamBugBotLinter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamBugBotLinterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReviewServiceServer).StreamBugBotLinter(m, &grpc.GenericServerStream[StreamBugBotLinterRequest, StreamBugBotLinterResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamBugBotLinterServer = grpc.ServerStreamingServer[StreamBugBotLinterResponse]

func _ReviewService_StreamBugFinding_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamBugFindingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReviewServiceServer).StreamBugFinding(m, &grpc.GenericServerStream[StreamBugFindingRequest, StreamBugFindingResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReviewService_StreamBugFindingServer = grpc.ServerStreamingServer[StreamBugFindingResponse]

// ReviewService_ServiceDesc is the grpc.ServiceDesc for ReviewService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReviewService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ReviewService",
	HandlerType: (*ReviewServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BugConfig",
			Handler:    _ReviewService_BugConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamReview",
			Handler:       _ReviewService_StreamReview_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamReviewChat",
			Handler:       _ReviewService_StreamReviewChat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSlowReview",
			Handler:       _ReviewService_StreamSlowReview_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBugBotLinter",
			Handler:       _ReviewService_StreamBugBotLinter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBugFinding",
			Handler:       _ReviewService_StreamBugFinding_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "aiserver_v1.proto",
}

const (
	ServerConfigService_GetServerConfig_FullMethodName = "/aiserver.v1.ServerConfigService/GetServerConfig"
)

// ServerConfigServiceClient is the client API for ServerConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ServerConfigService (var: VYe)
type ServerConfigServiceClient interface {
	GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*GetServerConfigResponse, error)
}

type serverConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServerConfigServiceClient(cc grpc.ClientConnInterface) ServerConfigServiceClient {
	return &serverConfigServiceClient{cc}
}

func (c *serverConfigServiceClient) GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*GetServerConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetServerConfigResponse)
	err := c.cc.Invoke(ctx, ServerConfigService_GetServerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServerConfigServiceServer is the server API for ServerConfigService service.
// All implementations must embed UnimplementedServerConfigServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ServerConfigService (var: VYe)
type ServerConfigServiceServer interface {
	GetServerConfig(context.Context, *GetServerConfigRequest) (*GetServerConfigResponse, error)
	mustEmbedUnimplementedServerConfigServiceServer()
}

// UnimplementedServerConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedServerConfigServiceServer struct{}

func (UnimplementedServerConfigServiceServer) GetServerConfig(context.Context, *GetServerConfigRequest) (*GetServerConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServerConfig not implemented")
}
func (UnimplementedServerConfigServiceServer) mustEmbedUnimplementedServerConfigServiceServer() {}
func (UnimplementedServerConfigServiceServer) testEmbeddedByValue()                             {}

// UnsafeServerConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServerConfigServiceServer will
// result in compilation errors.
type UnsafeServerConfigServiceServer interface {
	mustEmbedUnimplementedServerConfigServiceServer()
}

func RegisterServerConfigServiceServer(s grpc.ServiceRegistrar, srv ServerConfigServiceServer) {
	// If the following call panics, it indicates UnimplementedServerConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ServerConfigService_ServiceDesc, srv)
}

func _ServerConfigService_GetServerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerConfigServiceServer).GetServerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServerConfigService_GetServerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerConfigServiceServer).GetServerConfig(ctx, req.(*GetServerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServerConfigService_ServiceDesc is the grpc.ServiceDesc for ServerConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServerConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ServerConfigService",
	HandlerType: (*ServerConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerConfig",
			Handler:    _ServerConfigService_GetServerConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ShadowWorkspaceService_GetLintsForChange_FullMethodName                   = "/aiserver.v1.ShadowWorkspaceService/GetLintsForChange"
	ShadowWorkspaceService_ShadowHealthCheck_FullMethodName                   = "/aiserver.v1.ShadowWorkspaceService/ShadowHealthCheck"
	ShadowWorkspaceService_SwSyncIndex_FullMethodName                         = "/aiserver.v1.ShadowWorkspaceService/SwSyncIndex"
	ShadowWorkspaceService_SwProvideTemporaryAccessToken_FullMethodName       = "/aiserver.v1.ShadowWorkspaceService/SwProvideTemporaryAccessToken"
	ShadowWorkspaceService_SwCompileRepoIncludeExcludePatterns_FullMethodName = "/aiserver.v1.ShadowWorkspaceService/SwCompileRepoIncludeExcludePatterns"
	ShadowWorkspaceService_SwCallClientSideV2Tool_FullMethodName              = "/aiserver.v1.ShadowWorkspaceService/SwCallClientSideV2Tool"
	ShadowWorkspaceService_SwGetExplicitContext_FullMethodName                = "/aiserver.v1.ShadowWorkspaceService/SwGetExplicitContext"
	ShadowWorkspaceService_SwWriteTextFileWithLints_FullMethodName            = "/aiserver.v1.ShadowWorkspaceService/SwWriteTextFileWithLints"
	ShadowWorkspaceService_SwGetEnvironmentInfo_FullMethodName                = "/aiserver.v1.ShadowWorkspaceService/SwGetEnvironmentInfo"
	ShadowWorkspaceService_SwGetLinterErrors_FullMethodName                   = "/aiserver.v1.ShadowWorkspaceService/SwGetLinterErrors"
	ShadowWorkspaceService_SwGetMcpTools_FullMethodName                       = "/aiserver.v1.ShadowWorkspaceService/SwGetMcpTools"
	ShadowWorkspaceService_SwTrackModel_FullMethodName                        = "/aiserver.v1.ShadowWorkspaceService/SwTrackModel"
	ShadowWorkspaceService_SwCallDiagnosticsExecutor_FullMethodName           = "/aiserver.v1.ShadowWorkspaceService/SwCallDiagnosticsExecutor"
)

// ShadowWorkspaceServiceClient is the client API for ShadowWorkspaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ShadowWorkspaceService (var: Xg)
type ShadowWorkspaceServiceClient interface {
	GetLintsForChange(ctx context.Context, in *GetLintsForChangeRequest, opts ...grpc.CallOption) (*GetLintsForChangeResponse, error)
	ShadowHealthCheck(ctx context.Context, in *ShadowHealthCheckRequest, opts ...grpc.CallOption) (*ShadowHealthCheckResponse, error)
	SwSyncIndex(ctx context.Context, in *SwSyncIndexRequest, opts ...grpc.CallOption) (*SwSyncIndexResponse, error)
	SwProvideTemporaryAccessToken(ctx context.Context, in *SwProvideTemporaryAccessTokenRequest, opts ...grpc.CallOption) (*SwProvideTemporaryAccessTokenResponse, error)
	SwCompileRepoIncludeExcludePatterns(ctx context.Context, in *SwCompileRepoIncludeExcludePatternsRequest, opts ...grpc.CallOption) (*SwCompileRepoIncludeExcludePatternsResponse, error)
	SwCallClientSideV2Tool(ctx context.Context, in *SwCallClientSideV2ToolRequest, opts ...grpc.CallOption) (*SwCallClientSideV2ToolResponse, error)
	SwGetExplicitContext(ctx context.Context, in *SwGetExplicitContextRequest, opts ...grpc.CallOption) (*SwGetExplicitContextResponse, error)
	SwWriteTextFileWithLints(ctx context.Context, in *SwWriteTextFileWithLintsRequest, opts ...grpc.CallOption) (*SwWriteTextFileWithLintsResponse, error)
	SwGetEnvironmentInfo(ctx context.Context, in *SwGetEnvironmentInfoRequest, opts ...grpc.CallOption) (*SwGetEnvironmentInfoResponse, error)
	SwGetLinterErrors(ctx context.Context, in *SwGetLinterErrorsRequest, opts ...grpc.CallOption) (*SwGetLinterErrorsResponse, error)
	SwGetMcpTools(ctx context.Context, in *SwGetMcpToolsRequest, opts ...grpc.CallOption) (*SwGetMcpToolsResponse, error)
	SwTrackModel(ctx context.Context, in *SwTrackModelRequest, opts ...grpc.CallOption) (*SwTrackModelResponse, error)
	SwCallDiagnosticsExecutor(ctx context.Context, in *SwCallDiagnosticsExecutorRequest, opts ...grpc.CallOption) (*SwCallDiagnosticsExecutorResponse, error)
}

type shadowWorkspaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShadowWorkspaceServiceClient(cc grpc.ClientConnInterface) ShadowWorkspaceServiceClient {
	return &shadowWorkspaceServiceClient{cc}
}

func (c *shadowWorkspaceServiceClient) GetLintsForChange(ctx context.Context, in *GetLintsForChangeRequest, opts ...grpc.CallOption) (*GetLintsForChangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLintsForChangeResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_GetLintsForChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) ShadowHealthCheck(ctx context.Context, in *ShadowHealthCheckRequest, opts ...grpc.CallOption) (*ShadowHealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShadowHealthCheckResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_ShadowHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwSyncIndex(ctx context.Context, in *SwSyncIndexRequest, opts ...grpc.CallOption) (*SwSyncIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwSyncIndexResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwSyncIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwProvideTemporaryAccessToken(ctx context.Context, in *SwProvideTemporaryAccessTokenRequest, opts ...grpc.CallOption) (*SwProvideTemporaryAccessTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwProvideTemporaryAccessTokenResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwProvideTemporaryAccessToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwCompileRepoIncludeExcludePatterns(ctx context.Context, in *SwCompileRepoIncludeExcludePatternsRequest, opts ...grpc.CallOption) (*SwCompileRepoIncludeExcludePatternsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwCompileRepoIncludeExcludePatternsResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwCompileRepoIncludeExcludePatterns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwCallClientSideV2Tool(ctx context.Context, in *SwCallClientSideV2ToolRequest, opts ...grpc.CallOption) (*SwCallClientSideV2ToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwCallClientSideV2ToolResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwCallClientSideV2Tool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwGetExplicitContext(ctx context.Context, in *SwGetExplicitContextRequest, opts ...grpc.CallOption) (*SwGetExplicitContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwGetExplicitContextResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwGetExplicitContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwWriteTextFileWithLints(ctx context.Context, in *SwWriteTextFileWithLintsRequest, opts ...grpc.CallOption) (*SwWriteTextFileWithLintsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwWriteTextFileWithLintsResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwWriteTextFileWithLints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwGetEnvironmentInfo(ctx context.Context, in *SwGetEnvironmentInfoRequest, opts ...grpc.CallOption) (*SwGetEnvironmentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwGetEnvironmentInfoResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwGetEnvironmentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwGetLinterErrors(ctx context.Context, in *SwGetLinterErrorsRequest, opts ...grpc.CallOption) (*SwGetLinterErrorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwGetLinterErrorsResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwGetLinterErrors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwGetMcpTools(ctx context.Context, in *SwGetMcpToolsRequest, opts ...grpc.CallOption) (*SwGetMcpToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwGetMcpToolsResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwGetMcpTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwTrackModel(ctx context.Context, in *SwTrackModelRequest, opts ...grpc.CallOption) (*SwTrackModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwTrackModelResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwTrackModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shadowWorkspaceServiceClient) SwCallDiagnosticsExecutor(ctx context.Context, in *SwCallDiagnosticsExecutorRequest, opts ...grpc.CallOption) (*SwCallDiagnosticsExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwCallDiagnosticsExecutorResponse)
	err := c.cc.Invoke(ctx, ShadowWorkspaceService_SwCallDiagnosticsExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShadowWorkspaceServiceServer is the server API for ShadowWorkspaceService service.
// All implementations must embed UnimplementedShadowWorkspaceServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ShadowWorkspaceService (var: Xg)
type ShadowWorkspaceServiceServer interface {
	GetLintsForChange(context.Context, *GetLintsForChangeRequest) (*GetLintsForChangeResponse, error)
	ShadowHealthCheck(context.Context, *ShadowHealthCheckRequest) (*ShadowHealthCheckResponse, error)
	SwSyncIndex(context.Context, *SwSyncIndexRequest) (*SwSyncIndexResponse, error)
	SwProvideTemporaryAccessToken(context.Context, *SwProvideTemporaryAccessTokenRequest) (*SwProvideTemporaryAccessTokenResponse, error)
	SwCompileRepoIncludeExcludePatterns(context.Context, *SwCompileRepoIncludeExcludePatternsRequest) (*SwCompileRepoIncludeExcludePatternsResponse, error)
	SwCallClientSideV2Tool(context.Context, *SwCallClientSideV2ToolRequest) (*SwCallClientSideV2ToolResponse, error)
	SwGetExplicitContext(context.Context, *SwGetExplicitContextRequest) (*SwGetExplicitContextResponse, error)
	SwWriteTextFileWithLints(context.Context, *SwWriteTextFileWithLintsRequest) (*SwWriteTextFileWithLintsResponse, error)
	SwGetEnvironmentInfo(context.Context, *SwGetEnvironmentInfoRequest) (*SwGetEnvironmentInfoResponse, error)
	SwGetLinterErrors(context.Context, *SwGetLinterErrorsRequest) (*SwGetLinterErrorsResponse, error)
	SwGetMcpTools(context.Context, *SwGetMcpToolsRequest) (*SwGetMcpToolsResponse, error)
	SwTrackModel(context.Context, *SwTrackModelRequest) (*SwTrackModelResponse, error)
	SwCallDiagnosticsExecutor(context.Context, *SwCallDiagnosticsExecutorRequest) (*SwCallDiagnosticsExecutorResponse, error)
	mustEmbedUnimplementedShadowWorkspaceServiceServer()
}

// UnimplementedShadowWorkspaceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShadowWorkspaceServiceServer struct{}

func (UnimplementedShadowWorkspaceServiceServer) GetLintsForChange(context.Context, *GetLintsForChangeRequest) (*GetLintsForChangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLintsForChange not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) ShadowHealthCheck(context.Context, *ShadowHealthCheckRequest) (*ShadowHealthCheckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShadowHealthCheck not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwSyncIndex(context.Context, *SwSyncIndexRequest) (*SwSyncIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwSyncIndex not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwProvideTemporaryAccessToken(context.Context, *SwProvideTemporaryAccessTokenRequest) (*SwProvideTemporaryAccessTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwProvideTemporaryAccessToken not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwCompileRepoIncludeExcludePatterns(context.Context, *SwCompileRepoIncludeExcludePatternsRequest) (*SwCompileRepoIncludeExcludePatternsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwCompileRepoIncludeExcludePatterns not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwCallClientSideV2Tool(context.Context, *SwCallClientSideV2ToolRequest) (*SwCallClientSideV2ToolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwCallClientSideV2Tool not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwGetExplicitContext(context.Context, *SwGetExplicitContextRequest) (*SwGetExplicitContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwGetExplicitContext not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwWriteTextFileWithLints(context.Context, *SwWriteTextFileWithLintsRequest) (*SwWriteTextFileWithLintsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwWriteTextFileWithLints not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwGetEnvironmentInfo(context.Context, *SwGetEnvironmentInfoRequest) (*SwGetEnvironmentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwGetEnvironmentInfo not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwGetLinterErrors(context.Context, *SwGetLinterErrorsRequest) (*SwGetLinterErrorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwGetLinterErrors not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwGetMcpTools(context.Context, *SwGetMcpToolsRequest) (*SwGetMcpToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwGetMcpTools not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwTrackModel(context.Context, *SwTrackModelRequest) (*SwTrackModelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwTrackModel not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) SwCallDiagnosticsExecutor(context.Context, *SwCallDiagnosticsExecutorRequest) (*SwCallDiagnosticsExecutorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwCallDiagnosticsExecutor not implemented")
}
func (UnimplementedShadowWorkspaceServiceServer) mustEmbedUnimplementedShadowWorkspaceServiceServer() {
}
func (UnimplementedShadowWorkspaceServiceServer) testEmbeddedByValue() {}

// UnsafeShadowWorkspaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShadowWorkspaceServiceServer will
// result in compilation errors.
type UnsafeShadowWorkspaceServiceServer interface {
	mustEmbedUnimplementedShadowWorkspaceServiceServer()
}

func RegisterShadowWorkspaceServiceServer(s grpc.ServiceRegistrar, srv ShadowWorkspaceServiceServer) {
	// If the following call panics, it indicates UnimplementedShadowWorkspaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ShadowWorkspaceService_ServiceDesc, srv)
}

func _ShadowWorkspaceService_GetLintsForChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLintsForChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).GetLintsForChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_GetLintsForChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).GetLintsForChange(ctx, req.(*GetLintsForChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_ShadowHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShadowHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).ShadowHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_ShadowHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).ShadowHealthCheck(ctx, req.(*ShadowHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwSyncIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwSyncIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwSyncIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwSyncIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwSyncIndex(ctx, req.(*SwSyncIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwProvideTemporaryAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwProvideTemporaryAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwProvideTemporaryAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwProvideTemporaryAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwProvideTemporaryAccessToken(ctx, req.(*SwProvideTemporaryAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwCompileRepoIncludeExcludePatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwCompileRepoIncludeExcludePatternsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwCompileRepoIncludeExcludePatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwCompileRepoIncludeExcludePatterns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwCompileRepoIncludeExcludePatterns(ctx, req.(*SwCompileRepoIncludeExcludePatternsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwCallClientSideV2Tool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwCallClientSideV2ToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwCallClientSideV2Tool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwCallClientSideV2Tool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwCallClientSideV2Tool(ctx, req.(*SwCallClientSideV2ToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwGetExplicitContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwGetExplicitContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwGetExplicitContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwGetExplicitContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwGetExplicitContext(ctx, req.(*SwGetExplicitContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwWriteTextFileWithLints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwWriteTextFileWithLintsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwWriteTextFileWithLints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwWriteTextFileWithLints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwWriteTextFileWithLints(ctx, req.(*SwWriteTextFileWithLintsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwGetEnvironmentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwGetEnvironmentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwGetEnvironmentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwGetEnvironmentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwGetEnvironmentInfo(ctx, req.(*SwGetEnvironmentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwGetLinterErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwGetLinterErrorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwGetLinterErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwGetLinterErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwGetLinterErrors(ctx, req.(*SwGetLinterErrorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwGetMcpTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwGetMcpToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwGetMcpTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwGetMcpTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwGetMcpTools(ctx, req.(*SwGetMcpToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwTrackModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwTrackModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwTrackModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwTrackModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwTrackModel(ctx, req.(*SwTrackModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShadowWorkspaceService_SwCallDiagnosticsExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwCallDiagnosticsExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShadowWorkspaceServiceServer).SwCallDiagnosticsExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShadowWorkspaceService_SwCallDiagnosticsExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShadowWorkspaceServiceServer).SwCallDiagnosticsExecutor(ctx, req.(*SwCallDiagnosticsExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShadowWorkspaceService_ServiceDesc is the grpc.ServiceDesc for ShadowWorkspaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShadowWorkspaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ShadowWorkspaceService",
	HandlerType: (*ShadowWorkspaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLintsForChange",
			Handler:    _ShadowWorkspaceService_GetLintsForChange_Handler,
		},
		{
			MethodName: "ShadowHealthCheck",
			Handler:    _ShadowWorkspaceService_ShadowHealthCheck_Handler,
		},
		{
			MethodName: "SwSyncIndex",
			Handler:    _ShadowWorkspaceService_SwSyncIndex_Handler,
		},
		{
			MethodName: "SwProvideTemporaryAccessToken",
			Handler:    _ShadowWorkspaceService_SwProvideTemporaryAccessToken_Handler,
		},
		{
			MethodName: "SwCompileRepoIncludeExcludePatterns",
			Handler:    _ShadowWorkspaceService_SwCompileRepoIncludeExcludePatterns_Handler,
		},
		{
			MethodName: "SwCallClientSideV2Tool",
			Handler:    _ShadowWorkspaceService_SwCallClientSideV2Tool_Handler,
		},
		{
			MethodName: "SwGetExplicitContext",
			Handler:    _ShadowWorkspaceService_SwGetExplicitContext_Handler,
		},
		{
			MethodName: "SwWriteTextFileWithLints",
			Handler:    _ShadowWorkspaceService_SwWriteTextFileWithLints_Handler,
		},
		{
			MethodName: "SwGetEnvironmentInfo",
			Handler:    _ShadowWorkspaceService_SwGetEnvironmentInfo_Handler,
		},
		{
			MethodName: "SwGetLinterErrors",
			Handler:    _ShadowWorkspaceService_SwGetLinterErrors_Handler,
		},
		{
			MethodName: "SwGetMcpTools",
			Handler:    _ShadowWorkspaceService_SwGetMcpTools_Handler,
		},
		{
			MethodName: "SwTrackModel",
			Handler:    _ShadowWorkspaceService_SwTrackModel_Handler,
		},
		{
			MethodName: "SwCallDiagnosticsExecutor",
			Handler:    _ShadowWorkspaceService_SwCallDiagnosticsExecutor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	TeamCreditsService_GetTeamCredits_FullMethodName   = "/aiserver.v1.TeamCreditsService/GetTeamCredits"
	TeamCreditsService_SetTeamCredits_FullMethodName   = "/aiserver.v1.TeamCreditsService/SetTeamCredits"
	TeamCreditsService_ClearTeamCredits_FullMethodName = "/aiserver.v1.TeamCreditsService/ClearTeamCredits"
)

// TeamCreditsServiceClient is the client API for TeamCreditsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.TeamCreditsService (var: zYe)
type TeamCreditsServiceClient interface {
	GetTeamCredits(ctx context.Context, in *GetTeamCreditsRequest, opts ...grpc.CallOption) (*GetTeamCreditsResponse, error)
	SetTeamCredits(ctx context.Context, in *SetTeamCreditsRequest, opts ...grpc.CallOption) (*SetTeamCreditsResponse, error)
	ClearTeamCredits(ctx context.Context, in *ClearTeamCreditsRequest, opts ...grpc.CallOption) (*ClearTeamCreditsResponse, error)
}

type teamCreditsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTeamCreditsServiceClient(cc grpc.ClientConnInterface) TeamCreditsServiceClient {
	return &teamCreditsServiceClient{cc}
}

func (c *teamCreditsServiceClient) GetTeamCredits(ctx context.Context, in *GetTeamCreditsRequest, opts ...grpc.CallOption) (*GetTeamCreditsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamCreditsResponse)
	err := c.cc.Invoke(ctx, TeamCreditsService_GetTeamCredits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamCreditsServiceClient) SetTeamCredits(ctx context.Context, in *SetTeamCreditsRequest, opts ...grpc.CallOption) (*SetTeamCreditsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetTeamCreditsResponse)
	err := c.cc.Invoke(ctx, TeamCreditsService_SetTeamCredits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamCreditsServiceClient) ClearTeamCredits(ctx context.Context, in *ClearTeamCreditsRequest, opts ...grpc.CallOption) (*ClearTeamCreditsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearTeamCreditsResponse)
	err := c.cc.Invoke(ctx, TeamCreditsService_ClearTeamCredits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TeamCreditsServiceServer is the server API for TeamCreditsService service.
// All implementations must embed UnimplementedTeamCreditsServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.TeamCreditsService (var: zYe)
type TeamCreditsServiceServer interface {
	GetTeamCredits(context.Context, *GetTeamCreditsRequest) (*GetTeamCreditsResponse, error)
	SetTeamCredits(context.Context, *SetTeamCreditsRequest) (*SetTeamCreditsResponse, error)
	ClearTeamCredits(context.Context, *ClearTeamCreditsRequest) (*ClearTeamCreditsResponse, error)
	mustEmbedUnimplementedTeamCreditsServiceServer()
}

// UnimplementedTeamCreditsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTeamCreditsServiceServer struct{}

func (UnimplementedTeamCreditsServiceServer) GetTeamCredits(context.Context, *GetTeamCreditsRequest) (*GetTeamCreditsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeamCredits not implemented")
}
func (UnimplementedTeamCreditsServiceServer) SetTeamCredits(context.Context, *SetTeamCreditsRequest) (*SetTeamCreditsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetTeamCredits not implemented")
}
func (UnimplementedTeamCreditsServiceServer) ClearTeamCredits(context.Context, *ClearTeamCreditsRequest) (*ClearTeamCreditsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearTeamCredits not implemented")
}
func (UnimplementedTeamCreditsServiceServer) mustEmbedUnimplementedTeamCreditsServiceServer() {}
func (UnimplementedTeamCreditsServiceServer) testEmbeddedByValue()                            {}

// UnsafeTeamCreditsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TeamCreditsServiceServer will
// result in compilation errors.
type UnsafeTeamCreditsServiceServer interface {
	mustEmbedUnimplementedTeamCreditsServiceServer()
}

func RegisterTeamCreditsServiceServer(s grpc.ServiceRegistrar, srv TeamCreditsServiceServer) {
	// If the following call panics, it indicates UnimplementedTeamCreditsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TeamCreditsService_ServiceDesc, srv)
}

func _TeamCreditsService_GetTeamCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamCreditsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamCreditsServiceServer).GetTeamCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamCreditsService_GetTeamCredits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamCreditsServiceServer).GetTeamCredits(ctx, req.(*GetTeamCreditsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamCreditsService_SetTeamCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTeamCreditsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamCreditsServiceServer).SetTeamCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamCreditsService_SetTeamCredits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamCreditsServiceServer).SetTeamCredits(ctx, req.(*SetTeamCreditsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamCreditsService_ClearTeamCredits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearTeamCreditsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamCreditsServiceServer).ClearTeamCredits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamCreditsService_ClearTeamCredits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamCreditsServiceServer).ClearTeamCredits(ctx, req.(*ClearTeamCreditsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TeamCreditsService_ServiceDesc is the grpc.ServiceDesc for TeamCreditsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TeamCreditsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.TeamCreditsService",
	HandlerType: (*TeamCreditsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTeamCredits",
			Handler:    _TeamCreditsService_GetTeamCredits_Handler,
		},
		{
			MethodName: "SetTeamCredits",
			Handler:    _TeamCreditsService_SetTeamCredits_Handler,
		},
		{
			MethodName: "ClearTeamCredits",
			Handler:    _TeamCreditsService_ClearTeamCredits_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	ToolCallEventService_SubmitToolCallEvents_FullMethodName = "/aiserver.v1.ToolCallEventService/SubmitToolCallEvents"
)

// ToolCallEventServiceClient is the client API for ToolCallEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.ToolCallEventService (var: lze)
type ToolCallEventServiceClient interface {
	SubmitToolCallEvents(ctx context.Context, in *SubmitToolCallEventsRequest, opts ...grpc.CallOption) (*SubmitToolCallEventsResponse, error)
}

type toolCallEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewToolCallEventServiceClient(cc grpc.ClientConnInterface) ToolCallEventServiceClient {
	return &toolCallEventServiceClient{cc}
}

func (c *toolCallEventServiceClient) SubmitToolCallEvents(ctx context.Context, in *SubmitToolCallEventsRequest, opts ...grpc.CallOption) (*SubmitToolCallEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitToolCallEventsResponse)
	err := c.cc.Invoke(ctx, ToolCallEventService_SubmitToolCallEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ToolCallEventServiceServer is the server API for ToolCallEventService service.
// All implementations must embed UnimplementedToolCallEventServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.ToolCallEventService (var: lze)
type ToolCallEventServiceServer interface {
	SubmitToolCallEvents(context.Context, *SubmitToolCallEventsRequest) (*SubmitToolCallEventsResponse, error)
	mustEmbedUnimplementedToolCallEventServiceServer()
}

// UnimplementedToolCallEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedToolCallEventServiceServer struct{}

func (UnimplementedToolCallEventServiceServer) SubmitToolCallEvents(context.Context, *SubmitToolCallEventsRequest) (*SubmitToolCallEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitToolCallEvents not implemented")
}
func (UnimplementedToolCallEventServiceServer) mustEmbedUnimplementedToolCallEventServiceServer() {}
func (UnimplementedToolCallEventServiceServer) testEmbeddedByValue()                              {}

// UnsafeToolCallEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ToolCallEventServiceServer will
// result in compilation errors.
type UnsafeToolCallEventServiceServer interface {
	mustEmbedUnimplementedToolCallEventServiceServer()
}

func RegisterToolCallEventServiceServer(s grpc.ServiceRegistrar, srv ToolCallEventServiceServer) {
	// If the following call panics, it indicates UnimplementedToolCallEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ToolCallEventService_ServiceDesc, srv)
}

func _ToolCallEventService_SubmitToolCallEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitToolCallEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ToolCallEventServiceServer).SubmitToolCallEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ToolCallEventService_SubmitToolCallEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ToolCallEventServiceServer).SubmitToolCallEvents(ctx, req.(*SubmitToolCallEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ToolCallEventService_ServiceDesc is the grpc.ServiceDesc for ToolCallEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ToolCallEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.ToolCallEventService",
	HandlerType: (*ToolCallEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitToolCallEvents",
			Handler:    _ToolCallEventService_SubmitToolCallEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	TraceService_SubmitSpans_FullMethodName = "/aiserver.v1.TraceService/SubmitSpans"
)

// TraceServiceClient is the client API for TraceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.TraceService (var: cze)
type TraceServiceClient interface {
	SubmitSpans(ctx context.Context, in *SubmitSpansRequest, opts ...grpc.CallOption) (*SubmitSpansResponse, error)
}

type traceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTraceServiceClient(cc grpc.ClientConnInterface) TraceServiceClient {
	return &traceServiceClient{cc}
}

func (c *traceServiceClient) SubmitSpans(ctx context.Context, in *SubmitSpansRequest, opts ...grpc.CallOption) (*SubmitSpansResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitSpansResponse)
	err := c.cc.Invoke(ctx, TraceService_SubmitSpans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TraceServiceServer is the server API for TraceService service.
// All implementations must embed UnimplementedTraceServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.TraceService (var: cze)
type TraceServiceServer interface {
	SubmitSpans(context.Context, *SubmitSpansRequest) (*SubmitSpansResponse, error)
	mustEmbedUnimplementedTraceServiceServer()
}

// UnimplementedTraceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTraceServiceServer struct{}

func (UnimplementedTraceServiceServer) SubmitSpans(context.Context, *SubmitSpansRequest) (*SubmitSpansResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitSpans not implemented")
}
func (UnimplementedTraceServiceServer) mustEmbedUnimplementedTraceServiceServer() {}
func (UnimplementedTraceServiceServer) testEmbeddedByValue()                      {}

// UnsafeTraceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TraceServiceServer will
// result in compilation errors.
type UnsafeTraceServiceServer interface {
	mustEmbedUnimplementedTraceServiceServer()
}

func RegisterTraceServiceServer(s grpc.ServiceRegistrar, srv TraceServiceServer) {
	// If the following call panics, it indicates UnimplementedTraceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TraceService_ServiceDesc, srv)
}

func _TraceService_SubmitSpans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitSpansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraceServiceServer).SubmitSpans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TraceService_SubmitSpans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraceServiceServer).SubmitSpans(ctx, req.(*SubmitSpansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TraceService_ServiceDesc is the grpc.ServiceDesc for TraceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TraceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.TraceService",
	HandlerType: (*TraceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitSpans",
			Handler:    _TraceService_SubmitSpans_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	UploadService_UploadDocumentation_FullMethodName       = "/aiserver.v1.UploadService/UploadDocumentation"
	UploadService_UploadDocumentationStatus_FullMethodName = "/aiserver.v1.UploadService/UploadDocumentationStatus"
	UploadService_MarkAsPublic_FullMethodName              = "/aiserver.v1.UploadService/MarkAsPublic"
	UploadService_UploadStatus_FullMethodName              = "/aiserver.v1.UploadService/UploadStatus"
	UploadService_GetPages_FullMethodName                  = "/aiserver.v1.UploadService/GetPages"
	UploadService_GetDoc_FullMethodName                    = "/aiserver.v1.UploadService/GetDoc"
	UploadService_RescrapeDocs_FullMethodName              = "/aiserver.v1.UploadService/RescrapeDocs"
	UploadService_RescrapeDocsV2_FullMethodName            = "/aiserver.v1.UploadService/RescrapeDocsV2"
	UploadService_UpsertAllDocs_FullMethodName             = "/aiserver.v1.UploadService/UpsertAllDocs"
)

// UploadServiceClient is the client API for UploadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.UploadService (var: QYe)
type UploadServiceClient interface {
	UploadDocumentation(ctx context.Context, in *NewDocumentationRequest, opts ...grpc.CallOption) (*UploadResponse, error)
	UploadDocumentationStatus(ctx context.Context, in *UploadDocumentationRequest, opts ...grpc.CallOption) (*UploadedStatus, error)
	MarkAsPublic(ctx context.Context, in *MarkAsPublicRequest, opts ...grpc.CallOption) (*UploadedStatus, error)
	UploadStatus(ctx context.Context, in *UploadedStatusRequest, opts ...grpc.CallOption) (*UploadedStatus, error)
	GetPages(ctx context.Context, in *GetPagesRequest, opts ...grpc.CallOption) (*Pages, error)
	GetDoc(ctx context.Context, in *GetDocRequest, opts ...grpc.CallOption) (*ProtoDoc, error)
	RescrapeDocs(ctx context.Context, in *RescrapeDocsRequest, opts ...grpc.CallOption) (*RescrapeDocsResponse, error)
	RescrapeDocsV2(ctx context.Context, in *RescrapeDocsRequestV2, opts ...grpc.CallOption) (*RescrapeDocsResponse, error)
	UpsertAllDocs(ctx context.Context, in *UpsertDocsRequest, opts ...grpc.CallOption) (*UpsertDocsResponse, error)
}

type uploadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUploadServiceClient(cc grpc.ClientConnInterface) UploadServiceClient {
	return &uploadServiceClient{cc}
}

func (c *uploadServiceClient) UploadDocumentation(ctx context.Context, in *NewDocumentationRequest, opts ...grpc.CallOption) (*UploadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadResponse)
	err := c.cc.Invoke(ctx, UploadService_UploadDocumentation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) UploadDocumentationStatus(ctx context.Context, in *UploadDocumentationRequest, opts ...grpc.CallOption) (*UploadedStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedStatus)
	err := c.cc.Invoke(ctx, UploadService_UploadDocumentationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) MarkAsPublic(ctx context.Context, in *MarkAsPublicRequest, opts ...grpc.CallOption) (*UploadedStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedStatus)
	err := c.cc.Invoke(ctx, UploadService_MarkAsPublic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) UploadStatus(ctx context.Context, in *UploadedStatusRequest, opts ...grpc.CallOption) (*UploadedStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadedStatus)
	err := c.cc.Invoke(ctx, UploadService_UploadStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) GetPages(ctx context.Context, in *GetPagesRequest, opts ...grpc.CallOption) (*Pages, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pages)
	err := c.cc.Invoke(ctx, UploadService_GetPages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) GetDoc(ctx context.Context, in *GetDocRequest, opts ...grpc.CallOption) (*ProtoDoc, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProtoDoc)
	err := c.cc.Invoke(ctx, UploadService_GetDoc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) RescrapeDocs(ctx context.Context, in *RescrapeDocsRequest, opts ...grpc.CallOption) (*RescrapeDocsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RescrapeDocsResponse)
	err := c.cc.Invoke(ctx, UploadService_RescrapeDocs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) RescrapeDocsV2(ctx context.Context, in *RescrapeDocsRequestV2, opts ...grpc.CallOption) (*RescrapeDocsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RescrapeDocsResponse)
	err := c.cc.Invoke(ctx, UploadService_RescrapeDocsV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *uploadServiceClient) UpsertAllDocs(ctx context.Context, in *UpsertDocsRequest, opts ...grpc.CallOption) (*UpsertDocsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertDocsResponse)
	err := c.cc.Invoke(ctx, UploadService_UpsertAllDocs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UploadServiceServer is the server API for UploadService service.
// All implementations must embed UnimplementedUploadServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.UploadService (var: QYe)
type UploadServiceServer interface {
	UploadDocumentation(context.Context, *NewDocumentationRequest) (*UploadResponse, error)
	UploadDocumentationStatus(context.Context, *UploadDocumentationRequest) (*UploadedStatus, error)
	MarkAsPublic(context.Context, *MarkAsPublicRequest) (*UploadedStatus, error)
	UploadStatus(context.Context, *UploadedStatusRequest) (*UploadedStatus, error)
	GetPages(context.Context, *GetPagesRequest) (*Pages, error)
	GetDoc(context.Context, *GetDocRequest) (*ProtoDoc, error)
	RescrapeDocs(context.Context, *RescrapeDocsRequest) (*RescrapeDocsResponse, error)
	RescrapeDocsV2(context.Context, *RescrapeDocsRequestV2) (*RescrapeDocsResponse, error)
	UpsertAllDocs(context.Context, *UpsertDocsRequest) (*UpsertDocsResponse, error)
	mustEmbedUnimplementedUploadServiceServer()
}

// UnimplementedUploadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUploadServiceServer struct{}

func (UnimplementedUploadServiceServer) UploadDocumentation(context.Context, *NewDocumentationRequest) (*UploadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadDocumentation not implemented")
}
func (UnimplementedUploadServiceServer) UploadDocumentationStatus(context.Context, *UploadDocumentationRequest) (*UploadedStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadDocumentationStatus not implemented")
}
func (UnimplementedUploadServiceServer) MarkAsPublic(context.Context, *MarkAsPublicRequest) (*UploadedStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkAsPublic not implemented")
}
func (UnimplementedUploadServiceServer) UploadStatus(context.Context, *UploadedStatusRequest) (*UploadedStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadStatus not implemented")
}
func (UnimplementedUploadServiceServer) GetPages(context.Context, *GetPagesRequest) (*Pages, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPages not implemented")
}
func (UnimplementedUploadServiceServer) GetDoc(context.Context, *GetDocRequest) (*ProtoDoc, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDoc not implemented")
}
func (UnimplementedUploadServiceServer) RescrapeDocs(context.Context, *RescrapeDocsRequest) (*RescrapeDocsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RescrapeDocs not implemented")
}
func (UnimplementedUploadServiceServer) RescrapeDocsV2(context.Context, *RescrapeDocsRequestV2) (*RescrapeDocsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RescrapeDocsV2 not implemented")
}
func (UnimplementedUploadServiceServer) UpsertAllDocs(context.Context, *UpsertDocsRequest) (*UpsertDocsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpsertAllDocs not implemented")
}
func (UnimplementedUploadServiceServer) mustEmbedUnimplementedUploadServiceServer() {}
func (UnimplementedUploadServiceServer) testEmbeddedByValue()                       {}

// UnsafeUploadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UploadServiceServer will
// result in compilation errors.
type UnsafeUploadServiceServer interface {
	mustEmbedUnimplementedUploadServiceServer()
}

func RegisterUploadServiceServer(s grpc.ServiceRegistrar, srv UploadServiceServer) {
	// If the following call panics, it indicates UnimplementedUploadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UploadService_ServiceDesc, srv)
}

func _UploadService_UploadDocumentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewDocumentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).UploadDocumentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_UploadDocumentation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).UploadDocumentation(ctx, req.(*NewDocumentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_UploadDocumentationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDocumentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).UploadDocumentationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_UploadDocumentationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).UploadDocumentationStatus(ctx, req.(*UploadDocumentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_MarkAsPublic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsPublicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).MarkAsPublic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_MarkAsPublic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).MarkAsPublic(ctx, req.(*MarkAsPublicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_UploadStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadedStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).UploadStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_UploadStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).UploadStatus(ctx, req.(*UploadedStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_GetPages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).GetPages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_GetPages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).GetPages(ctx, req.(*GetPagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_GetDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).GetDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_GetDoc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).GetDoc(ctx, req.(*GetDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_RescrapeDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RescrapeDocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).RescrapeDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_RescrapeDocs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).RescrapeDocs(ctx, req.(*RescrapeDocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_RescrapeDocsV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RescrapeDocsRequestV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).RescrapeDocsV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_RescrapeDocsV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).RescrapeDocsV2(ctx, req.(*RescrapeDocsRequestV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _UploadService_UpsertAllDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertDocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UploadServiceServer).UpsertAllDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UploadService_UpsertAllDocs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UploadServiceServer).UpsertAllDocs(ctx, req.(*UpsertDocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UploadService_ServiceDesc is the grpc.ServiceDesc for UploadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UploadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.UploadService",
	HandlerType: (*UploadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadDocumentation",
			Handler:    _UploadService_UploadDocumentation_Handler,
		},
		{
			MethodName: "UploadDocumentationStatus",
			Handler:    _UploadService_UploadDocumentationStatus_Handler,
		},
		{
			MethodName: "MarkAsPublic",
			Handler:    _UploadService_MarkAsPublic_Handler,
		},
		{
			MethodName: "UploadStatus",
			Handler:    _UploadService_UploadStatus_Handler,
		},
		{
			MethodName: "GetPages",
			Handler:    _UploadService_GetPages_Handler,
		},
		{
			MethodName: "GetDoc",
			Handler:    _UploadService_GetDoc_Handler,
		},
		{
			MethodName: "RescrapeDocs",
			Handler:    _UploadService_RescrapeDocs_Handler,
		},
		{
			MethodName: "RescrapeDocsV2",
			Handler:    _UploadService_RescrapeDocsV2_Handler,
		},
		{
			MethodName: "UpsertAllDocs",
			Handler:    _UploadService_UpsertAllDocs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	UsageSimulationService_GetSimulation_FullMethodName     = "/aiserver.v1.UsageSimulationService/GetSimulation"
	UsageSimulationService_SetSimulation_FullMethodName     = "/aiserver.v1.UsageSimulationService/SetSimulation"
	UsageSimulationService_ClearSimulation_FullMethodName   = "/aiserver.v1.UsageSimulationService/ClearSimulation"
	UsageSimulationService_GetAllSimulations_FullMethodName = "/aiserver.v1.UsageSimulationService/GetAllSimulations"
	UsageSimulationService_AddSyntheticUsage_FullMethodName = "/aiserver.v1.UsageSimulationService/AddSyntheticUsage"
)

// UsageSimulationServiceClient is the client API for UsageSimulationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.UsageSimulationService (var: eKe)
type UsageSimulationServiceClient interface {
	GetSimulation(ctx context.Context, in *GetSimulationRequest, opts ...grpc.CallOption) (*GetSimulationResponse, error)
	SetSimulation(ctx context.Context, in *SetSimulationRequest, opts ...grpc.CallOption) (*SetSimulationResponse, error)
	ClearSimulation(ctx context.Context, in *ClearSimulationRequest, opts ...grpc.CallOption) (*ClearSimulationResponse, error)
	GetAllSimulations(ctx context.Context, in *GetAllSimulationsRequest, opts ...grpc.CallOption) (*GetAllSimulationsResponse, error)
	AddSyntheticUsage(ctx context.Context, in *AddSyntheticUsageRequest, opts ...grpc.CallOption) (*AddSyntheticUsageResponse, error)
}

type usageSimulationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUsageSimulationServiceClient(cc grpc.ClientConnInterface) UsageSimulationServiceClient {
	return &usageSimulationServiceClient{cc}
}

func (c *usageSimulationServiceClient) GetSimulation(ctx context.Context, in *GetSimulationRequest, opts ...grpc.CallOption) (*GetSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSimulationResponse)
	err := c.cc.Invoke(ctx, UsageSimulationService_GetSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageSimulationServiceClient) SetSimulation(ctx context.Context, in *SetSimulationRequest, opts ...grpc.CallOption) (*SetSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSimulationResponse)
	err := c.cc.Invoke(ctx, UsageSimulationService_SetSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageSimulationServiceClient) ClearSimulation(ctx context.Context, in *ClearSimulationRequest, opts ...grpc.CallOption) (*ClearSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearSimulationResponse)
	err := c.cc.Invoke(ctx, UsageSimulationService_ClearSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageSimulationServiceClient) GetAllSimulations(ctx context.Context, in *GetAllSimulationsRequest, opts ...grpc.CallOption) (*GetAllSimulationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllSimulationsResponse)
	err := c.cc.Invoke(ctx, UsageSimulationService_GetAllSimulations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageSimulationServiceClient) AddSyntheticUsage(ctx context.Context, in *AddSyntheticUsageRequest, opts ...grpc.CallOption) (*AddSyntheticUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddSyntheticUsageResponse)
	err := c.cc.Invoke(ctx, UsageSimulationService_AddSyntheticUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsageSimulationServiceServer is the server API for UsageSimulationService service.
// All implementations must embed UnimplementedUsageSimulationServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.UsageSimulationService (var: eKe)
type UsageSimulationServiceServer interface {
	GetSimulation(context.Context, *GetSimulationRequest) (*GetSimulationResponse, error)
	SetSimulation(context.Context, *SetSimulationRequest) (*SetSimulationResponse, error)
	ClearSimulation(context.Context, *ClearSimulationRequest) (*ClearSimulationResponse, error)
	GetAllSimulations(context.Context, *GetAllSimulationsRequest) (*GetAllSimulationsResponse, error)
	AddSyntheticUsage(context.Context, *AddSyntheticUsageRequest) (*AddSyntheticUsageResponse, error)
	mustEmbedUnimplementedUsageSimulationServiceServer()
}

// UnimplementedUsageSimulationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUsageSimulationServiceServer struct{}

func (UnimplementedUsageSimulationServiceServer) GetSimulation(context.Context, *GetSimulationRequest) (*GetSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSimulation not implemented")
}
func (UnimplementedUsageSimulationServiceServer) SetSimulation(context.Context, *SetSimulationRequest) (*SetSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSimulation not implemented")
}
func (UnimplementedUsageSimulationServiceServer) ClearSimulation(context.Context, *ClearSimulationRequest) (*ClearSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearSimulation not implemented")
}
func (UnimplementedUsageSimulationServiceServer) GetAllSimulations(context.Context, *GetAllSimulationsRequest) (*GetAllSimulationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAllSimulations not implemented")
}
func (UnimplementedUsageSimulationServiceServer) AddSyntheticUsage(context.Context, *AddSyntheticUsageRequest) (*AddSyntheticUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddSyntheticUsage not implemented")
}
func (UnimplementedUsageSimulationServiceServer) mustEmbedUnimplementedUsageSimulationServiceServer() {
}
func (UnimplementedUsageSimulationServiceServer) testEmbeddedByValue() {}

// UnsafeUsageSimulationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsageSimulationServiceServer will
// result in compilation errors.
type UnsafeUsageSimulationServiceServer interface {
	mustEmbedUnimplementedUsageSimulationServiceServer()
}

func RegisterUsageSimulationServiceServer(s grpc.ServiceRegistrar, srv UsageSimulationServiceServer) {
	// If the following call panics, it indicates UnimplementedUsageSimulationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UsageSimulationService_ServiceDesc, srv)
}

func _UsageSimulationService_GetSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageSimulationServiceServer).GetSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageSimulationService_GetSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageSimulationServiceServer).GetSimulation(ctx, req.(*GetSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageSimulationService_SetSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageSimulationServiceServer).SetSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageSimulationService_SetSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageSimulationServiceServer).SetSimulation(ctx, req.(*SetSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageSimulationService_ClearSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageSimulationServiceServer).ClearSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageSimulationService_ClearSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageSimulationServiceServer).ClearSimulation(ctx, req.(*ClearSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageSimulationService_GetAllSimulations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllSimulationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageSimulationServiceServer).GetAllSimulations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageSimulationService_GetAllSimulations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageSimulationServiceServer).GetAllSimulations(ctx, req.(*GetAllSimulationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageSimulationService_AddSyntheticUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSyntheticUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageSimulationServiceServer).AddSyntheticUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsageSimulationService_AddSyntheticUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageSimulationServiceServer).AddSyntheticUsage(ctx, req.(*AddSyntheticUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UsageSimulationService_ServiceDesc is the grpc.ServiceDesc for UsageSimulationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UsageSimulationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.UsageSimulationService",
	HandlerType: (*UsageSimulationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSimulation",
			Handler:    _UsageSimulationService_GetSimulation_Handler,
		},
		{
			MethodName: "SetSimulation",
			Handler:    _UsageSimulationService_SetSimulation_Handler,
		},
		{
			MethodName: "ClearSimulation",
			Handler:    _UsageSimulationService_ClearSimulation_Handler,
		},
		{
			MethodName: "GetAllSimulations",
			Handler:    _UsageSimulationService_GetAllSimulations_Handler,
		},
		{
			MethodName: "AddSyntheticUsage",
			Handler:    _UsageSimulationService_AddSyntheticUsage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	VmDaemonService_SyncIndex_FullMethodName                         = "/aiserver.v1.VmDaemonService/SyncIndex"
	VmDaemonService_CompileRepoIncludeExcludePatterns_FullMethodName = "/aiserver.v1.VmDaemonService/CompileRepoIncludeExcludePatterns"
	VmDaemonService_Upgrade_FullMethodName                           = "/aiserver.v1.VmDaemonService/Upgrade"
	VmDaemonService_Ping_FullMethodName                              = "/aiserver.v1.VmDaemonService/Ping"
	VmDaemonService_Exec_FullMethodName                              = "/aiserver.v1.VmDaemonService/Exec"
	VmDaemonService_CallClientSideV2Tool_FullMethodName              = "/aiserver.v1.VmDaemonService/CallClientSideV2Tool"
	VmDaemonService_ReadTextFile_FullMethodName                      = "/aiserver.v1.VmDaemonService/ReadTextFile"
	VmDaemonService_WriteTextFile_FullMethodName                     = "/aiserver.v1.VmDaemonService/WriteTextFile"
	VmDaemonService_GetFileStats_FullMethodName                      = "/aiserver.v1.VmDaemonService/GetFileStats"
	VmDaemonService_GetExplicitContext_FullMethodName                = "/aiserver.v1.VmDaemonService/GetExplicitContext"
	VmDaemonService_GetEnvironmentInfo_FullMethodName                = "/aiserver.v1.VmDaemonService/GetEnvironmentInfo"
	VmDaemonService_ProvideTemporaryAccessToken_FullMethodName       = "/aiserver.v1.VmDaemonService/ProvideTemporaryAccessToken"
	VmDaemonService_WarmCursorServer_FullMethodName                  = "/aiserver.v1.VmDaemonService/WarmCursorServer"
	VmDaemonService_RefreshGitHubAccessToken_FullMethodName          = "/aiserver.v1.VmDaemonService/RefreshGitHubAccessToken"
	VmDaemonService_GetWorkspaceChangesHash_FullMethodName           = "/aiserver.v1.VmDaemonService/GetWorkspaceChangesHash"
	VmDaemonService_GetDiff_FullMethodName                           = "/aiserver.v1.VmDaemonService/GetDiff"
	VmDaemonService_GetLinterErrors_FullMethodName                   = "/aiserver.v1.VmDaemonService/GetLinterErrors"
	VmDaemonService_GetLogs_FullMethodName                           = "/aiserver.v1.VmDaemonService/GetLogs"
	VmDaemonService_InstallExtensions_FullMethodName                 = "/aiserver.v1.VmDaemonService/InstallExtensions"
	VmDaemonService_GetMcpTools_FullMethodName                       = "/aiserver.v1.VmDaemonService/GetMcpTools"
	VmDaemonService_TrackModel_FullMethodName                        = "/aiserver.v1.VmDaemonService/TrackModel"
	VmDaemonService_CallDiagnosticsExecutor_FullMethodName           = "/aiserver.v1.VmDaemonService/CallDiagnosticsExecutor"
)

// VmDaemonServiceClient is the client API for VmDaemonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.VmDaemonService (var: tKe)
type VmDaemonServiceClient interface {
	SyncIndex(ctx context.Context, in *SyncIndexRequest, opts ...grpc.CallOption) (*SyncIndexResponse, error)
	CompileRepoIncludeExcludePatterns(ctx context.Context, in *CompileRepoIncludeExcludePatternsRequest, opts ...grpc.CallOption) (*CompileRepoIncludeExcludePatternsResponse, error)
	Upgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error)
	CallClientSideV2Tool(ctx context.Context, in *CallClientSideV2ToolRequest, opts ...grpc.CallOption) (*CallClientSideV2ToolResponse, error)
	ReadTextFile(ctx context.Context, in *ReadTextFileRequest, opts ...grpc.CallOption) (*ReadTextFileResponse, error)
	WriteTextFile(ctx context.Context, in *WriteTextFileRequest, opts ...grpc.CallOption) (*WriteTextFileResponse, error)
	GetFileStats(ctx context.Context, in *GetFileStatsRequest, opts ...grpc.CallOption) (*GetFileStatsResponse, error)
	GetExplicitContext(ctx context.Context, in *GetExplicitContextRequest, opts ...grpc.CallOption) (*GetExplicitContextResponse, error)
	GetEnvironmentInfo(ctx context.Context, in *GetEnvironmentInfoRequest, opts ...grpc.CallOption) (*GetEnvironmentInfoResponse, error)
	ProvideTemporaryAccessToken(ctx context.Context, in *ProvideTemporaryAccessTokenRequest, opts ...grpc.CallOption) (*ProvideTemporaryAccessTokenResponse, error)
	WarmCursorServer(ctx context.Context, in *WarmCursorServerRequest, opts ...grpc.CallOption) (*WarmCursorServerResponse, error)
	RefreshGitHubAccessToken(ctx context.Context, in *RefreshGitHubAccessTokenRequest, opts ...grpc.CallOption) (*RefreshGitHubAccessTokenResponse, error)
	GetWorkspaceChangesHash(ctx context.Context, in *GetWorkspaceChangesHashRequest, opts ...grpc.CallOption) (*GetWorkspaceChangesHashResponse, error)
	GetDiff(ctx context.Context, in *GetDiffRequest, opts ...grpc.CallOption) (*GetDiffResponse, error)
	GetLinterErrors(ctx context.Context, in *GetLinterErrorsRequest, opts ...grpc.CallOption) (*GetLinterErrorsResponse, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error)
	InstallExtensions(ctx context.Context, in *InstallExtensionsRequest, opts ...grpc.CallOption) (*InstallExtensionsResponse, error)
	GetMcpTools(ctx context.Context, in *GetMcpToolsRequest, opts ...grpc.CallOption) (*GetMcpToolsResponse, error)
	TrackModel(ctx context.Context, in *TrackModelRequest, opts ...grpc.CallOption) (*TrackModelResponse, error)
	CallDiagnosticsExecutor(ctx context.Context, in *CallDiagnosticsExecutorRequest, opts ...grpc.CallOption) (*CallDiagnosticsExecutorResponse, error)
}

type vmDaemonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVmDaemonServiceClient(cc grpc.ClientConnInterface) VmDaemonServiceClient {
	return &vmDaemonServiceClient{cc}
}

func (c *vmDaemonServiceClient) SyncIndex(ctx context.Context, in *SyncIndexRequest, opts ...grpc.CallOption) (*SyncIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncIndexResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_SyncIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) CompileRepoIncludeExcludePatterns(ctx context.Context, in *CompileRepoIncludeExcludePatternsRequest, opts ...grpc.CallOption) (*CompileRepoIncludeExcludePatternsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompileRepoIncludeExcludePatternsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_CompileRepoIncludeExcludePatterns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) Upgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_Upgrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_Exec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) CallClientSideV2Tool(ctx context.Context, in *CallClientSideV2ToolRequest, opts ...grpc.CallOption) (*CallClientSideV2ToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallClientSideV2ToolResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_CallClientSideV2Tool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) ReadTextFile(ctx context.Context, in *ReadTextFileRequest, opts ...grpc.CallOption) (*ReadTextFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadTextFileResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_ReadTextFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) WriteTextFile(ctx context.Context, in *WriteTextFileRequest, opts ...grpc.CallOption) (*WriteTextFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteTextFileResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_WriteTextFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetFileStats(ctx context.Context, in *GetFileStatsRequest, opts ...grpc.CallOption) (*GetFileStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFileStatsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetFileStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetExplicitContext(ctx context.Context, in *GetExplicitContextRequest, opts ...grpc.CallOption) (*GetExplicitContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExplicitContextResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetExplicitContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetEnvironmentInfo(ctx context.Context, in *GetEnvironmentInfoRequest, opts ...grpc.CallOption) (*GetEnvironmentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEnvironmentInfoResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetEnvironmentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) ProvideTemporaryAccessToken(ctx context.Context, in *ProvideTemporaryAccessTokenRequest, opts ...grpc.CallOption) (*ProvideTemporaryAccessTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProvideTemporaryAccessTokenResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_ProvideTemporaryAccessToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) WarmCursorServer(ctx context.Context, in *WarmCursorServerRequest, opts ...grpc.CallOption) (*WarmCursorServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WarmCursorServerResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_WarmCursorServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) RefreshGitHubAccessToken(ctx context.Context, in *RefreshGitHubAccessTokenRequest, opts ...grpc.CallOption) (*RefreshGitHubAccessTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshGitHubAccessTokenResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_RefreshGitHubAccessToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetWorkspaceChangesHash(ctx context.Context, in *GetWorkspaceChangesHashRequest, opts ...grpc.CallOption) (*GetWorkspaceChangesHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkspaceChangesHashResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetWorkspaceChangesHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetDiff(ctx context.Context, in *GetDiffRequest, opts ...grpc.CallOption) (*GetDiffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDiffResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetDiff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetLinterErrors(ctx context.Context, in *GetLinterErrorsRequest, opts ...grpc.CallOption) (*GetLinterErrorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLinterErrorsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetLinterErrors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLogsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) InstallExtensions(ctx context.Context, in *InstallExtensionsRequest, opts ...grpc.CallOption) (*InstallExtensionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstallExtensionsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_InstallExtensions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) GetMcpTools(ctx context.Context, in *GetMcpToolsRequest, opts ...grpc.CallOption) (*GetMcpToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMcpToolsResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_GetMcpTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) TrackModel(ctx context.Context, in *TrackModelRequest, opts ...grpc.CallOption) (*TrackModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrackModelResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_TrackModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vmDaemonServiceClient) CallDiagnosticsExecutor(ctx context.Context, in *CallDiagnosticsExecutorRequest, opts ...grpc.CallOption) (*CallDiagnosticsExecutorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallDiagnosticsExecutorResponse)
	err := c.cc.Invoke(ctx, VmDaemonService_CallDiagnosticsExecutor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VmDaemonServiceServer is the server API for VmDaemonService service.
// All implementations must embed UnimplementedVmDaemonServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.VmDaemonService (var: tKe)
type VmDaemonServiceServer interface {
	SyncIndex(context.Context, *SyncIndexRequest) (*SyncIndexResponse, error)
	CompileRepoIncludeExcludePatterns(context.Context, *CompileRepoIncludeExcludePatternsRequest) (*CompileRepoIncludeExcludePatternsResponse, error)
	Upgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	Exec(context.Context, *ExecRequest) (*ExecResponse, error)
	CallClientSideV2Tool(context.Context, *CallClientSideV2ToolRequest) (*CallClientSideV2ToolResponse, error)
	ReadTextFile(context.Context, *ReadTextFileRequest) (*ReadTextFileResponse, error)
	WriteTextFile(context.Context, *WriteTextFileRequest) (*WriteTextFileResponse, error)
	GetFileStats(context.Context, *GetFileStatsRequest) (*GetFileStatsResponse, error)
	GetExplicitContext(context.Context, *GetExplicitContextRequest) (*GetExplicitContextResponse, error)
	GetEnvironmentInfo(context.Context, *GetEnvironmentInfoRequest) (*GetEnvironmentInfoResponse, error)
	ProvideTemporaryAccessToken(context.Context, *ProvideTemporaryAccessTokenRequest) (*ProvideTemporaryAccessTokenResponse, error)
	WarmCursorServer(context.Context, *WarmCursorServerRequest) (*WarmCursorServerResponse, error)
	RefreshGitHubAccessToken(context.Context, *RefreshGitHubAccessTokenRequest) (*RefreshGitHubAccessTokenResponse, error)
	GetWorkspaceChangesHash(context.Context, *GetWorkspaceChangesHashRequest) (*GetWorkspaceChangesHashResponse, error)
	GetDiff(context.Context, *GetDiffRequest) (*GetDiffResponse, error)
	GetLinterErrors(context.Context, *GetLinterErrorsRequest) (*GetLinterErrorsResponse, error)
	GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error)
	InstallExtensions(context.Context, *InstallExtensionsRequest) (*InstallExtensionsResponse, error)
	GetMcpTools(context.Context, *GetMcpToolsRequest) (*GetMcpToolsResponse, error)
	TrackModel(context.Context, *TrackModelRequest) (*TrackModelResponse, error)
	CallDiagnosticsExecutor(context.Context, *CallDiagnosticsExecutorRequest) (*CallDiagnosticsExecutorResponse, error)
	mustEmbedUnimplementedVmDaemonServiceServer()
}

// UnimplementedVmDaemonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVmDaemonServiceServer struct{}

func (UnimplementedVmDaemonServiceServer) SyncIndex(context.Context, *SyncIndexRequest) (*SyncIndexResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncIndex not implemented")
}
func (UnimplementedVmDaemonServiceServer) CompileRepoIncludeExcludePatterns(context.Context, *CompileRepoIncludeExcludePatternsRequest) (*CompileRepoIncludeExcludePatternsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompileRepoIncludeExcludePatterns not implemented")
}
func (UnimplementedVmDaemonServiceServer) Upgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Upgrade not implemented")
}
func (UnimplementedVmDaemonServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedVmDaemonServiceServer) Exec(context.Context, *ExecRequest) (*ExecResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedVmDaemonServiceServer) CallClientSideV2Tool(context.Context, *CallClientSideV2ToolRequest) (*CallClientSideV2ToolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CallClientSideV2Tool not implemented")
}
func (UnimplementedVmDaemonServiceServer) ReadTextFile(context.Context, *ReadTextFileRequest) (*ReadTextFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadTextFile not implemented")
}
func (UnimplementedVmDaemonServiceServer) WriteTextFile(context.Context, *WriteTextFileRequest) (*WriteTextFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WriteTextFile not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetFileStats(context.Context, *GetFileStatsRequest) (*GetFileStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFileStats not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetExplicitContext(context.Context, *GetExplicitContextRequest) (*GetExplicitContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetExplicitContext not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetEnvironmentInfo(context.Context, *GetEnvironmentInfoRequest) (*GetEnvironmentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEnvironmentInfo not implemented")
}
func (UnimplementedVmDaemonServiceServer) ProvideTemporaryAccessToken(context.Context, *ProvideTemporaryAccessTokenRequest) (*ProvideTemporaryAccessTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ProvideTemporaryAccessToken not implemented")
}
func (UnimplementedVmDaemonServiceServer) WarmCursorServer(context.Context, *WarmCursorServerRequest) (*WarmCursorServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WarmCursorServer not implemented")
}
func (UnimplementedVmDaemonServiceServer) RefreshGitHubAccessToken(context.Context, *RefreshGitHubAccessTokenRequest) (*RefreshGitHubAccessTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshGitHubAccessToken not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetWorkspaceChangesHash(context.Context, *GetWorkspaceChangesHashRequest) (*GetWorkspaceChangesHashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetWorkspaceChangesHash not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetDiff(context.Context, *GetDiffRequest) (*GetDiffResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDiff not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetLinterErrors(context.Context, *GetLinterErrorsRequest) (*GetLinterErrorsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLinterErrors not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedVmDaemonServiceServer) InstallExtensions(context.Context, *InstallExtensionsRequest) (*InstallExtensionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InstallExtensions not implemented")
}
func (UnimplementedVmDaemonServiceServer) GetMcpTools(context.Context, *GetMcpToolsRequest) (*GetMcpToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMcpTools not implemented")
}
func (UnimplementedVmDaemonServiceServer) TrackModel(context.Context, *TrackModelRequest) (*TrackModelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TrackModel not implemented")
}
func (UnimplementedVmDaemonServiceServer) CallDiagnosticsExecutor(context.Context, *CallDiagnosticsExecutorRequest) (*CallDiagnosticsExecutorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CallDiagnosticsExecutor not implemented")
}
func (UnimplementedVmDaemonServiceServer) mustEmbedUnimplementedVmDaemonServiceServer() {}
func (UnimplementedVmDaemonServiceServer) testEmbeddedByValue()                         {}

// UnsafeVmDaemonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VmDaemonServiceServer will
// result in compilation errors.
type UnsafeVmDaemonServiceServer interface {
	mustEmbedUnimplementedVmDaemonServiceServer()
}

func RegisterVmDaemonServiceServer(s grpc.ServiceRegistrar, srv VmDaemonServiceServer) {
	// If the following call panics, it indicates UnimplementedVmDaemonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VmDaemonService_ServiceDesc, srv)
}

func _VmDaemonService_SyncIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).SyncIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_SyncIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).SyncIndex(ctx, req.(*SyncIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_CompileRepoIncludeExcludePatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompileRepoIncludeExcludePatternsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).CompileRepoIncludeExcludePatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_CompileRepoIncludeExcludePatterns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).CompileRepoIncludeExcludePatterns(ctx, req.(*CompileRepoIncludeExcludePatternsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_Upgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).Upgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_Upgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).Upgrade(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_Exec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).Exec(ctx, req.(*ExecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_CallClientSideV2Tool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallClientSideV2ToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).CallClientSideV2Tool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_CallClientSideV2Tool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).CallClientSideV2Tool(ctx, req.(*CallClientSideV2ToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_ReadTextFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadTextFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).ReadTextFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_ReadTextFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).ReadTextFile(ctx, req.(*ReadTextFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_WriteTextFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteTextFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).WriteTextFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_WriteTextFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).WriteTextFile(ctx, req.(*WriteTextFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetFileStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetFileStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetFileStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetFileStats(ctx, req.(*GetFileStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetExplicitContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExplicitContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetExplicitContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetExplicitContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetExplicitContext(ctx, req.(*GetExplicitContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetEnvironmentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEnvironmentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetEnvironmentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetEnvironmentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetEnvironmentInfo(ctx, req.(*GetEnvironmentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_ProvideTemporaryAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvideTemporaryAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).ProvideTemporaryAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_ProvideTemporaryAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).ProvideTemporaryAccessToken(ctx, req.(*ProvideTemporaryAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_WarmCursorServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WarmCursorServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).WarmCursorServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_WarmCursorServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).WarmCursorServer(ctx, req.(*WarmCursorServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_RefreshGitHubAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshGitHubAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).RefreshGitHubAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_RefreshGitHubAccessToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).RefreshGitHubAccessToken(ctx, req.(*RefreshGitHubAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetWorkspaceChangesHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkspaceChangesHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetWorkspaceChangesHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetWorkspaceChangesHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetWorkspaceChangesHash(ctx, req.(*GetWorkspaceChangesHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetDiff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetDiff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetDiff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetDiff(ctx, req.(*GetDiffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetLinterErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLinterErrorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetLinterErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetLinterErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetLinterErrors(ctx, req.(*GetLinterErrorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetLogs(ctx, req.(*GetLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_InstallExtensions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallExtensionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).InstallExtensions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_InstallExtensions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).InstallExtensions(ctx, req.(*InstallExtensionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_GetMcpTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMcpToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).GetMcpTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_GetMcpTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).GetMcpTools(ctx, req.(*GetMcpToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_TrackModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).TrackModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_TrackModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).TrackModel(ctx, req.(*TrackModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VmDaemonService_CallDiagnosticsExecutor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallDiagnosticsExecutorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VmDaemonServiceServer).CallDiagnosticsExecutor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VmDaemonService_CallDiagnosticsExecutor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VmDaemonServiceServer).CallDiagnosticsExecutor(ctx, req.(*CallDiagnosticsExecutorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VmDaemonService_ServiceDesc is the grpc.ServiceDesc for VmDaemonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VmDaemonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.VmDaemonService",
	HandlerType: (*VmDaemonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncIndex",
			Handler:    _VmDaemonService_SyncIndex_Handler,
		},
		{
			MethodName: "CompileRepoIncludeExcludePatterns",
			Handler:    _VmDaemonService_CompileRepoIncludeExcludePatterns_Handler,
		},
		{
			MethodName: "Upgrade",
			Handler:    _VmDaemonService_Upgrade_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _VmDaemonService_Ping_Handler,
		},
		{
			MethodName: "Exec",
			Handler:    _VmDaemonService_Exec_Handler,
		},
		{
			MethodName: "CallClientSideV2Tool",
			Handler:    _VmDaemonService_CallClientSideV2Tool_Handler,
		},
		{
			MethodName: "ReadTextFile",
			Handler:    _VmDaemonService_ReadTextFile_Handler,
		},
		{
			MethodName: "WriteTextFile",
			Handler:    _VmDaemonService_WriteTextFile_Handler,
		},
		{
			MethodName: "GetFileStats",
			Handler:    _VmDaemonService_GetFileStats_Handler,
		},
		{
			MethodName: "GetExplicitContext",
			Handler:    _VmDaemonService_GetExplicitContext_Handler,
		},
		{
			MethodName: "GetEnvironmentInfo",
			Handler:    _VmDaemonService_GetEnvironmentInfo_Handler,
		},
		{
			MethodName: "ProvideTemporaryAccessToken",
			Handler:    _VmDaemonService_ProvideTemporaryAccessToken_Handler,
		},
		{
			MethodName: "WarmCursorServer",
			Handler:    _VmDaemonService_WarmCursorServer_Handler,
		},
		{
			MethodName: "RefreshGitHubAccessToken",
			Handler:    _VmDaemonService_RefreshGitHubAccessToken_Handler,
		},
		{
			MethodName: "GetWorkspaceChangesHash",
			Handler:    _VmDaemonService_GetWorkspaceChangesHash_Handler,
		},
		{
			MethodName: "GetDiff",
			Handler:    _VmDaemonService_GetDiff_Handler,
		},
		{
			MethodName: "GetLinterErrors",
			Handler:    _VmDaemonService_GetLinterErrors_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _VmDaemonService_GetLogs_Handler,
		},
		{
			MethodName: "InstallExtensions",
			Handler:    _VmDaemonService_InstallExtensions_Handler,
		},
		{
			MethodName: "GetMcpTools",
			Handler:    _VmDaemonService_GetMcpTools_Handler,
		},
		{
			MethodName: "TrackModel",
			Handler:    _VmDaemonService_TrackModel_Handler,
		},
		{
			MethodName: "CallDiagnosticsExecutor",
			Handler:    _VmDaemonService_CallDiagnosticsExecutor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}

const (
	WebProfilingService_SubmitInteractionWindow_FullMethodName = "/aiserver.v1.WebProfilingService/SubmitInteractionWindow"
)

// WebProfilingServiceClient is the client API for WebProfilingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Source: aiserver.v1.WebProfilingService (var: oze)
type WebProfilingServiceClient interface {
	SubmitInteractionWindow(ctx context.Context, in *SubmitInteractionWindowRequest, opts ...grpc.CallOption) (*SubmitInteractionWindowResponse, error)
}

type webProfilingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWebProfilingServiceClient(cc grpc.ClientConnInterface) WebProfilingServiceClient {
	return &webProfilingServiceClient{cc}
}

func (c *webProfilingServiceClient) SubmitInteractionWindow(ctx context.Context, in *SubmitInteractionWindowRequest, opts ...grpc.CallOption) (*SubmitInteractionWindowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitInteractionWindowResponse)
	err := c.cc.Invoke(ctx, WebProfilingService_SubmitInteractionWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProfilingServiceServer is the server API for WebProfilingService service.
// All implementations must embed UnimplementedWebProfilingServiceServer
// for forward compatibility.
//
// Source: aiserver.v1.WebProfilingService (var: oze)
type WebProfilingServiceServer interface {
	SubmitInteractionWindow(context.Context, *SubmitInteractionWindowRequest) (*SubmitInteractionWindowResponse, error)
	mustEmbedUnimplementedWebProfilingServiceServer()
}

// UnimplementedWebProfilingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWebProfilingServiceServer struct{}

func (UnimplementedWebProfilingServiceServer) SubmitInteractionWindow(context.Context, *SubmitInteractionWindowRequest) (*SubmitInteractionWindowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SubmitInteractionWindow not implemented")
}
func (UnimplementedWebProfilingServiceServer) mustEmbedUnimplementedWebProfilingServiceServer() {}
func (UnimplementedWebProfilingServiceServer) testEmbeddedByValue()                             {}

// UnsafeWebProfilingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProfilingServiceServer will
// result in compilation errors.
type UnsafeWebProfilingServiceServer interface {
	mustEmbedUnimplementedWebProfilingServiceServer()
}

func RegisterWebProfilingServiceServer(s grpc.ServiceRegistrar, srv WebProfilingServiceServer) {
	// If the following call panics, it indicates UnimplementedWebProfilingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WebProfilingService_ServiceDesc, srv)
}

func _WebProfilingService_SubmitInteractionWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitInteractionWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProfilingServiceServer).SubmitInteractionWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProfilingService_SubmitInteractionWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProfilingServiceServer).SubmitInteractionWindow(ctx, req.(*SubmitInteractionWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProfilingService_ServiceDesc is the grpc.ServiceDesc for WebProfilingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProfilingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aiserver.v1.WebProfilingService",
	HandlerType: (*WebProfilingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitInteractionWindow",
			Handler:    _WebProfilingService_SubmitInteractionWindow_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "aiserver_v1.proto",
}
